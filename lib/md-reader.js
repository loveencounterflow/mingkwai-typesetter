// Generated by CoffeeScript 2.3.2
(function() {
  //###########################################################################################################
  var $, CND, D, HELPERS, MKNCR, MKTS, Markdown_parser, PTVREADER, alert, assign, badge, debug, echo, get_parse_html_methods, help, info, jr, log, misfit, new_md_inline_plugin, njs_fs, njs_path, parse_methods, rpr, tracker_pattern, urge, warn, whisper,
    indexOf = [].indexOf;

  njs_path = require('path');

  njs_fs = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/MD-READER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //-----------------------------------------------------------------------------------------------------------
  D = require('pipedreams');

  $ = D.remit.bind(D);

  // $async                    = D.remit_async.bind D
  //...........................................................................................................
  Markdown_parser = require('markdown-it');

  // Html_parser               = ( require 'htmlparser2' ).Parser
  new_md_inline_plugin = require('markdown-it-regexp');

  //...........................................................................................................
  HELPERS = require('./helpers');

  //...........................................................................................................
  misfit = Symbol('misfit');

  MKTS = require('./main');

  this.TYPOFIX = require('./md-reader-typofix');

  //...........................................................................................................
  assign = Object.assign;

  jr = JSON.stringify;

  MKNCR = require('../../mingkwai-ncr');

  PTVREADER = require('./ptv-reader');

  //-----------------------------------------------------------------------------------------------------------
  this._get_badge = function(delta = 0) {
    /* Experimental, to be used with remarks when things got omitted or inserted. */
    var caller_info, method_name, ref;
    caller_info = CND.get_caller_info(delta + 2);
    // filename    = njs_path.basename caller_info[ 'route' ]
    // line_nr     = caller_info[ 'line-nr' ]
    method_name = (ref = caller_info['function-name']) != null ? ref : caller_info['method-name'];
    method_name = method_name.replace(/^__dirname\./, '');
    // return "#{filename}/#{method_name}"
    return method_name;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._get_remark = function(delta = 0) {
    var my_badge;
    my_badge = this._get_badge(delta + 1);
    return (kind, message, meta) => {
      return this.stamp([
        '#',
        kind,
        message,
        this.copy(meta,
        {
          badge: my_badge
        })
      ]);
    };
  };

  // send stamp [ '#', 'insert', my_badge, "inserting `p` tag", ( copy meta ), ]

  //===========================================================================================================
  // MD / HTML PARSING
  //-----------------------------------------------------------------------------------------------------------
  this._new_markdown_parser = function() {
    var R, feature_set, settings;
    //.........................................................................................................
    /* https://markdown-it.github.io/markdown-it/#MarkdownIt.new */
    // feature_set = 'commonmark'
    feature_set = 'zero';
    //.........................................................................................................
    settings = {
      html: true, // Enable HTML tags in source
      xhtmlOut: false, // Use '/' to close single tags (<br />)
      breaks: false, // Convert '\n' in paragraphs into <br>
      langPrefix: 'language-', // CSS language prefix for fenced blocks
      linkify: true, // Autoconvert URL-like text to links
      typographer: true,
      quotes: '“”‘’'
    };
    // quotes:         '""\'\''
    // quotes:         '""`\''
    // quotes:         [ '<<', '>>', '!!!', '???', ]
    // quotes:   ['«\xa0', '\xa0»', '‹\xa0', '\xa0›'] # French
    //.........................................................................................................
    R = new Markdown_parser(feature_set, settings);
    // R = new Markdown_parser settings
    // .enable 'newline'
    // .enable 'entity'
    // .enable 'code'
    // .enable 'hr'
    // .enable 'lheading'
    // .enable 'linkify'
    // .enable 'replacements'
    R.enable('text').enable('escape').enable('backticks').enable('strikethrough').enable('emphasis').enable('link').enable('image').enable('autolink').enable('html_inline').enable('fence').enable('blockquote').enable('list').enable('reference').enable('heading').enable('html_block').enable('table').enable('paragraph').enable('normalize').enable('block').enable('inline').enable('smartquotes');
    //.......................................................................................................
    R.use(require('markdown-it-footnote'));
    // R.use require 'markdown-it-multimd-table'
    // R.use require 'markdown-it-mark'
    // R.use require 'markdown-it-sub'
    // R.use require 'markdown-it-sup'
    //.......................................................................................................
    // ### sample plugin ###
    // user_pattern  = /@(\w+)/
    // user_handler  = ( match, utils ) ->
    //   url = 'http://example.org/u/' + match[ 1 ]
    //   return '<a href="' + utils.escape(url) + '">' + utils.escape(match[1]) + '</a>'
    // user_plugin = new_md_inline_plugin user_pattern, user_handler
    // R.use user_plugin
    //.......................................................................................................
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  get_parse_html_methods = function() {
    var PARSE5, R, _resolve_html_attributes, get_message;
    PARSE5 = require('parse5');
    get_message = function(source) {
      return `expected single opening node, got ${rpr(source)}`;
    };
    R = {};
    //.........................................................................................................
    _resolve_html_attributes = function(facets) {
      var facet;
      return assign({}, ...((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = facets.length; i < len; i++) {
          facet = facets[i];
          results.push({
            [`${facet.name}`]: facet.value
          });
        }
        return results;
      })()));
    };
    //.........................................................................................................
    R['_parse_html_open_or_lone_tag'] = function(source) {
      var cn, cns, is_lone_tag, position, ref, tree;
      if (is_lone_tag = source.endsWith('/>')) {
        position = 'lone';
        source = source.slice(0, source.length - 2) + '>';
      } else {
        position = 'begin';
      }
      tree = PARSE5.parseFragment(source);
      if ((cns = tree['childNodes']).length !== 1) {
        throw new Error(get_message(source));
      }
      cn = cns[0];
      if (((ref = cn['childNodes']) != null ? ref.length : void 0) !== 0) {
        throw new Error(get_message(source));
      }
      return [position, cn['tagName'], _resolve_html_attributes(cn['attrs'])];
    };
    // return [ 'begin', cn[ 'tagName' ], cn[ 'attrs' ][ 0 ] ? {}, ]
    //.........................................................................................................
    R['_parse_html_block'] = function(source) {
      var tree;
      tree = PARSE5.parseFragment(source);
      debug('@88817', tree);
      return null;
    };
    //.........................................................................................................
    return R;
  };

  //...........................................................................................................
  parse_methods = get_parse_html_methods();

  this._parse_html_open_or_lone_tag = parse_methods['_parse_html_open_or_lone_tag'];

  this._parse_html_block = parse_methods['_parse_html_block'];

  //-----------------------------------------------------------------------------------------------------------
  this._parse_html_tag = function(source) {
    var match;
    if ((match = source.match(this._parse_html_tag.close_tag_pattern)) != null) {
      return ['end', match[1]];
    }
    if ((match = source.match(this._parse_html_tag.comment_pattern)) != null) {
      return ['comment', 'comment', match[1]];
    }
    return this._parse_html_open_or_lone_tag(source);
  };

  this._parse_html_tag.close_tag_pattern = /^<\/([^>]+)>$/;

  this._parse_html_tag.comment_pattern = /^<!--([\s\S]*)-->$/;

  //===========================================================================================================
  // FENCES
  //-----------------------------------------------------------------------------------------------------------
  this.FENCES = {};

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT moving to parentheses-only syntax; note that most of the `FENCES` submodule can then go */
  this.FENCES.left = ['('];

  this.FENCES.right = [')'];

  this.FENCES.pairs = {
    '(': ')',
    ')': '('
  };

  //-----------------------------------------------------------------------------------------------------------
  this.FENCES._get_opposite = (fence, fallback) => {
    var R;
    if ((R = this.FENCES.pairs[fence]) == null) {
      if (fallback !== void 0) {
        return fallback;
      }
      throw new Error(`unknown fence: ${rpr(fence)}`);
    }
    return R;
  };

  //===========================================================================================================
  // TRACKER
  //-----------------------------------------------------------------------------------------------------------
  this.TRACKER = {};

  //-----------------------------------------------------------------------------------------------------------
  tracker_pattern = /^([.!$(]?)([^\s.!$()]*)([)]?)$/;

  //-----------------------------------------------------------------------------------------------------------
  this.FENCES.parse = (pattern, settings) => {
    var _, left_fence, match, name, ref, right_fence, symmetric;
    left_fence = null;
    name = null;
    right_fence = null;
    symmetric = (ref = settings != null ? settings['symmetric'] : void 0) != null ? ref : true;
    //.........................................................................................................
    if ((pattern == null) || pattern.length === 0) {
      throw new Error(`pattern must be non-empty, got ${rpr(pattern)}`);
    }
    //.........................................................................................................
    match = pattern.match(this.TRACKER._tracker_pattern);
    if (match == null) {
      throw new Error(`not a valid pattern: ${rpr(pattern)}`);
    }
    //.........................................................................................................
    [_, left_fence, name, right_fence] = match;
    if (left_fence.length === 0) {
      left_fence = null;
    }
    if (name.length === 0) {
      name = null;
    }
    if (right_fence.length === 0) {
      right_fence = null;
    }
    //.........................................................................................................
    if (left_fence === '.') {
      /* Can not have a right fence if left fence is a dot */
      if (right_fence != null) {
        throw new Error(`fence '.' can not have right fence, got ${rpr(pattern)}`);
      }
    } else {
      /* Except for dot fence, must always have no fence or both fences in case `symmetric` is set */
      //.........................................................................................................
      if (symmetric) {
        if (((left_fence != null) && (right_fence == null)) || ((right_fence != null) && (left_fence == null))) {
          throw new Error(`unmatched fence in ${rpr(pattern)}`);
        }
      }
    }
    //.........................................................................................................
    if ((left_fence != null) && left_fence !== '.') {
      /* Complain about unknown left fences */
      if (indexOf.call(this.FENCES.left, left_fence) < 0) {
        throw new Error(`illegal left_fence in pattern ${rpr(pattern)}`);
      }
      if (right_fence != null) {
        /* Complain about non-matching fences */
        if ((this.FENCES._get_opposite(left_fence, null)) !== right_fence) {
          throw new Error(`fences don't match in pattern ${rpr(pattern)}`);
        }
      }
    }
    if (right_fence != null) {
      /* Complain about unknown right fences */
      if (indexOf.call(this.FENCES.right, right_fence) < 0) {
        throw new Error(`illegal right_fence in pattern ${rpr(pattern)}`);
      }
    }
    //.........................................................................................................
    return [left_fence, name, right_fence];
  };

  //-----------------------------------------------------------------------------------------------------------
  this.TRACKER._tracker_pattern = tracker_pattern;

  //-----------------------------------------------------------------------------------------------------------
  this.TRACKER.new_tracker = (...patterns) => {
    var _MKTS, self;
    _MKTS = this;
    //.........................................................................................................
    self = function(event) {
      var event_name, left_fence, parts, pattern, pattern_name, ref, right_fence, state, type;
      ref = self._states;
      // CND.dir self
      // debug '@763', "tracking event #{rpr event}"
      for (pattern in ref) {
        state = ref[pattern];
        ({parts} = state);
        if (!_MKTS.select(event, ...parts)) {
          continue;
        }
        [[left_fence, right_fence], pattern_name] = parts;
        [type, event_name] = event;
        if (type === left_fence) {
          // debug '@1', pattern, yes
          self._enter(state);
        } else {
          // debug '@2', pattern, no
          self._leave(state);
          if (state['count'] < 0) {
            /* TAINT shouldn't throw error but issue warning remark */
            throw new Error(`too many right fences: ${rpr(event)}`);
          }
        }
      }
      return event;
    };
    //.........................................................................................................
    self._states = {};
    //.........................................................................................................
    self._get_state = function(pattern) {
      var R;
      if ((R = self._states[pattern]) == null) {
        throw new Error(`untracked pattern ${rpr(pattern)}`);
      }
      return R;
    };
    //.........................................................................................................
    self.within = function(...patterns) {
      var i, len, pattern;
      for (i = 0, len = patterns.length; i < len; i++) {
        pattern = patterns[i];
        if (self._within(pattern)) {
          return true;
        }
      }
      return false;
    };
    self._within = function(pattern) {
      return (self._get_state(pattern))['count'] > 0;
    };
    //.........................................................................................................
    self.enter = function(pattern) {
      return self._enter(self._get_state(pattern));
    };
    self.leave = function(pattern) {
      return self._leave(self._get_state(pattern));
    };
    self._enter = function(state) {
      return state['count'] += +1;
    };
    /* TAINT should validate count when leaving */
    self._leave = function(state) {
      return state['count'] += -1;
    };
    (function() {      //.........................................................................................................
      var i, left_fence, len, pattern, pattern_name, results, right_fence, state;
      results = [];
      for (i = 0, len = patterns.length; i < len; i++) {
        pattern = patterns[i];
        [left_fence, pattern_name, right_fence] = _MKTS.FENCES.parse(pattern);
        state = {
          parts: [[left_fence, right_fence], pattern_name],
          count: 0
        };
        results.push(self._states[pattern] = state);
      }
      return results;
    })();
    //.........................................................................................................
    return self;
  };

  //===========================================================================================================
  // _PRE (PREPROCESSING)
  //-----------------------------------------------------------------------------------------------------------
  this._PRE = {};

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$configuration = (S) => {
    var within_configuration, within_preamble;
    within_configuration = false;
    within_preamble = true;
    if (!((S.configuration != null) && CND.isa_pod(S.configuration))) {
      throw new Error(`(internal error) need \`S.configuration\`, got ${rpr(S.configuration)}`);
    }
    //.........................................................................................................
    return $((event, send) => {
      var Q, base, base1, meta, name, text, type;
      // debug '33533', jr event
      //.......................................................................................................
      if (this.select(event, '(', 'configuration')) {
        [type, name, Q, meta] = event;
        if (Q.type == null) {
          Q.type = 'ptv';
        }
        //.....................................................................................................
        /* TAINT simplified temporary solution */
        if (Q.type !== 'ptv') {
          throw new Error(`expected 'ptv' for configuration type, got ${rpr(Q.type)}`);
        }
        //.....................................................................................................
        send(this.stamp(event));
        within_configuration = true;
        if (!within_preamble) {
          throw new Error(`configuration must appear in preamble of document, got ${jr(event)}`);
        }
      //.......................................................................................................
      } else if (this.select(event, ')', 'configuration')) {
        send(this.stamp(event));
        within_configuration = false;
        text = ((base = S.configuration).lines != null ? base.lines : base.lines = []).join('');
        delete S.configuration.lines;
        PTVREADER.cast_values(PTVREADER.update_hash_from_text(text, S.configuration));
      //.......................................................................................................
      } else if (within_configuration && this.select(event, '.', 'text')) {
        [type, name, text, meta] = event;
        ((base1 = S.configuration).lines != null ? base1.lines : base1.lines = []).push(text);
      // send @stamp event
      //.......................................................................................................
      } else if (this.select(event, ['.', '('], 'document')) {
        within_preamble = false;
        send(event);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$custom_entities = (S) => {
    return $((event, send) => {
      var i, is_plain, len, meta, name, part, ref, results, text, type;
      if (this.select(event, '.', 'text')) {
        [type, name, text, meta] = event;
        is_plain = false;
        ref = text.split(/&([^\s#&;]+);/g);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          part = ref[i];
          if ((is_plain = !is_plain)) {
            if (part.length > 0) {
              results.push(send([type, name, part, this.copy(meta)]));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(send(['.', 'entity', part, this.copy(meta)]));
          }
        }
        return results;
      } else {
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$spurious_ampersand = (S) => {
    return $((event, send) => {
      var i, is_plain, len, meta, name, part, ref, results, text, type;
      if (this.select(event, '.', 'text')) {
        [type, name, text, meta] = event;
        is_plain = false;
        ref = text.split(/(&[^\s;]+(?:;|\s|$))/g);
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          part = ref[i];
          // /^&([a-z][-a-z0-9]*)#x[0-9a-f]+;$/
          if ((is_plain = !is_plain) || ((part.match(MKNCR._xncr_matcher)) != null)) {
            if (part.length > 0) {
              results.push(send([type, name, part, this.copy(meta)]));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(send(['.', 'spurious-ampersand', part, this.copy(meta)]));
          }
        }
        return results;
      } else {
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$flatten_inline_tokens = (S) => {
    return $(function(token, send) {
      var i, len, ref, results, sub_token, type;
      if ((type = token['type']) === 'inline') {
        ref = token['children'];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          sub_token = ref[i];
          results.push(send(sub_token));
        }
        return results;
      } else {
        return send(token);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$flatten_image_tokens = (S) => {
    return $(function(token, send) {
      var attribute_name, attribute_value, i, j, len, len1, ref, ref1, src, sub_token, type;
      if ((type = token['type']) === 'image') {
        src = null;
        ref = token['attrs'];
        for (i = 0, len = ref.length; i < len; i++) {
          [attribute_name, attribute_value] = ref[i];
          if (attribute_name === 'src') {
            src = attribute_value;
            break;
          }
        }
        send({
          type: 'image_open',
          src,
          map: token['map']
        });
        ref1 = token['children'];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          sub_token = ref1[j];
          send(sub_token);
        }
        return send({
          type: 'image_close',
          src,
          map: token['map']
        });
      } else {
        return send(token);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$reinject_html_blocks = (S) => {
    /* re-inject HTML blocks */
    var md_parser;
    md_parser = this._new_markdown_parser();
    return $((token, send) => {
      /* TAINT `map` location data is borked with this method */
      /* add extraneous text content; this causes the parser to parse the HTML block as a paragraph
      with some inline HTML: */
      /* remove extraneous text content: */
      var XXX_source, environment, i, len, map, ref, ref1, ref2, removed, results, tokens, type;
      ({type, map} = token);
      if (type !== 'html_block') {
        return send(token);
      }
      XXX_source = "XXX" + token['content'];
      // debug '33392-1', token
      // debug '33392-2', XXX_source
      /* for `environment` see https://markdown-it.github.io/markdown-it/#MarkdownIt.parse */
      /* TAINT what to do with useful data appearing in `environment`? */
      environment = {};
      tokens = md_parser.parse(XXX_source, environment);
      removed = (ref = tokens[1]) != null ? (ref1 = ref['children']) != null ? ref1.splice(0, 1) : void 0 : void 0;
      if (((ref2 = removed[0]) != null ? ref2['content'] : void 0) !== "XXX") {
        debug('29282', "offending token:", token);
        throw new Error("should never happen (1):\nerror in MD-READER _PRE.$reinject_html_blocks");
      }
      results = [];
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        results.push(S.confluence.write(token));
      }
      return results;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$rewrite_markdownit_tokens = (S) => {
    var _send, end_token, is_first, last_link_href, last_map, remark, send_unknown, unknown_tokens, within_footnote_block;
    unknown_tokens = [];
    is_first = true;
    last_map = [0, 0];
    _send = null;
    remark = this._get_remark();
    within_footnote_block = false;
    end_token = Symbol.for('end');
    last_link_href = null;
    //.........................................................................................................
    send_unknown = (token, meta) => {
      var type;
      ({type} = token);
      _send(['?', type, token['content'], meta]);
      if (indexOf.call(unknown_tokens, type) < 0) {
        return unknown_tokens.push(type);
      }
    };
    //.........................................................................................................
    // return $ ( token, send, end ) =>
    return $((token, send) => {
      var attribute_name, attribute_value, col_nr, extra, h_level, i, id, j, language_name, len, len1, line_nr, map, markup, meta, name, position, ref, ref1, ref2, ref3, tag, text_meta, type;
      // info '36372', JSON.stringify token
      _send = send;
      //.......................................................................................................
      if (token === end_token) {
        if (unknown_tokens.length > 0) {
          send(remark('warn', `unknown tokens: ${unknown_tokens.sort().join(', ')}`, {}));
        }
        // if is_first
        //   is_first = no
        //   send [ '(', 'document', null, {}, ]
        send([
          ')',
          'document',
          null,
          {
            ref: '35333'
          }
        ]);
        setImmediate(() => {
          return send.end();
        });
      } else if (CND.isa_list(token)) {
        /* TAINT this clause shouldn't be here; we should target resends (which could be source texts
        or MKTS events) to appropriate insertion points in the stream */
        /* pass through re-injected MKTS events */
        send(token);
      } else {
        ({type, map, markup} = token);
        if (map == null) {
          map = last_map;
        }
        line_nr = ((ref = map[0]) != null ? ref : 0) + 1;
        col_nr = ((ref1 = map[1]) != null ? ref1 : 0) + 1;
        //.....................................................................................................
        meta = {line_nr, col_nr, markup};
        // if is_first
        //   is_first = no
        //   send [ '(', 'document', null, meta, ]
        // #.....................................................................................................
        // if type in [
        //   'footnote_ref',
        //   'footnote_open', 'footnote_close',
        //   'footnote_anchor',
        //   'footnote_block_open', 'footnote_block_close', ]
        //   whisper '@a20g', token[ 'type' ]
        //.....................................................................................................
        if (type === 'footnote_block_open') {
          within_footnote_block = true;
        }
        //.....................................................................................................
        if (within_footnote_block || !S.has_ended) {
          // urge '@a20g', token[ 'type' ]#, within_footnote_block
          switch (type) {
            // blocks
            case 'paragraph_open':
              send(this.hide(['~', 'start-paragraph', null, meta]));
              break;
            case 'paragraph_close':
              send(['.', 'p', null, meta]);
              break;
            case 'bullet_list_open':
              send(['(', 'ul', null, meta]);
              break;
            case 'bullet_list_close':
              send([')', 'ul', null, meta]);
              break;
            case 'list_item_open':
              send(['(', 'li', null, meta]);
              break;
            case 'list_item_close':
              send([')', 'li', null, meta]);
              break;
            case 'blockquote_open':
              send(['(', 'blockquote', null, meta]);
              break;
            case 'blockquote_close':
              send([')', 'blockquote', null, meta]);
              break;
            // inlines
            // singles
            case 'text':
              send(['.', 'text', token['content'], meta]);
              break;
            case 'hr':
              send(['.', 'hr', token['markup'], meta]);
              break;
            //.................................................................................................
            // specials
            //.................................................................................................
            // when 'strong_open'        then send [ '(', 'strong',        null,                         meta, ]
            // when 'strong_close'       then send [ ')', 'strong',        null,                         meta, ]
            // when 'em_open'            then send [ '(', 'em',            null,                         meta, ]
            // when 'em_close'           then send [ ')', 'em',            null,                         meta, ]
            case 'strong_open':
            case 'strong_close':
            case 'em_open':
            case 'em_close':
              type = token['type'].endsWith('open') ? '(' : ')';
              name = (function() {
                switch (token['markup']) {
                  case '*':
                    return 'em';
                  case '**':
                    return 'strong';
                  case '_':
                    return 'smallcaps-lower';
                  case '__':
                    return 'smallcaps-upper';
                }
              })();
              send([type, name, null, meta]);
              break;
            case 'heading_open':
              h_level = parseInt(token['tag'][1], 10);
              // urge '44356', [ '(', 'h', h_level, meta, ]
              send(['(', 'h', h_level, meta]);
              break;
            //.................................................................................................
            case 'heading_close':
              h_level = parseInt(token['tag'][1], 10);
              send([')', 'h', h_level, meta]);
              break;
            //.................................................................................................
            case 'link_open':
              ref2 = token['attrs'];
              /* NB markdown-it does not support nested link markup a la `xxx [333 [444](555) 666](777)`;
              as such, we have only to recall the most recent link target when the linking span is closed. */
              for (i = 0, len = ref2.length; i < len; i++) {
                [attribute_name, attribute_value] = ref2[i];
                if (attribute_name === 'href') {
                  last_link_href = attribute_value;
                  break;
                }
              }
              send(['(', 'link', last_link_href, meta]);
              break;
            //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            case 'link_close':
              send([')', 'link', last_link_href, meta]);
              last_link_href = null;
              break;
            //.................................................................................................
            case 'image_open':
              meta['src'] = token['src'];
              send(['(', 'image', null, meta]);
              break;
            //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            case 'image_close':
              meta['src'] = token['src'];
              send([')', 'image', null, meta]);
              break;
            //.................................................................................................
            case 'code_inline':
              text_meta = this.copy(meta);
              text_meta['markup'] = '';
              send(['(', 'code-span', null, meta]);
              send(['.', 'text', token['content'], text_meta]);
              send([')', 'code-span', null, this.copy(meta)]);
              break;
            //.................................................................................................
            case 'footnote_ref':
              id = token['meta']['id'];
              send(['.', 'footnote-ref', id, meta]);
              break;
            //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            case 'footnote_open':
              id = token['meta']['id'];
              send(['(', 'footnote-def', id, meta]);
              break;
            //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            case 'footnote_close':
              send([')', 'footnote-def', null, meta]);
              break;
            //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            case 'footnote_anchor':
              null;
              break;
            // send remark 'drop', "footnote anchor is dispensable", ( @copy meta )
            //  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
            case 'footnote_block_open':
            case 'footnote_block_close':
              null;
              break;
            // send remark 'drop', "footnote block processed", ( @copy meta )
            //.................................................................................................
            case 'table_open':
            case 'table_close':
            case 'tbody_open':
            case 'tbody_close':
            case 'td_open':
            case 'td_close':
            case 'th_open':
            case 'th_close':
            case 'thead_open':
            case 'thead_close':
            case 'tr_open':
            case 'tr_close':
              // debug '982342', token
              if (type === 'th_open' && (token['attrs'] != null)) {
                ref3 = token['attrs'];
                for (j = 0, len1 = ref3.length; j < len1; j++) {
                  [attribute_name, attribute_value] = ref3[j];
                  if (attribute_name === 'style') {
                    (meta['table'] != null ? meta['table'] : meta['table'] = {})['style'] = attribute_value;
                    break;
                  }
                }
              }
              [tag, position] = type.split('_');
              send([(position === 'open' ? '(' : ')'), tag, null, meta]);
              break;
            //.................................................................................................
            case 'html_block':
              debug('29281', "offending token:", token);
              throw new Error("should never happen (2)");
            //.................................................................................................
            case 'fence':
              switch (token['tag']) {
                case 'code':
                  language_name = token['info'];
                  if (language_name.length === 0) {
                    language_name = 'text';
                  }
                  send(['(', 'code', language_name, meta]);
                  send(['.', 'text', token['content'], this.copy(meta)]);
                  send([')', 'code', language_name, this.copy(meta)]);
                  break;
                default:
                  send_unknown(token, meta);
              }
              break;
            //.................................................................................................
            case 'html_inline':
              [position, name, extra] = this._parse_html_tag(token['content']);
              meta.markup = token['content'];
              switch (position) {
                case 'comment':
                  send(['.', 'comment', extra.trim(), meta]);
                  break;
                case 'begin':
                  if (name !== 'p') {
                    send(['(', name, extra, meta]);
                  }
                  break;
                case 'end':
                  if (name === 'p') {
                    send(['.', name, null, meta]);
                  } else {
                    send([')', name, null, meta]);
                  }
                  break;
                case 'lone':
                  send(['.', name, extra, meta]);
                  break;
                default:
                  throw new Error(`unknown HTML tag position ${rpr(position)}`);
              }
              break;
            default:
              // debug '@26.05', token
              //.................................................................................................
              send_unknown(token, meta);
          }
          //...................................................................................................
          last_map = map;
        }
        //.....................................................................................................
        if (type === 'footnote_block_close') {
          within_footnote_block = false;
        }
      }
      // #.......................................................................................................
      // if end?
      //   if unknown_tokens.length > 0
      //     send remark 'warn', "unknown tokens: #{unknown_tokens.sort().join ', '}", {}
      //   send [ ')', 'document', null, {}, ]
      //   # setImmediate => end()
      //   setTimeout ( => end() ), 1000
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$issue_administrative_events = (S) => {
    var sent_end_document;
    sent_end_document = false;
    //.........................................................................................................
    return $((event, send, end) => {
      var meta, name, text, type;
      if (event != null) {
        [type, name, text, meta] = event;
        //.......................................................................................................
        if (this.select(event, ['.', '('], 'document')) {
          send(['~', 'start', null, this.copy(meta)]);
          send(['~', 'flush', null, this.copy(meta)]);
          send(['(', 'document', null, this.copy(meta)]);
        //.......................................................................................................
        } else if (this.select(event, ')', 'document')) {
          sent_end_document = true;
          send(event);
        } else {
          //.......................................................................................................
          send(event);
        }
      }
      //.......................................................................................................
      if (end != null) {
        warn('34744', 'end');
        if (!sent_end_document) {
          sent_end_document = true;
          send([')', 'document', null, {}]);
        }
        send(['~', 'stop', null, {}]);
        end();
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$process_end_command = (S) => {
    var remark;
    S.has_ended = false;
    remark = this._get_remark();
    //.........................................................................................................
    return $((event, send) => {
      var _, line_nr, meta;
      // [ type, name, text, meta, ] = event
      if (this.select(event, '!', 'end')) {
        if (!S.has_ended) {
          [_, _, _, meta] = event;
          ({line_nr} = meta);
          /* TAINT consider to re-send `document>` */
          send(this.stamp(event));
          send(remark('info', `encountered \`<<!end>>\` on line #${line_nr}`, this.copy(meta)));
          S.has_ended = true;
        }
      } else {
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$consolidate_tables_1 = (S) => {
    /* TAINT assumes unnested tables without merged cells */
    var alignments, col_count, collecting, collector, description, track;
    track = this.TRACKER.new_tracker('(table)');
    collector = [];
    collecting = false;
    col_count = null;
    alignments = null;
    description = null;
    //.........................................................................................................
    return $((event, send) => {
      /* TAINT relying on very specific format detail here; need `{ style: 'text-align:xxx' }` */
      var i, len, meta, name, past_event, ref, ref1, style, style_name, style_value, table_meta, text, type, within_table;
      [type, name, text, meta] = event;
      within_table = track.within('(table)');
      track(event);
      //.......................................................................................................
      if (this.select(event, '(', 'table')) {
        if (collecting) {
          return send(['.', 'warning', "detected nested tables", this.copy(meta)]);
        }
        collecting = true;
        alignments = [];
        description = {};
        if (meta['table'] == null) {
          meta['table'] = description;
        }
        return collector.push(event);
      //.......................................................................................................
      } else if (collecting) {
        //.....................................................................................................
        if (this.select(event, '(', ['td', 'th'])) {
          collector.push(event);
          col_count += +1;
          style = (ref = (ref1 = meta['table']) != null ? ref1['style'] : void 0) != null ? ref : 'text-align:left';
          [style_name, style_value] = style.split(':');
          if (style_name === 'text-align') {
            return alignments.push(style_value);
          } else {
            return alignments.push('left');
          }
        //.....................................................................................................
        } else if (this.select(event, ')', 'tr')) {
          description['col_count'] = col_count;
          description['alignments'] = alignments;
          for (i = 0, len = collector.length; i < len; i++) {
            past_event = collector[i];
            send(past_event);
          }
          send(event);
          collector.length = 0;
          col_count = 0;
          collecting = false;
          alignments = null;
          return table_meta = null;
        } else {
          //.....................................................................................................
          return collector.push(event);
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$consolidate_tables_2 = (S) => {
    var collector, description, row_count, within_table;
    collector = [];
    description = null;
    row_count = 0;
    within_table = false;
    //.........................................................................................................
    return $((event, send) => {
      var cached_event, i, len, meta, name, text, type;
      [type, name, text, meta] = event;
      //.......................................................................................................
      if (this.select(event, '(', 'table')) {
        within_table = true;
        description = meta['table'];
        return collector.push(event);
      }
      if (!within_table) {
        //.......................................................................................................
        return send(event);
      }
      //.......................................................................................................
      if (this.select(event, ')', 'table')) {
        within_table = false;
        description['row_count'] = row_count;
        description = null;
        for (i = 0, len = collector.length; i < len; i++) {
          cached_event = collector[i];
          send(cached_event);
        }
        send(event);
        collector.length = 0;
        row_count = 0;
      //.......................................................................................................
      } else if (this.select(event, '(', 'tr')) {
        row_count += +1;
        collector.push(event);
      } else {
        //.......................................................................................................
        collector.push(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$consolidate_footnotes = (S) => {
    var collector, current_footnote_events, current_footnote_id, idx_by_ids, track, within_footnote_def;
    track = this.TRACKER.new_tracker('(footnote-def)');
    collector = [];
    idx_by_ids = new Map();
    current_footnote_events = [];
    current_footnote_id = null;
    within_footnote_def = false;
    //.........................................................................................................
    return $((event, send, end) => {
      var events, i, id, j, len, len1, message, meta, name, target_idx, type;
      if (event != null) {
        within_footnote_def = track.within('(footnote-def)');
        track(event);
        //.....................................................................................................
        if (this.select(event, '.', 'footnote-ref')) {
          [type, name, id, meta] = event;
          collector.push([['(', 'footnote', id, this.copy(meta)]]);
          idx_by_ids.set(id, collector.length);
          collector.push([]);
          collector.push([[')', 'footnote', id, this.copy(meta)]]);
        //.....................................................................................................
        } else if (this.select(event, '(', 'footnote-def')) {
          [type, name, id, meta] = event;
          current_footnote_id = id;
        //.....................................................................................................
        } else if (this.select(event, ')', 'footnote-def')) {
          current_footnote_id = null;
        } else {
          //.....................................................................................................
          if (within_footnote_def) {
            target_idx = idx_by_ids.get(current_footnote_id);
            if (!target_idx) {
              message = `unknown footnote ID ${rpr(current_footnote_id)}`;
              // send.error new Error message
              send(['.', 'warning', message, this.copy(meta != null ? meta : {})]);
            } else {
              collector[target_idx].push(event);
            }
          } else {
            collector.push([event]);
          }
        }
      }
      //.......................................................................................................
      if (end != null) {
        for (i = 0, len = collector.length; i < len; i++) {
          events = collector[i];
          for (j = 0, len1 = events.length; j < len1; j++) {
            event = events[j];
            send(event);
          }
        }
        return end();
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$close_dangling_open_tags = (S) => {
    var remark, tag_stack;
    tag_stack = [];
    remark = this._get_remark();
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, sub_event, sub_meta, sub_name, sub_text, sub_type, text, type;
      [type, name, text, meta] = event;
      //.......................................................................................................
      if (this.select(event, '(', 'document')) {
        null;
      //.......................................................................................................
      } else if (this.select(event, ')', 'document')) {
        while (tag_stack.length > 0) {
          sub_event = tag_stack.pop();
          [sub_type, sub_name, sub_text, sub_meta] = sub_event;
          sub_type = ')';
          send(remark('resend', `\`${sub_name}${sub_type}\``, this.copy(meta)));
          S.resend([sub_type, sub_name, sub_text, this.copy(sub_meta)]);
        }
      //.......................................................................................................
      } else if (this.select(event, '(')) {
        tag_stack.push([type, name, null, meta]);
      // debug '©18623', tag_stack
      //.......................................................................................................
      } else if (this.select(event, ')')) {
        /* TAINT should check matching pairs */
        tag_stack.pop();
      }
      //.......................................................................................................
      send(event);
      return null;
    });
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @_PRE.$extra_hr = ( S ) =>
  //   pattern     = /// ^ ( °{4,} | \.{4,} | :{4,} | -{4,} | ={4,} | \^{4,} | v{4,} ) $ ///gm
  //   within_code = no
  //   #.........................................................................................................
  //   return $ ( event, send ) =>
  //     #.......................................................................................................
  //     if @select event, '(', [ 'code', 'code-span', ]
  //       within_code = yes
  //       send event
  //     #.......................................................................................................
  //     else if @select event, ')', [ 'code', 'code-span', ]
  //       within_code = no
  //       send event
  //     #.......................................................................................................
  //     else if ( not within_code ) and @select event, '.', 'text'
  //       [ type, name, text, meta, ] = event
  //       is_plain = no
  //       for stretch in text.split pattern
  //         if is_plain = not is_plain
  //           send [ '.', 'text', stretch, ( @copy meta ), ]
  //         else
  //           send [ '.', 'hr', stretch, ( @copy meta ), ]
  //     #.......................................................................................................
  //     else
  //       send event

  //-----------------------------------------------------------------------------------------------------------
  this._PRE.$hr2 = (S) => {
    var analyzer, buffer, code_count, flush, send_;
    /*

    / slash
    - plain (line)
    = bold (line)
    -= plain with bold (2 stacked lines)
    =- bold with plain (2 stacked lines)
    -=- plain, bold, plain (3 stacked lines)
    . dotted (line)
    * asterisks (line)
    + swole (line)
    0 compress (above & below)
    1 normal (spacing, one line above & below; default)
    2,1 custom (2 above, 1 below)
    2 splendid (2 above & below)

    // <!-- just a slash -->
    /0-------/
    0-------
    /2+++++2/
    /0--------============1/
     */
    // splitter    = /// ^ ( \/? [0-9]* [-=*+]{3,} [0-9]* \/? ) $ ///gm
    analyzer = /^(\/?)([0-9]*)(-+|=+|\.+|\*+|\++|\#+|°+)(-*|=*|\.*|\**|\+*|\#*|°*)(-*|=*|\.*|\**|\+*|\#*|°*)([0-9]*)(\1)$/;
    code_count = 0;
    buffer = null;
    send_ = null;
    //.........................................................................................................
    flush = function() {
      var i, len, sub_event;
      if (buffer == null) {
        return;
      }
      for (i = 0, len = buffer.length; i < len; i++) {
        sub_event = buffer[i];
        send_(sub_event);
      }
      return buffer = null;
    };
    //.........................................................................................................
    return $((event, send) => {
      var _, above, below, match, meta, name, one, ref, ref1, ref2, slash, start, stop, text, three, two, type;
      send_ = send;
      //.......................................................................................................
      if (this.select(event, '(', ['code', 'code-span'])) {
        flush();
        code_count += +1;
      // send event
      //.......................................................................................................
      } else if (this.select(event, ')', ['code', 'code-span'])) {
        code_count += -1;
      }
      // send event
      //.......................................................................................................
      if (code_count < 1 && this.select(event, '~', 'start-paragraph', true)) {
        if (buffer != null) {
          throw new Error('XXXX');
        }
        buffer = [];
        return buffer.push(event);
      //.......................................................................................................
      } else if ((buffer != null) && this.select(event, '.', 'p')) {
        buffer.push(event);
        if (!((buffer.length === 3) && this.select(buffer[1], '.', 'text'))) {
          return flush();
        }
        [type, name, text, meta] = buffer[1];
        match = text.match(analyzer);
        if (match == null) {
          return flush();
        }
        buffer = null;
        [_, start, above, one, two, three, below, stop] = match;
        if (start !== stop) {
          return send(['.', 'warning', `illegal HR markup ${rpr(meta['markup'])}`, copy(meta)]);
        }
        slash = start === '/';
        if (above.length === 0) {
          above = '0';
        }
        if (below.length === 0) {
          below = '1';
        }
        above = parseInt(above, 10);
        below = parseInt(below, 10);
        one = (ref = one[0]) != null ? ref : '';
        two = (ref1 = two[0]) != null ? ref1 : '';
        three = (ref2 = three[0]) != null ? ref2 : '';
        return send([
          '.',
          'hr2',
          {slash,
          above,
          one,
          two,
          three,
          below,
          stop},
          this.copy(meta,
          {
            markup: text
          })
        ]);
      // send [ '.', 'hr2', stretch, ( @copy meta ), ]
      //.......................................................................................................
      } else if (buffer != null) {
        buffer.push(event);
        if (buffer.length > 2) {
          return flush();
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.select = function(event, type, name, hidden = false) {
    var arity, ref, ref1, type_of_name, type_of_type;
    if ((!hidden) && this.is_hidden(event)) {
      /* TAINT should use the same syntax as accepted by `FENCES.parse` */
      /* check for arity as it's easy to write `select event, '(', ')', 'latex'` when what you meant
      was `select event, [ '(', ')', ], 'latex'` */
      return false;
    }
    if ((arity = arguments.length) > 4) {
      throw new Error(`expected at most 3 arguments, got ${arity}`);
    }
    if (type != null) {
      switch (type_of_type = CND.type_of(type)) {
        case 'text':
        case 'symbol':
          if (event[0] !== type) {
            return false;
          }
          break;
        case 'list':
          if (ref = event[0], indexOf.call(type, ref) < 0) {
            return false;
          }
          break;
        default:
          throw new Error(`expected a text, a symbol or a list, got a ${type_of_type}`);
      }
    }
    if (name != null) {
      switch (type_of_name = CND.type_of(name)) {
        case 'text':
        case 'symbol':
          if (event[1] !== name) {
            return false;
          }
          break;
        case 'list':
          if (ref1 = event[1], indexOf.call(name, ref1) < 0) {
            return false;
          }
          break;
        default:
          throw new Error(`expected a text, a symbol or a list, got a ${type_of_name}`);
      }
    }
    return true;
  };

  //===========================================================================================================
  // STAMPING & HIDING
  //-----------------------------------------------------------------------------------------------------------
  this.stamp = function(event) {
    /* 'Stamping' an event means to mark it as 'processed'; hence, downstream transformers can choose to
    ignore events that have already been marked upstream, or, inversely choose to look out for events
    that have not yet found a representation in the target document. **NB** that stamping and hiding an
    event will place a copy of the `meta` event element into the event. */
    event[3] = this.copy(event[3], {
      stamped: true
    });
    return event;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unstamp = function(event) {
    event[3] = this.copy(event[3], {
      stamped: false
    });
    return event;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_stamped = function(event) {
    var ref;
    return ((ref = event[3]) != null ? ref['stamped'] : void 0) === true;
  };

  this.is_unstamped = function(event) {
    return !this.is_stamped(event);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.hide = function(event) {
    /* 'Stamping' an event means to mark it as 'processed'; hence, downstream transformers can choose to
    ignore events that have already been marked upstream, or, inversely choose to look out for events
    that have not yet found a representation in the target document. **NB** that stamping and hiding an
    event will place a copy of the `meta` event element into the event. */
    event[3] = this.copy(event[3], {
      hidden: true
    });
    return event;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_hidden = function(event) {
    var ref;
    return ((ref = event[3]) != null ? ref['hidden'] : void 0) === true;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.copy = function(x, ...updates) {
    /* (Hopefully) fast semi-deep copying for events (i.e. lists with a possible `meta` object on
    index 3) and plain objects. The value returned will be a shallow copy in the case of objects and
    lists, but if a list has a value at index 3, that object will also be copied. Not guaranteed to
    work for general values. */
    var R, isa_list, meta;
    if ((isa_list = CND.isa_list(x))) {
      R = [];
    } else if (CND.isa_pod(x)) {
      R = {};
    } else {
      throw new Error(`unable to copy a ${CND.type_of(x)}`);
    }
    R = Object.assign(R, x, ...updates);
    if (isa_list && ((meta = R[3]) != null)) {
      R[3] = Object.assign({}, meta);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._split_lines_with_nl = function(text) {
    var i, len, line, ref, results;
    ref = text.split(/(.*\n)/);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      if (line.length > 0) {
        results.push(line);
      }
    }
    return results;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._flush_text_collector = function(send, collector, meta) {
    if (collector.length > 0) {
      send(['.', 'text', collector.join(''), meta]);
      collector.length = 0;
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$show_illegal_chrs = function(S) {
    /* TAINT if these characters are illegal, we don't have to escape them when tunneling macros */
    /* TAINT must send MKTS events, not TeX to keep method general */
    return $(function(old_text, send) {
      var new_text;
      new_text = old_text.replace(/[\x00-\x08\x0b\x0c\x0e-\x1f\x7f\ufffd-\uffff]/g, function($0) {
        var cid_hex, post, pre;
        cid_hex = ($0.codePointAt(0)).toString(16);
        pre = '█';
        post = '█';
        /* TAINT use mkts command */
        warn(`detected illegal character U+${cid_hex // if old_text isnt new_text
}`);
        return `{\\mktsStyleBold\\color{red}{%\n\\mktsStyleSymbol${pre}}U+${cid_hex}{\\mktsStyleSymbol${post}}}`;
      });
      return send(new_text);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_resender = function(S, stream) {
    /* TAINT re-parsing new source text should be handled by regular stream transform at an appropriate
    stream entry point */
    /* TAINT new parser not needed, can reuse 'main' parser */
    var md_parser;
    md_parser = this._new_markdown_parser();
    return (md_source) => {
      /* Omit `paragraph_open` as first and `paragraph_close` as last token: */
      var environment, first_idx, i, idx, keys, last_idx, ref, ref1, results, tokens;
      /* TAINT must handle data in environment */
      if (CND.isa_text(md_source)) {
        md_source = MKTS.MACRO_ESCAPER.escape(S, md_source);
        md_source = this.TYPOFIX.rewrite(S, md_source);
        environment = {};
        tokens = md_parser.parse(md_source, environment);
        // tokens      = md_parser.parse md_source, S.environment
        //.......................................................................................................
        /* TAINT intermediate solution */
        if ((keys = Object.keys(environment)).length > 0) {
          warn(`ignoring keys from sub-parsing environment: ${rpr(keys)}`);
        }
        //.......................................................................................................
        if (tokens.length > 0) {
          first_idx = 0;
          last_idx = tokens.length - 1;
          first_idx = tokens[first_idx]['type'] === 'paragraph_open' ? first_idx + 1 : first_idx;
          last_idx = tokens[last_idx]['type'] === 'paragraph_close' ? last_idx - 1 : last_idx;
          results = [];
          for (idx = i = ref = first_idx, ref1 = last_idx; (ref <= ref1 ? i <= ref1 : i >= ref1); idx = ref <= ref1 ? ++i : --i) {
            // ( debug '©9fdeD', "resending", tokens[ idx ] ) for idx in [ first_idx .. last_idx ]
            results.push(stream.write(tokens[idx]));
          }
          return results;
        }
      } else {
        return stream.write(md_source);
      }
    };
  };

  //===========================================================================================================
  // STREAM CREATION
  //-----------------------------------------------------------------------------------------------------------
  this.create_md_read_tee = function(S, md_source) {
    var R, arity, input, readstream, settings, writestream;
    switch (arity = arguments.length) {
      case 1:
        md_source = S;
        //.....................................................................................................
        /* for `environment` see https://markdown-it.github.io/markdown-it/#MarkdownIt.parse */
        S = {
          // confluence:           confluence
          environment: {}
        };
        break;
      case 2:
        S.environment = {};
        break;
      default:
        throw new Error(`expected 1 or 2 arguments, got ${arity}`);
    }
    //.........................................................................................................
    /* TAINT `settings`, `S` and fitting should be the same object */
    settings = {
      S: S
    };
    //.........................................................................................................
    /* TAINT rewrite to use D.TEE.from_pipeline, don't use readstream, writestream */
    readstream = D.create_throughstream();
    writestream = D.create_throughstream();
    // confluence  = D.create_throughstream()
    R = D.TEE.from_readwritestreams(readstream, writestream, settings);
    ({input} = R.tee);
    input.pause();
    //.........................................................................................................
    S.resend = this.new_resender(S, readstream);
    S.confluence = readstream;
    // S.confluence = input
    //.........................................................................................................
    // .pipe D.$observe ( event ) -> alert event
    // .pipe D.$observe ( event ) => debug '©1', jr event
    // .pipe @_PRE.$extra_hr                             S
    // .pipe D.$show '47594-B'
    readstream.pipe(this._PRE.$flatten_inline_tokens(S)).pipe(this._PRE.$flatten_image_tokens(S)).pipe(this._PRE.$reinject_html_blocks(S)).pipe(this._PRE.$rewrite_markdownit_tokens(S)).pipe(this._PRE.$configuration(S)).pipe(this._PRE.$custom_entities(S)).pipe(this._PRE.$spurious_ampersand(S)).pipe(this._PRE.$issue_administrative_events(S)).pipe(MKTS.MACRO_ESCAPER.$expand(S)).pipe(this._PRE.$process_end_command(S)).pipe(this._PRE.$consolidate_tables_1(S)).pipe(this._PRE.$consolidate_tables_2(S)).pipe(this._PRE.$consolidate_footnotes(S)).pipe(this._PRE.$hr2(S)).pipe(MKTS.MACRO_INTERPRETER.$prepare_sandbox(S)).pipe(MKTS.MACRO_INTERPRETER.$process_actions(S)).pipe(MKTS.MACRO_INTERPRETER.$process_values(S)).pipe(MKTS.MACRO_INTERPRETER.$process_commands(S)).pipe(MKTS.MACRO_INTERPRETER.$process_regions(S)).pipe(MKTS.MACRO_INTERPRETER.$consolidate_regions(S)).pipe(MKTS.MACRO_INTERPRETER.$process_code_blocks(S)).pipe(this._PRE.$close_dangling_open_tags(S)).pipe(writestream);
    //.........................................................................................................
    // readstream.on     'end', -> debug '©tdfA4', "readstream ended"
    // writestream.on    'end', -> debug '©sId1V', "writestream ended"
    // input.on          'end', -> debug '©1sbYv', "input ended"
    // R[ 'output' ].on  'end', -> debug '©zSMOc', "output ended"
    //.........................................................................................................
    input.on('resume', () => {
      var i, len, md_parser, token, tokens;
      S.t0 = +new Date();
      md_parser = this._new_markdown_parser();
      MKTS.MACRO_ESCAPER.initialize_state(S);
      md_source = MKTS.MACRO_ESCAPER.escape(S, md_source);
      md_source = this.TYPOFIX.rewrite(S, md_source);
      S.chr_count = md_source.length;
      tokens = md_parser.parse(md_source, S.environment);
// debug '©78531', rpr tokens
      for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        input.write(token);
      }
      return input.write(Symbol.for('end'));
    });
    //.........................................................................................................
    return R;
  };

}).call(this);

//# sourceMappingURL=md-reader.js.map
