// Generated by CoffeeScript 2.3.2
(function() {
  //###########################################################################################################
  var CND, FS, MD_READER, OVAL, PATH, PIPEDREAMS3B7B, PS, alert, badge, copy, debug, echo, finished_sym, help, hide, info, is_hidden, is_stamped, jr, log, new_pushable, new_sync_sub_sender, promisify, rpr, select, stamp, unstamp, urge, warn, whisper;

  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/TEX-WRITER/PLUGINS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  // #...........................................................................................................
  // suspend                   = require 'coffeenode-suspend'
  // step                      = suspend.step
  //...........................................................................................................
  PIPEDREAMS3B7B = require('pipedreams-3b7b');

  // PIPEDREAMS                = require 'pipedreams'
  // PIPEDREAMS.$              = PIPEDREAMS.remit.bind PIPEDREAMS
  // PIPEDREAMS.$async         = PIPEDREAMS.remit_async.bind PIPEDREAMS
  // #...........................................................................................................
  // ASYNC                     = require 'async'
  // #...........................................................................................................
  // ƒ                         = CND.format_number.bind CND
  // HELPERS                   = require '../helpers'
  // TEXLIVEPACKAGEINFO        = require '../texlivepackageinfo'
  // options_route             = '../options.coffee'
  // { CACHE, OPTIONS, }       = require '../options-and-cache'
  // SEMVER                    = require 'semver'
  // #...........................................................................................................
  // XNCHR                     = require '../xnchr'
  // MKTS                      = require '../main'
  // MKTSCRIPT_WRITER          = require '../mktscript-writer'
  MD_READER = require('../md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  // MACRO_ESCAPER             = require '../macro-escaper'
  // MACRO_INTERPRETER         = require '../macro-interpreter'
  // LINEBREAKER               = require '../linebreaker'
  // @COLUMNS                  = require '../tex-writer-columns'
  // @MKTS_TABLE               = require '../tex-writer-mkts-table'
  // AUX                       = require '../tex-writer-aux'
  // YADDA                     = require '../yadda'
  OVAL = require('../object-validator');

  // UNITS                     = require '../mkts-table-units'
  //...........................................................................................................
  // Σ_formatted_warning       = Symbol 'formatted-warning'
  promisify = (require('util')).promisify;

  jr = JSON.stringify;

  new_pushable = require('pull-pushable');

  PS = require('pipestreams');

  // { $, $async, }            = PS
  /* TAINT temporary kludge */
  finished_sym = Symbol.for('finished');

  //-----------------------------------------------------------------------------------------------------------
  this._resolve_arguments = (S, Q) => {
    var callable, crumb, crumbs, error, i, len, locator, match, method_path, module, module_path, reference, reference_path;
    reference_path = S.layout_info['source-home'];
    //.....................................................................................................
    if ((match = Q.src.match(/^(?<module_path>.+?)\#(?<method_path>[^\#]+)$/)) != null) {
      ({module_path, method_path} = match.groups);
      if (method_path === '') {
        method_path = null;
      }
    } else {
      //.....................................................................................................
      module_path = Q.src;
      method_path = 'main';
    }
    //.....................................................................................................
    crumbs = method_path != null ? method_path.split('.') : null;
    locator = PATH.join(reference_path, module_path);
    try {
      //.....................................................................................................
      module = require(locator);
      reference = module;
      callable = module;
      if (crumbs != null) {
        for (i = 0, len = crumbs.length; i < len; i++) {
          crumb = crumbs[i];
          reference = callable;
          callable = callable[crumb];
        }
      }
      if (!CND.isa_function(callable)) {
        throw new Error(`not callable: ${rpr(method_path)}`);
      }
      callable = callable.bind(reference);
    } catch (error1) {
      error = error1;
      alert('98987-1', `when trying to resolve ${rpr(Q.src)}`);
      alert('98987-2', `starting with module ${rpr(locator)}`);
      alert('98987-3', "an error occurred");
      throw error;
    }
    //.....................................................................................................
    return Object.assign({}, Q, {locator, module_path, method_path, callable});
  };

  //-----------------------------------------------------------------------------------------------------------
  new_sync_sub_sender = function(transforms) {
    var callback, collector, i, len, pipeline, pushable, transform;
    /* Given a transform, construct a pipeline with a pushable as its source, and
    return a function that accepts a data event to be processed by the pipeline. */
    // The sub-sender works by temporarily attaching a hidden ###
    pushable = new_pushable();
    collector = [];
    pipeline = [];
    callback = null;
    pipeline.push(pushable);
    pipeline.push(PS.$(function(d, send) {
      send(d);
      return send(['~', finished_sym]);
    }));
    for (i = 0, len = transforms.length; i < len; i++) {
      transform = transforms[i];
      pipeline.push(transform);
    }
    pipeline.push(PS.$(function(d, send) {
      if (select(d, '~', finished_sym)) {
        send(collector);
        return collector = [];
      } else {
        return collector.push(d);
      }
    }));
    pipeline.push(PS.$watch(function(d) {
      return callback(d);
    }));
    pipeline.push(PS.$drain());
    PS.pull(...pipeline);
    return function(d, send) {
      callback = send;
      return pushable.push(d);
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$plugins = (S) => {
    var schema, self, validate_and_cast;
    self = this.$plugins;
    schema = {
      postprocess: (Q) => {
        if (!(Q.src.length > 0)) {
          throw new Error(`µ38893 expected non-empty text, got ${jr(Q)}`);
        }
        if (!(Q.prefix.length > 0)) {
          throw new Error(`µ38894 expected non-empty text, got ${jr(Q)}`);
        }
        if (self.known_prefixes.has(Q.prefix)) {
          throw new Error(`µ38895 unable to redefine prefix ${rpr(Q.prefix)}`);
        }
        self.known_prefixes.add(Q.prefix);
        return this._resolve_arguments(S, Q);
      },
      //.......................................................................................................
      properties: {
        src: {
          type: 'string'
        },
        prefix: {
          type: 'string'
        }
      },
      //.......................................................................................................
      additionalProperties: false,
      required: ['src', 'prefix']
    };
    //.........................................................................................................
    validate_and_cast = OVAL.new_validator(schema);
    //.........................................................................................................
    return PIPEDREAMS3B7B.$async((event, send, end) => {
      var Q, callable, meta, name, plugins, settings, type;
      if (select(event, '.', 'plugin')) {
        [type, name, Q, meta] = event;
        Q = validate_and_cast(Q);
        self.callables.push([
          Q.callable,
          {
            prefix: Q.prefix
          }
        ]);
        send(stamp(event));
        send.done();
        //.....................................................................................................
        /* TAINT shouldn't build a new pipeline for each event */
        plugins = (function() {
          var i, len, ref, results;
          ref = self.callables;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            [callable, settings] = ref[i];
            results.push(callable(S, settings));
          }
          return results;
        })();
        self.send_to_plugins = new_sync_sub_sender(plugins);
      //.......................................................................................................
      } else if (self.callables.length > 0) {
        self.send_to_plugins(event, function(events) {
          var i, len;
          for (i = 0, len = events.length; i < len; i++) {
            event = events[i];
            send(event);
          }
          return send.done();
        });
      } else {
        //.......................................................................................................
        send(event);
        send.done();
      }
      if (end != null) {
        //.......................................................................................................
        end();
      }
      return null;
    });
  };

  this.$plugins.callables = [];

  this.$plugins.known_prefixes = new Set();

  this.$plugins.send_to_plugins = null;

}).call(this);

//# sourceMappingURL=tex-writer-plugins.js.map
