// Generated by CoffeeScript 2.3.2
(function() {
  //###########################################################################################################
  var $, $async, CND, D, FS, MD_READER, OVAL, PATH, PS, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, jr, log, new_pushable, new_sync_sub_sender, promisify, rpr, select, stamp, unstamp, urge, warn, whisper;

  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/TEX-WRITER/PLUGIN';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  // #...........................................................................................................
  // suspend                   = require 'coffeenode-suspend'
  // step                      = suspend.step
  //...........................................................................................................
  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  // #...........................................................................................................
  // ASYNC                     = require 'async'
  // #...........................................................................................................
  // ƒ                         = CND.format_number.bind CND
  // HELPERS                   = require '../helpers'
  // TEXLIVEPACKAGEINFO        = require '../texlivepackageinfo'
  // options_route             = '../options.coffee'
  // { CACHE, OPTIONS, }       = require '../options-and-cache'
  // SEMVER                    = require 'semver'
  // #...........................................................................................................
  // XNCHR                     = require '../xnchr'
  // MKTS                      = require '../main'
  // MKTSCRIPT_WRITER          = require '../mktscript-writer'
  MD_READER = require('../md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  // MACRO_ESCAPER             = require '../macro-escaper'
  // MACRO_INTERPRETER         = require '../macro-interpreter'
  // LINEBREAKER               = require '../linebreaker'
  // @COLUMNS                  = require '../tex-writer-columns'
  // @MKTS_TABLE               = require '../tex-writer-mkts-table'
  // AUX                       = require '../tex-writer-aux'
  // YADDA                     = require '../yadda'
  OVAL = require('../object-validator');

  // UNITS                     = require '../mkts-table-units'
  //...........................................................................................................
  // Σ_formatted_warning       = Symbol 'formatted-warning'
  promisify = (require('util')).promisify;

  jr = JSON.stringify;

  new_pushable = require('pull-pushable');

  PS = require('pipestreams');

  // { $, $async, }            = PS

  //-----------------------------------------------------------------------------------------------------------
  this._resolve_arguments = (S, Q) => {
    var callable, crumb, crumbs, error, i, len, locator, match, method_path, module, module_path, reference, reference_path;
    reference_path = S.layout_info['source-home'];
    //.....................................................................................................
    if ((match = Q.src.match(/^(?<module_path>.+?)\#(?<method_path>[^\#]+)$/)) != null) {
      ({module_path, method_path} = match.groups);
      if (method_path === '') {
        method_path = null;
      }
    } else {
      //.....................................................................................................
      module_path = Q.src;
      method_path = 'main';
    }
    //.....................................................................................................
    crumbs = method_path != null ? method_path.split('.') : null;
    locator = PATH.join(reference_path, module_path);
    try {
      //.....................................................................................................
      module = require(locator);
      reference = module;
      callable = module;
      if (crumbs != null) {
        for (i = 0, len = crumbs.length; i < len; i++) {
          crumb = crumbs[i];
          reference = callable;
          callable = callable[crumb];
        }
      }
      if (!CND.isa_function(callable)) {
        throw new Error(`not callable: ${rpr(method_path)}`);
      }
      callable = callable.bind(reference);
    } catch (error1) {
      error = error1;
      alert('98987-1', `when trying to resolve ${rpr(Q.src)}`);
      alert('98987-2', `starting with module ${rpr(locator)}`);
      alert('98987-3', "an error occurred");
      throw error;
    }
    //.....................................................................................................
    return Object.assign({}, Q, {locator, module_path, method_path, callable});
  };

  //-----------------------------------------------------------------------------------------------------------
  new_sync_sub_sender = function(transforms, send) {
    var i, len, pipeline, pushable, transform;
    /* Given a transform, construct a pipeline with a pushable as its source, and
    return a function that accepts a send method and a data event. */
    // The sub-sender works by temporarily attaching a hidden ###
    pushable = new_pushable();
    pipeline = [];
    pipeline.push(pushable);
    for (i = 0, len = transforms.length; i < len; i++) {
      transform = transforms[i];
      pipeline.push(transform);
    }
    pipeline.push(PS.$watch(function(d) {
      return send(d);
    }));
    pipeline.push(PS.$drain());
    PS.pull(...pipeline);
    return function(d) {
      return pushable.push(d);
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$plugins = (S) => {
    var schema, self, validate_and_cast;
    self = this.$plugins;
    schema = {
      postprocess: (Q) => {
        if (!(Q.src.length > 0)) {
          throw new Error(`µ38893 expected non-empty text, got ${jr(Q)}`);
        }
        if (!(Q.prefix.length > 0)) {
          throw new Error(`µ38894 expected non-empty text, got ${jr(Q)}`);
        }
        if (self.known_prefixes.has(Q.prefix)) {
          throw new Error(`µ38895 unable to redefine prefix ${rpr(Q.prefix)}`);
        }
        self.known_prefixes.add(Q.prefix);
        return this._resolve_arguments(S, Q);
      },
      //.......................................................................................................
      properties: {
        src: {
          type: 'string'
        },
        prefix: {
          type: 'string'
        }
      },
      //.......................................................................................................
      additionalProperties: false,
      required: ['src', 'prefix']
    };
    //.........................................................................................................
    validate_and_cast = OVAL.new_validator(schema);
    //.........................................................................................................
    return $((event, send) => {
      /* Build a new pipeline whenever a new plugin declaration is found. In principle, we could scope
      plugin validity using regional tags `<plugin>...</plugin>`, but that is left for later. */
      var Q, meta, name, plugin, type;
      if (select(event, '.', 'plugin')) {
        [type, name, Q, meta] = event;
        Q = validate_and_cast(Q);
        plugin = Q.callable(S, {
          prefix: Q.prefix
        });
        self.plugins.push(plugin);
        self.sub_sender = new_sync_sub_sender(self.plugins, send);
        send(stamp(event));
      //.......................................................................................................
      } else if (self.sub_sender != null) {
        self.sub_sender(event);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  this.$plugins.plugins = [];

  this.$plugins.sub_sender = null;

  this.$plugins.known_prefixes = new Set();

}).call(this);

//# sourceMappingURL=tex-writer-plugin.js.map
