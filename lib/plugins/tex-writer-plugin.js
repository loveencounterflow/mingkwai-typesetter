// Generated by CoffeeScript 2.3.2
(function() {
  //###########################################################################################################
  var $, $async, CND, D, FS, MD_READER, OVAL, PATH, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, jr, log, plugins_sym, promisify, rpr, select, stamp, unstamp, urge, warn, whisper;

  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/TEX-WRITER/PLUGIN';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  // #...........................................................................................................
  // suspend                   = require 'coffeenode-suspend'
  // step                      = suspend.step
  //...........................................................................................................
  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  // #...........................................................................................................
  // ASYNC                     = require 'async'
  // #...........................................................................................................
  // ƒ                         = CND.format_number.bind CND
  // HELPERS                   = require '../helpers'
  // TEXLIVEPACKAGEINFO        = require '../texlivepackageinfo'
  // options_route             = '../options.coffee'
  // { CACHE, OPTIONS, }       = require '../options-and-cache'
  // SEMVER                    = require 'semver'
  // #...........................................................................................................
  // XNCHR                     = require '../xnchr'
  // MKTS                      = require '../main'
  // MKTSCRIPT_WRITER          = require '../mktscript-writer'
  MD_READER = require('../md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  // MACRO_ESCAPER             = require '../macro-escaper'
  // MACRO_INTERPRETER         = require '../macro-interpreter'
  // LINEBREAKER               = require '../linebreaker'
  // @COLUMNS                  = require '../tex-writer-columns'
  // @MKTS_TABLE               = require '../tex-writer-mkts-table'
  // AUX                       = require '../tex-writer-aux'
  // YADDA                     = require '../yadda'
  OVAL = require('../object-validator');

  // UNITS                     = require '../mkts-table-units'
  //...........................................................................................................
  // Σ_formatted_warning       = Symbol 'formatted-warning'
  promisify = (require('util')).promisify;

  jr = JSON.stringify;

  plugins_sym = Symbol('plugins');

  //-----------------------------------------------------------------------------------------------------------
  this._resolve_arguments = (S, Q) => {
    var callable, crumb, crumbs, error, i, len, locator, match, method_path, module, module_path, reference_path;
    reference_path = S.layout_info['source-home'];
    //.....................................................................................................
    if ((match = Q.src.match(/^(?<module_path>.+?)\#(?<method_path>[^\#]+)$/)) != null) {
      ({module_path, method_path} = match.groups);
      if (method_path === '') {
        method_path = null;
      }
    } else {
      //.....................................................................................................
      module_path = Q.src;
      method_path = 'main';
    }
    //.....................................................................................................
    crumbs = method_path != null ? method_path.split('.') : null;
    locator = PATH.join(reference_path, module_path);
    try {
      //.....................................................................................................
      module = require(locator);
      callable = module;
      if (crumbs != null) {
        for (i = 0, len = crumbs.length; i < len; i++) {
          crumb = crumbs[i];
          callable = callable[crumb];
          if (!CND.isa_function(callable)) {
            throw new Error(`not callable: ${rpr(crumb)} in ${rpr(method_path)}`);
          }
        }
      }
    } catch (error1) {
      error = error1;
      alert('98987-1', `when trying to resolve ${rpr(Q.src)}`);
      alert('98987-2', `starting with module ${rpr(locator)}`);
      alert('98987-3', "an error occurred");
      throw error;
    }
    //.....................................................................................................
    return Object.assign({}, Q, {locator, module_path, method_path, callable});
  };

  //-----------------------------------------------------------------------------------------------------------
  this._prefix_from_event = (S, event) => {
    var meta, name, registry, text, type;
    registry = S[plugins_sym];
    [type, name, text, meta] = event;
    debug('88595', 'prefix', name);
    return true;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$plugin = (S) => {
    var registry, schema, validate_and_cast;
    schema = {
      postprocess: (Q) => {
        if (!(Q.src.length > 0)) {
          throw new Error(`µ38893 expected non-empty text, got ${jr(Q)}`);
        }
        if (!(Q.prefix.length > 0)) {
          throw new Error(`µ38894 expected non-empty text, got ${jr(Q)}`);
        }
        return this._resolve_arguments(S, Q);
      },
      //.......................................................................................................
      properties: {
        src: {
          type: 'string'
        },
        prefix: {
          type: 'string'
        }
      },
      //.......................................................................................................
      additionalProperties: false,
      required: ['src', 'prefix']
    };
    //.........................................................................................................
    validate_and_cast = OVAL.new_validator(schema);
    registry = S[plugins_sym] = {};
    //.........................................................................................................
    return $((event, send) => {
      var Q, meta, name, prefix, type;
      if (select(event, '.', 'plugin')) {
        [type, name, Q, meta] = event;
        Q = validate_and_cast(Q);
        debug('33933', Q);
        send(stamp(event));
      //.......................................................................................................
      } else if ((prefix = this._prefix_from_event(S, event)) != null) {
        debug('10095', 'plugin', jr(event));
        send(stamp(event));
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

}).call(this);

//# sourceMappingURL=tex-writer-plugin.js.map
