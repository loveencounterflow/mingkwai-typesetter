// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, FS, PATH, PS, S, alert, assign, badge, copy, debug, echo, help, info, jr, log, new_pushable, new_sync_sub_sender, plugins_library, rpr, rprx, select, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'SCRATCH/DYNAMIC-PIPELINES';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  // #...........................................................................................................
  // suspend                   = require 'coffeenode-suspend'
  // step                      = suspend.step
  //...........................................................................................................
  // D                         = require 'pipedreams'
  // $                         = D.remit.bind D
  // $async                    = D.remit_async.bind D
  PS = require('pipestreams');

  ({$, $async} = PS);

  new_pushable = require('pull-pushable');

  assign = Object.assign;

  jr = JSON.stringify;

  copy = function(...P) {
    return assign({}, ...P);
  };

  rprx = function(d) {
    return `${d.mark} ${d.type}:: ${jr(d.value)}`;
  };

  /*

  Pipestream Events v2
  ====================

  d         := { mark,          type, value, ... }    # implicit global namespace
            := { mark, prefix,  type, value, ... }    # explicit namespace

   * `d.mark` indicates 'regionality':

  mark      := '.' # singleton                        # will become '!'   # or '</>' ?
            := '(' # start-of-region (SOR)            #                   # '<-'
            := ')' # end-of-region   (EOR)            #                   # '->'

   * `prefix` indicates the namespace; where missing on an event or is `null`, `undefined` or `'global'`,
   * it indicates the global namespace:

  prefix    := null | undefined | 'global' | non-empty text

  type      := non-empty text         # typename

  value     := any                    # payload

   */
  //-----------------------------------------------------------------------------------------------------------
  select = function(event, prefix, marks, types) {
    /* accepts 3 or 4 arguments; when 4, then second must be prefix (only one prefix allowed);
    `marks` and `types` may be text or list of texts. */
    var _type, arity, ref, ref1;
    switch (arity = arguments.length) {
      // when 2 then [ prefix, marks, types, ] = [ null, prefix, marks, ]
      case 3:
        [prefix, marks, types] = [null, prefix, marks];
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expected 3 to 4 arguments, got arity");
    }
    if ((prefix == null) || (prefix === 'global')) {
      prefix = null;
    }
    if (marks == null) {
      marks = null;
    }
    if (types == null) {
      types = null;
    }
    switch (_type = CND.type_of(prefix)) {
      case 'null':
        null;
        break;
      case 'text':
        if (event.prefix !== prefix) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(marks)) {
      case 'null':
        null;
        break;
      case 'text':
        if (event.mark !== marks) {
          return false;
        }
        break;
      case 'list':
        if (ref = event.mark, indexOf.call(marks, ref) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(types)) {
      case 'null':
        null;
        break;
      case 'text':
        if (event.type !== types) {
          return false;
        }
        break;
      case 'list':
        if (ref1 = event.type, indexOf.call(types, ref1) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    return true;
  };

  //-----------------------------------------------------------------------------------------------------------
  new_sync_sub_sender = function(transforms, send) {
    var i, len, pipeline, pushable, transform;
    /* Given a transform, construct a pipeline with a pushable as its source, and
    return a function that accepts a send method and a data event. */
    // The sub-sender works by temporarily attaching a hidden ###
    pushable = new_pushable();
    pipeline = [];
    pipeline.push(pushable);
    for (i = 0, len = transforms.length; i < len; i++) {
      transform = transforms[i];
      pipeline.push(transform);
    }
    pipeline.push(PS.$watch(function(d) {
      return send(d);
    }));
    pipeline.push(PS.$drain());
    PS.pull(...pipeline);
    return function(d) {
      return pushable.push(d);
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  plugins_library = {
    //-----------------------------------------------------------------------------------------------------------
    doubler: $(function(d, send) {
      if (select(d, '.', 'number')) {
        // send d
        return send(copy(d, {
          value: 2 * d.value
        }));
      } else {
        whisper(`no match: ${rprx(d)}`);
        return send(d);
      }
    }),
    //-----------------------------------------------------------------------------------------------------------
    tripler: $(function(d, send) {
      if (select(d, '.', 'number')) {
        send(d);
        return send(copy(d, {
          value: 3 * d.value
        }));
      } else {
        whisper(`no match: ${rprx(d)}`);
        return send(d);
      }
    }),
    //-----------------------------------------------------------------------------------------------------------
    // logger: PS.$watch ( d ) -> null
    logger: PS.$watch(function(d) {
      return whisper(`intermediate: ${rprx(d)}`);
    })
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$plugins = function(S) {
    var pipeline;
    pipeline = [];
    pipeline.push($((d, send) => {
      var plugin, self;
      self = this.$plugins;
      if (select(d, '.', 'plugin')) {
        debug('plugin', rprx(d));
        if ((plugin = plugins_library[d.value]) == null) {
          throw new Error(`unknown plugin ${rpr(d.value)}`);
        }
        self.plugins.push(plugin);
        self.sub_sender = new_sync_sub_sender(self.plugins, send);
      } else if (self.sub_sender != null) {
        self.sub_sender(d);
      } else {
        send(d);
      }
      return null;
    }));
    //.........................................................................................................
    return PS.pull(...pipeline);
  };

  this.$plugins.plugins = [];

  this.$plugins.sub_sender = null;

  //-----------------------------------------------------------------------------------------------------------
  this.get_outer_pipeline = function(S) {
    var interlude_1, interlude_2, interlude_3, interlude_4, n, on_stop, pipeline, source, t0, t1, value;
    source = (function() {
      var i, results;
      results = [];
      for (n = i = 1; i <= 10; n = i += +1) {
        results.push(n);
      }
      return results;
    })();
    // source      = ( n for n in [ 1 .. 2e4 ] by +1 )
    source = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = source.length; i < len; i++) {
        value = source[i];
        results.push({
          mark: '.',
          type: 'number',
          value
        });
      }
      return results;
    })();
    interlude_1 = {
      mark: '.',
      type: 'plugin',
      value: 'doubler'
    };
    // interlude_2 = { mark: '.', type: 'plugin', value: 'frobulator', }
    interlude_2 = {
      mark: '.',
      type: 'plugin',
      value: 'logger'
    };
    interlude_3 = {
      mark: '.',
      type: 'plugin',
      value: 'tripler'
    };
    interlude_4 = {
      mark: '.',
      type: 'something',
      value: 'anything'
    };
    source = [...source.slice(0, 2), interlude_1, ...source.slice(2, 4), interlude_2, interlude_3, ...source.slice(4, 7), interlude_4, ...source.slice(6)];
    source = PS.new_value_source(source);
    //.........................................................................................................
    on_stop = PS.new_event_collector('stop', function() {
      return help('ok');
    });
    pipeline = [];
    //.........................................................................................................
    pipeline.push(source);
    pipeline.push(PS.$watch(function(d) {
      return whisper('> source ', rprx(d));
    }));
    pipeline.push(this.$plugins(S));
    pipeline.push(PS.$watch(function(d) {
      return help('> sink   ', rprx(d));
    }));
    pipeline.push(on_stop.add(PS.$drain()));
    //.........................................................................................................
    t0 = Date.now();
    PS.pull(...pipeline);
    t1 = Date.now();
    debug(((t1 - t0) / 1000).toFixed(3));
    return null;
  };

  if (module.parent == null) {
    S = {};
    this.get_outer_pipeline(S);
  }

  /*
 * x = {}
 * y_sym = Symbol 'y'
 * x[ y_sym ] = 42
 * debug '55542', x
 * x2 = copy x
 * debug x is x2
 * debug '55542', x2

pull = require('pull-stream')
urge 'this tick'
setImmediate -> urge 'next tick'

p1 = []
p1.push pull.values [1,2,3]
p1.push pull.map ( x ) -> 2 * x
p1.push pull.log()
 * pull p1...

async_map_example = ->
  p2 = []
  p2.push pull.values [ 1 .. 4 ]
  p2.push pull.map ( x ) -> whisper 'A', x; return x
  p2.push pull.asyncMap ( x, handler ) ->
    setTimeout ( -> handler null, 2 * x ), 2000
    setTimeout ( -> handler null, Math.PI * x ), 1000
 * p2.push pull.map ( x ) -> debug 'A', x; return x
 * p2.push pull.asyncMap ( x, handler ) ->
 *   setImmediate -> handler null, 2 * x
 *   # setImmediate -> handler new Error 'oops' if x is 120
  p2.push pull.map ( x ) -> help 'B', x; return x
 * p2.push pull.log()
  p2.push pull.drain()
  pull p2...

log = ( error, d ) ->
  throw error if error?
  urge d

pull      = require('pull-stream')
paramap   = require('pull-paramap')
width     = 1
async_job = ( data, cb ) ->
  whisper data
 * cb null, data
  cb null, data + 1.5
 * cb null, data + 1.256
  return null
p1 = []
p1.push pull.values [ 1, 3, 5, 7, ]
p1.push paramap async_job, width
p1.push pull.collect log
pull p1...

```
//  pull(
//    pull.values([ 1, 3, 5, 7, ]),
//    //perform an async job in parallel,
//    //and return results in the order they arrive
//    paramap(function (data, cb) {
//      async_job(data, cb)
//    }, null, false), // optional flag `inOrder`, default true
//    pull.collect( log )
//  )
```
 */

}).call(this);

//# sourceMappingURL=dynamic-pipeline.js.map
