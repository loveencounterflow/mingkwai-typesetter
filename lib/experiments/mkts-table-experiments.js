// Generated by CoffeeScript 2.3.2
(function() {
  //###########################################################################################################
  var CND, EXCJSCC, XREGEXP, alert, badge, cellquad, d, debug, demo_tableparsing, echo, help, info, jr, log, njs_fs, njs_path, ref, ref1, ref2, ref3, ref4, remark_grid_tables, remark_parse, remark_to_html, remark_to_rehype, rpr, show_permutations, stringify, unified, urge, warn, whisper;

  njs_path = require('path');

  njs_fs = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/MACRO-ESCAPER/mkts-tables';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  XREGEXP = require('xregexp');

  unified = require('unified');

  remark_parse = require('remark-parse');

  stringify = require('rehype-stringify');

  remark_to_rehype = require('remark-rehype');

  remark_to_html = require('remark-html');

  remark_grid_tables = require('remark-grid-tables');

  jr = JSON.stringify;

  //-----------------------------------------------------------------------------------------------------------
  show_permutations = function() {
    var column, columns, i, len, results, row, rows;
    columns = ['O', 'A', 'B', 'C', 'Z'];
    rows = ['O', 'A', 'B', 'C', 'Z'];
    results = [];
    for (i = 0, len = columns.length; i < len; i++) {
      column = columns[i];
      results.push((function() {
        var j, len1, results1;
        results1 = [];
        for (j = 0, len1 = rows.length; j < len1; j++) {
          row = rows[j];
          results1.push(echo(`      \\node[color=gray] at ( \\c${column}, \\r${row} ) {{\\mktsStyleCode{}${column}${row}}};`));
        }
        return results1;
      })());
    }
    return results;
  };

  //-----------------------------------------------------------------------------------------------------------
  demo_tableparsing = function() {
    var demo_1, demo_2, x;
    // .use remark_to_rehype
    x = unified().use(remark_parse).use(remark_grid_tables).use(stringify).use(remark_to_html);
    demo_1 = "+-------+----------+------+\n| Table Headings   | Here |\n+-------+----------+------+\n| Sub   | Headings | Too  |\n+=======+==========+======+\n| cell  | column spanning |\n+ spans +----------+------+\n| rows  | normal   | cell |\n+-------+----------+------+\n| multi | cells can be    |\n| line  | *formatted*     |\n|       | **paragraphs**  |\n| cells |                 |\n| too   |                 |\n+-------+-----------------+\n";
    debug(x.stringify(x.parse(demo_1)));
    demo_2 = "+-------+----------+------+\n| Table Headings   | Here |\n+-------+----------+------+\n| Sub   | Headings | Too  |\n+-------+----------+------+\n| Sub   | Headings | Too  |\n+=======+==========+======+\n| cell  | column spanning |\n+ spans +----------+------+\n| rows  | normal   | cell |\n+-------+----------+------+\n| multi | cells can be    |\n| line  | *formatted*     |\n|       | **paragraphs**  |\n| cells |                 |\n| too   |                 |\n+-------+-----------------+\n\n\n";
    return debug(x.stringify(x.parse(demo_2)));
  };

  /* ==================================================================================================== */
  // debug EXCJSCC = require '../../src/experiments/exceljs-col-cache-module'
  EXCJSCC = require('../exceljs-spreadsheet-address-codec');

  // debug '77762-1', EXCJSCC.l2n               'A'    ### letter_from_number ###
  // debug '77762-2', EXCJSCC.l2n               'Z'
  // debug '77762-3', EXCJSCC.l2n               'AA'
  // # debug '77762-4', EXCJSCC.l2n               'zz' ### must be uppercase ###
  // debug '77762-5', EXCJSCC.n2l               '1'    ### letter_from_number ###
  // debug '77762-6', EXCJSCC.n2l               '256'
  // debug '77762-7', EXCJSCC.n2l               256
  // # debug '77762-8', EXCJSCC.validateAddress   '*+'
  // debug '77762-9', EXCJSCC.validateAddress   'AA1'
  // # debug '77762-10', EXCJSCC.validateAddress   'A:A'
  // debug '77762-11', EXCJSCC.decodeAddress     'A1'  ### convert address string into structure ###
  // debug '77762-12', EXCJSCC.decodeAddress     'AA1' ### like `{ address: 'A1', col: 1, row: 1, '$col$row': '$A$1' }` ###
  // debug '77762-13', EXCJSCC.getAddress        'AA1' ### convert r,c into structure (if only 1 arg, assume r is address string) ###
  // debug '77762-13', EXCJSCC.getAddress        '1', '2'
  // debug '77762-13', EXCJSCC.getAddress        1, 2
  // debug '77762-14', EXCJSCC.decode            'AA1' ### convert [address], [tl:br] into address structures ###
  // debug '77762-14', EXCJSCC.decode            'A1:B2'
  // # debug '77762-15', EXCJSCC.decodeEx          'AA1'
  // debug '77762-16', EXCJSCC.encodeAddress     1, 1 ### convert row,col into address string ###
  // debug '77762-16', EXCJSCC.encodeAddress     1234, 1234
  // debug '77762-17', EXCJSCC.encode            1234, 1234 ### convert row,col into string address or t,l,b,r into range ###
  // debug '77762-17', EXCJSCC.encode            1, 2, 3, 4

  //-----------------------------------------------------------------------------------------------------------
  this._walk_cellquad_sides = function*(me, cellquad, side) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter, col_nr, col_nr_1, col_nr_2, i, j, quad, ref, ref1, ref2, ref3, row_nr, row_nr_1, row_nr_2;
    switch (side) {
      case 'left':
        row_nr_1 = cellquad.top;
        row_nr_2 = cellquad.bottom;
        col_nr_1 = cellquad.left;
        col_nr_2 = cellquad.left;
        break;
      case 'right':
        row_nr_1 = cellquad.top;
        row_nr_2 = cellquad.bottom;
        col_nr_1 = cellquad.right;
        col_nr_2 = cellquad.right;
        break;
      case 'top':
        row_nr_1 = cellquad.top;
        row_nr_2 = cellquad.top;
        col_nr_1 = cellquad.left;
        col_nr_2 = cellquad.right;
        break;
      case 'bottom':
        row_nr_1 = cellquad.bottom;
        row_nr_2 = cellquad.bottom;
        col_nr_1 = cellquad.left;
        col_nr_2 = cellquad.right;
        break;
      case '*':
        yield* this._walk_cellquad_sides(me, cellquad, 'left');
        yield* this._walk_cellquad_sides(me, cellquad, 'right');
        yield* this._walk_cellquad_sides(me, cellquad, 'top');
        yield* this._walk_cellquad_sides(me, cellquad, 'bottom');
        return;
      default:
        throw new Error(`(MKTS/TABLE 2658) illegal argument for side ${rpr(side)}`);
    }
    for (row_nr = i = ref = row_nr_1, ref1 = row_nr_2; (ref <= ref1 ? i <= ref1 : i >= ref1); row_nr = ref <= ref1 ? ++i : --i) {
      for (col_nr = j = ref2 = col_nr_1, ref3 = col_nr_2; (ref2 <= ref3 ? j <= ref3 : j >= ref3); col_nr = ref2 <= ref3 ? ++j : --j) {
        col_letter = (EXCJSCC.n2l(col_nr)).toLowerCase();
        quad = `${col_letter}${row_nr}`;
        yield ({col_nr, row_nr, col_letter, quad, side});
      }
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  cellquad = {
    top: 1,
    left: 1,
    bottom: 4,
    right: 3,
    tl: 'a1',
    br: 'c4'
  };

  ref = this._walk_cellquad_sides(null, cellquad, 'left');
  for (d of ref) {
    urge('cellquad left   ', jr(d));
  }

  ref1 = this._walk_cellquad_sides(null, cellquad, 'right');
  for (d of ref1) {
    urge('cellquad right  ', jr(d));
  }

  ref2 = this._walk_cellquad_sides(null, cellquad, 'top');
  for (d of ref2) {
    urge('cellquad top    ', jr(d));
  }

  ref3 = this._walk_cellquad_sides(null, cellquad, 'bottom');
  for (d of ref3) {
    urge('cellquad bottom ', jr(d));
  }

  ref4 = this._walk_cellquad_sides(null, cellquad, '*');
  for (d of ref4) {
    urge('*', jr(d));
  }

  echo();

}).call(this);

//# sourceMappingURL=mkts-table-experiments.js.map
