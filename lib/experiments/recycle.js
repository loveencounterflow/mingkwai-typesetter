// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, FS, L, PATH, PS, _new_push_source, alert, assign, badge, copy, debug, echo, help, info, jr, log, rpr, rprx, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  PATH = require('path');

  FS = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS/EXPERIMENTS/RECYCLE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  // #...........................................................................................................
  // suspend                   = require 'coffeenode-suspend'
  // step                      = suspend.step
  //...........................................................................................................
  // D                         = require 'pipedreams'
  // $                         = D.remit.bind D
  // $async                    = D.remit_async.bind D
  PS = require('pipestreams');

  ({$, $async} = PS);

  _new_push_source = require('pull-pushable');

  assign = Object.assign;

  jr = JSON.stringify;

  copy = function(...P) {
    return assign({}, ...P);
  };

  rprx = function(d) {
    var ref1, ref2;
    return `${d.sigil} ${d.key}:: ${jr((ref1 = d.value) != null ? ref1 : null)} ${jr((ref2 = d.stamped) != null ? ref2 : false)}`;
  };

  /*

  Pipestream Events v2
  ====================

  d         := { sigil,          key, value, ..., $, }    # implicit global namespace
            := { sigil, prefix,  key, value, ..., $, }    # explicit namespace

   * `d.sigil` indicates 'regionality':

  sigil     := '.' # proper singleton
            := '~' # system singleton
            := '(' # start-of-region (SOR)    # '<'
            := ')' # end-of-region   (EOR)    # '>'

   * `prefix` indicates the namespace; where missing on an event or is `null`, `undefined` or `'global'`,
   * it indicates the global namespace:

  prefix    := null | undefined | 'global' | non-empty text

  key       := non-empty text         # typename

  value     := any                    # payload

  $         := pod                    # system-level attributes, to be copied from old to new events

   */
  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.stamp = function(d) {
    /* Set the `stamped` attribute on event to sigil it as processed. Stamped events will not be selected
    by the `select` method, only by the `select_all` method. */
    d.stamped = true;
    return d;
  };

  //===========================================================================================================
  // RECYCLING
  //-----------------------------------------------------------------------------------------------------------
  this.$unwrap_recycled = function() {
    /* If the event is a `~recycle` event, send its associated `~sync` event, if any, then its value;
    otherwise, send the event itself. */
    return $((d, send) => {
      if (!this.is_recycling(d)) {
        return send(d);
      }
      // if @is_sync d.value
      // send @new_system_event 'sync', null, { sync: 'xxx', }
      send(d.value);
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$recycle = function(push) {
    /* Stream transform to send events either down the pipeline (using `send`) or
    to an alternate destination, using the `push` method ( the only argument to
    this function). Normally, this will be the `push` method of a push source, but
    it could be any function that accepts a single event as argument. */
    return $((d, send) => {
      if (this.is_sync(d)) {
        push(this.recycling(d));
      } else if (this.is_recycling(d)) {
        push(d);
      } else {
        send(d);
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.recycling = function(d, sync = null) {
    return this.new_system_event('recycle', d, sync != null ? {sync} : null);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_recycling = function(d) {
    /* Return whether event is a recycling wrapper event. */
    return (d.sigil === '~') && (d.key === 'recycle');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_sync = function(d) {
    /* Return whether event is a recycling wrapper event. */
    return (d.sigil === '~') && (d.key === 'sync');
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_push_source = function() {
    /* Return a `pull-streams` `pushable`. Methods `push` and `end` will be bound to the instance
    so they can be freely passed around. */
    var R;
    R = _new_push_source();
    R.push = R.push.bind(R);
    R.end = R.end.bind(R);
    return R;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.select = function(d, prefix, sigils, keys) {
    var arity;
    if (this.is_stamped(d)) {
      /* Reject all stamped events: */
      return false;
    }
    // return false if @is_recycling d
    /* TAINT avoid to test twice for arity */
    switch (arity = arguments.length) {
      case 3:
        return this.select_all(d, prefix, sigils);
      case /* d, sigils, keys */4:
        return this.select_all(d, prefix, sigils, keys);
      default:
        throw new Error(`expected 3 to 4 arguments, got ${arity}`);
    }
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @select_system = ( d, prefix, keys ) ->
  //   ### TAINT avoid to test twice for arity ###
  //   switch arity = arguments.length
  //     when 2 then return @select_all d, prefix, sigils ### d, sigils, keys ###
  //     when 3 then return @select_all d, prefix, sigils, keys
  //     else throw new Error "expected 3 to 4 arguments, got arity"

  //-----------------------------------------------------------------------------------------------------------
  this.select_all = function(d, prefix, sigils, keys) {
    /* accepts 3 or 4 arguments; when 4, then second must be prefix (only one prefix allowed);
    `sigils` and `keys` may be text or list of texts. */
    var _type, arity, ref1, ref2;
    switch (arity = arguments.length) {
      // when 2 then [ prefix, sigils, keys, ] = [ null, prefix, sigils, ]
      case 3:
        [prefix, sigils, keys] = [null, prefix, sigils];
        break;
      case 4:
        null;
        break;
      default:
        throw new Error("expected 3 to 4 arguments, got arity");
    }
    if ((prefix == null) || (prefix === 'global')) {
      //.........................................................................................................
      prefix = null;
    }
    if (sigils == null) {
      sigils = null;
    }
    if (keys == null) {
      keys = null;
    }
    switch (_type = CND.type_of(prefix)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.prefix !== prefix) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(sigils)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.sigil !== sigils) {
          return false;
        }
        break;
      case 'list':
        if (ref1 = d.sigil, indexOf.call(sigils, ref1) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    switch (_type = CND.type_of(keys)) {
      case 'null':
        null;
        break;
      case 'text':
        if (d.key !== keys) {
          return false;
        }
        break;
      case 'list':
        if (ref2 = d.key, indexOf.call(keys, ref2) < 0) {
          return false;
        }
        break;
      default:
        throw new Error(`expected a text or a list, got a ${_type}`);
    }
    return true;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.is_system = function(d) {
    /* Return whether event is a system event (i.e. whether its `sigil` equals `'~'`). */
    return d.sigil === '~';
  };

  //-----------------------------------------------------------------------------------------------------------
  this.is_stamped = function(d) {
    var ref1;
    /* Return whether event is stamped (i.e. already processed). */
    return (ref1 = d.stamped) != null ? ref1 : false;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.new_event = function(sigil, key, value, ...other) {
    var R;
    /* When `other` contains a key `$`, it is treated as a hint to copy
    system-level attributes; if the value of key `$` is a POD that has itself a
    key `$`, then a copy of that value is used. This allows to write `new_event
    ..., $: d` to copy system-level attributes such as source locations to a new
    event. */
    if (value != null) {
      R = assign({sigil, key, value}, ...other);
    } else {
      R = assign({sigil, key}, ...other);
    }
    /* TAINT consider to resolve recursively */
    if ((CND.isa_pod(R.$)) && (CND.isa_pod(R.$.$))) {
      R.$ = copy(R.$.$);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_single_event = function(key, value, ...other) {
    return this.new_event('.', key, value, ...other);
  };

  this.new_start_event = function(key, value, ...other) {
    return this.new_event('(', key, value, ...other);
  };

  this.new_stop_event = function(key, value, ...other) {
    return this.new_event(')', key, value, ...other);
  };

  this.new_system_event = function(key, value, ...other) {
    return this.new_event('~', key, value, ...other);
  };

  this.new_end_event = function() {
    return this.new_system_event('end');
  };

  this.new_flush_event = function() {
    return this.new_system_event('flush');
  };

  this.new_text_event = function(value, ...other) {
    return this.new_single_event('text', value, ...other);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.new_warning = function(ref, message, d, ...other) {
    return this.new_system_event('warning', d, {ref, message}, ...other);
  };

  //###########################################################################################################
  L = this;

  (function() {
    var key, value;
    for (key in L) {
      value = L[key];
      if (!CND.isa_function(value)) {
        continue;
      }
      L[key] = value.bind(L);
    }
    return null;
  })();

}).call(this);

//# sourceMappingURL=recycle.js.map
