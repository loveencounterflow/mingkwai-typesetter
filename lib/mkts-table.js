// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, D, ECS, EXCJSCC, MD_READER, MKTS, _stackerr, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, rpr, select, stamp, unstamp, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS/TABLE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  //...........................................................................................................
  ECS = require('./eval-cs');

  MKTS = require('./main');

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  //...........................................................................................................
  copy = function(x) {
    return Object.assign({}, x);
  };

  EXCJSCC = require('./exceljs-spreadsheet-address-codec');

  //===========================================================================================================
  // INITIALIZATION
  //-----------------------------------------------------------------------------------------------------------
  this._new_description = function(S) {
    var R;
    R = {
      '~isa': 'MKTS/TABLE/description',
      // grid:       { width: 4, height: 4, }
      // ### default unit for width, height: ###
      // u:
      //   width:    '10mm'
      //   height:   '10mm'
      cells: [],
      quadwidths: null,
      quadheights: null,
      joint_coordinates: null,
      cellgrid: false,
      default: {
        gridwidth: 4,
        gridheight: 4,
        unitwidth: '1mm',
        unitheight: '1mm',
        quadwidth: 10,
        quadheight: 10
      }
    };
    return R;
  };

  //===========================================================================================================
  // PUBLIC API
  //-----------------------------------------------------------------------------------------------------------
  this.gridwidth = function(me, text) {
    var match, type;
    //.........................................................................................................
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8082) need a text for mkts-table/gridwidth, got a ${type}`);
    }
    if ((match = text.match(/^\s*(\d+)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 9000) need a text like '3' or similar for mkts-table/gridwidth, got ${rpr(text)}`);
    }
    if (me.gridwidth != null) {
      throw new Error("(MKTS/TABLE 1282) unable to re-define gridwidth");
    }
    //.........................................................................................................
    me.gridwidth = parseInt(match[1], 10);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.gridheight = function(me, text) {
    var match, type;
    //.........................................................................................................
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 4532) need a text for mkts-table/gridheight, got a ${type}`);
    }
    if ((match = text.match(/^\s*(\d+)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 3691) need a text like '3' or similar for mkts-table/gridheight, got ${rpr(text)}`);
    }
    if (me.gridheight != null) {
      throw new Error("(MKTS/TABLE 5164) unable to re-define gridheight");
    }
    //.........................................................................................................
    me.gridheight = parseInt(match[1], 10);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitwidth = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 4959) need a text for mkts-table/unitwidth, got a ${type}`);
    }
    if (me.unitwidth != null) {
      throw new Error("(MKTS/TABLE 7732) unable to re-define unitheight");
    }
    //.........................................................................................................
    me.unitwidth = text;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitheight = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 3643) need a text for mkts-table/unitheight, got a ${type}`);
    }
    if (me.unitheight != null) {
      throw new Error("(MKTS/TABLE 3537) unable to re-define unitheight");
    }
    //.........................................................................................................
    me.unitheight = text;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cell = function(me, text) {
    var cell, type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9791) need a text for mkts-table/cell, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_gridwidth(me);
    this._ensure_gridheight(me);
    this._ensure_unitvector(me);
    cell = this._parse_range_quadref(me, text);
    if (cell.right > me.gridwidth) {
      throw new Error(`(MKTS/TABLE 1274) cell exceeds grid width: ${rpr(text)}`);
    }
    if (cell.bottom > me.gridheight) {
      throw new Error(`(MKTS/TABLE 6069) cell exceeds grid height: ${rpr(text)}`);
    }
    me.cells.push(cell);
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cellgrid = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9791) need a text for mkts-table/cell, got a ${type}`);
    }
    //.........................................................................................................
    switch (text) {
      case 'true':
        me.cellgrid = true;
        break;
      case 'false':
        me.cellgrid = false;
        break;
      default:
        throw new Error(`(MKTS/TABLE 9791) expected 'true' or 'false' for mkts-table/cellgrid, got a ${rpr(text)}`);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cellspacing = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 1539) need a text for mkts-table/cellspacing, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    me.cellspacing = this._parse_coordinate_without_units(me, text);
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // PARSERS ETC
  //-----------------------------------------------------------------------------------------------------------
  this._idx_from_col_and_row = function(col, row) {
    var col_idx, row_idx, type;
    if ((type = CND.type_of(col)) !== 'text') {
      throw new Error(`(MKTS/TABLE 1763) expected a text for col, got a ${rpr(type)}`);
    }
    if ((type = CND.type_of(row)) !== 'text') {
      throw new Error(`(MKTS/TABLE 4752) expected a text for row, got a ${rpr(type)}`);
    }
    //.........................................................................................................
    col_idx = (col.codePointAt(0)) - ('a'.codePointAt(0));
    row_idx = (parseInt(row, 10)) - 1;
    return {
      col: col_idx,
      row: row_idx
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_range_quadref = function(me, quad_range) {
    /* TAINT don't use EXCJSCC directly */
    var R, match, type;
    if ((type = CND.type_of(quad_range)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9879) expected a text for quad_range, got a ${rpr(type)}`);
    }
    if ((match = quad_range.match(/^([a-z]{1,3})([0-9]{1,4}):([a-z]{1,3})([0-9]{1,4})$/)) == null) {
      throw new Error(`(MKTS/TABLE 3807) expected a quad range like 'a1:d4', got ${rpr(quad_range)}`);
    }
    R = EXCJSCC.decode(quad_range.toUpperCase());
    delete R.dimensions;
    R.tl = R.tl.toLowerCase();
    R.br = R.br.toLowerCase();
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_coordinate_with_units = function(me, coordinate) {
    var _, match, type, x, y;
    if ((type = CND.type_of(coordinate)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8077) expected a text for coordinate, got a ${rpr(type)}`);
    }
    if ((match = coordinate.match(/^\s*\(\s*([-0-9.]{1,8}[a-z]{0,3})\s*,\s*([-0-9.]{1,8}[a-z]{0,3})\s*\)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 3191) expected a coordinate with units like '( 1mm, 2.4cm )', got ${rpr(coordinate)}`);
    }
    [_, x, y] = match;
    return {x, y};
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_coordinate_without_units = function(me, coordinate) {
    var _, match, type, x, y;
    if ((type = CND.type_of(coordinate)) !== 'text') {
      throw new Error(`(MKTS/TABLE 3975) expected a text for coordinate, got a ${rpr(type)}`);
    }
    if ((match = coordinate.match(/^\s*\(\s*([-0-9.]{1,8})\s*,\s*([-0-9.]{1,8})\s*\)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 2658) expected a unitless coordinate like '( 1, 2.4 )', got ${rpr(coordinate)}`);
    }
    [_, x, y] = match;
    return {x, y};
  };

  //===========================================================================================================
  // EVENT GENERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_events = function*(me) {
    yield* this._walk_opening_events(me);
    yield* this._walk_cellspacing_events(me);
    yield* this._walk_column_and_row_coordinates_events(me);
    yield* this._walk_joint_coordinates_events(me);
    yield* this._walk_quad_sides_events(me);
    yield* this._walk_quad_coordinates_events(me);
    yield* this._walk_debugging_events(me);
    yield* this._walk_cellgrid_events(me);
    yield* this._walk_closing_events(me);
    //.........................................................................................................
    // ### dump description for debugging ###
    // ### TAINT make dump configurable ###
    // ### TAINT print in smaller type ###
    // yield [ 'tex', '\\par{}', ]
    // yield [ 'text', "MKTS Table Description:\n\n", ( copy me.meta ), ]
    // yield [ '(', 'code', [],                       ( copy me.meta ), ]
    // yield [ '.', 'text', ( rpr me ),               ( copy me.meta ), ]
    // yield [ ')', 'code', [],                       ( copy me.meta ), ]
    // yield [ 'tex', '\\par{}', ]
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_opening_events = function*(me) {
    this._ensure_unitvector(me);
    yield ['tex', "\n\n"];
    yield ['tex', "\\par% Beginning of MKTS Table ==============================================================================\n"];
    yield ['tex', "{\\setlength{\\fboxsep}{0mm}%\n"];
    yield [/* TAINT insert proper dimensions */ 'tex', "\\framebox{\\begin{minipage}[t][45mm][t]{100mm}%\n"];
    yield [/* !!!!!!!!!!!!!!!!!!!!! */ '.', 'text', "table goes here", copy(me.meta)];
    yield [/* !!!!!!!!!!!!!!!!!!!!! */ 'tex', "\\begin{tikzpicture}[ overlay, yshift = 0mm, yscale = -1, line cap = round ]%\n"];
    yield ['tex', `\\tikzset{ x = ${me.unitheight} };%\n`];
    yield ['tex', `\\tikzset{ y = ${me.unitheight} };%\n`];
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_closing_events = function*(me) {
    yield ['tex', "\\end{tikzpicture}%\n"];
    yield ['tex', "\\end{minipage}}}%\n"];
    yield ['tex', "\\par% End of MKTS Table ====================================================================================\n\n"];
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_cellspacing_events = function*(me) {
    if (me.cellspacing == null) {
      /* TAINT should rather use default cellspacing */
      return null;
    }
    yield ['tex', `\\coordinate (horizontal spacing)  at ( ${me.cellspacing.x}, 0 );%\n`];
    yield ['tex', `\\coordinate (vertical spacing)    at ( 0, ${me.cellspacing.y} );%\n`];
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_column_and_row_coordinates_events = function*(me) {
    var col_letter, col_nr, ref1, ref2, row_nr, x_position, y_position, z;
    this._ensure_joint_coordinates(me);
    x_position = 0;
    y_position = 0;
    ref1 = this._walk_column_letters_and_numbers(me, 'long');
    //.........................................................................................................
    for (z of ref1) {
      [col_letter, col_nr] = z;
      yield ['tex', `\\coordinate (c${col_letter}) at ( ${x_position}, 0 );%\n`];
      x_position += me.quadwidths[col_nr];
    }
    ref2 = this._walk_row_numbers(me, 'long');
    //.........................................................................................................
    for (row_nr of ref2) {
      yield ['tex', `\\coordinate (r${row_nr}) at ( 0, ${y_position} );%\n`];
      y_position += me.quadheights[row_nr];
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_joint_coordinates_events = function*(me) {
    var col_letter, col_nr, joint, ref1, ref2, row_nr, x_position, y_position, z;
    this._ensure_joint_coordinates(me);
    x_position = 0;
    y_position = 0;
    ref1 = this._walk_column_letters_and_numbers(me, 'long');
    //.........................................................................................................
    /* TAINT code duplication; use iterator */
    for (z of ref1) {
      [col_letter, col_nr] = z;
      ref2 = this._walk_row_numbers(me, 'long');
      for (row_nr of ref2) {
        joint = `${col_letter}${row_nr}`;
        yield ['tex', `\\coordinate (joint ${joint}) at ($ (c${col_letter}) + (r${row_nr}) $);%\n`];
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_quad_sides_events = function*(me) {
    var col_letter, col_nr, ref1, ref2, row_nr, z;
    this._ensure_joint_coordinates(me);
    ref1 = this._walk_column_letters_and_numbers(me, 'long');
    //.........................................................................................................
    for (z of ref1) {
      [col_letter, col_nr] = z;
      yield ['tex', `\\coordinate (c${col_letter} W) at ($ (c${col_letter}) - (horizontal spacing) $);%\n`];
      yield ['tex', `\\coordinate (c${col_letter} E) at ($ (c${col_letter}) + (horizontal spacing) $);%\n`];
    }
    ref2 = this._walk_row_numbers(me, 'long');
    //.........................................................................................................
    for (row_nr of ref2) {
      yield ['tex', `\\coordinate (r${row_nr} N) at ($ (r${row_nr}) - (vertical spacing) $);%\n`];
      yield ['tex', `\\coordinate (r${row_nr} S) at ($ (r${row_nr}) + (vertical spacing) $);%\n`];
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_quad_coordinates_events = function*(me) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter_1, col_letter_2, col_nr_1, col_nr_2, quad, ref1, ref2, row_nr_1, row_nr_2, z;
    this._ensure_joint_coordinates(me);
    ref1 = this._walk_column_letters_and_numbers(me, 'short');
    //.........................................................................................................
    /* TAINT code duplication; use iterator */
    for (z of ref1) {
      [col_letter_1, col_nr_1] = z;
      col_nr_2 = col_nr_1 + 1;
      col_letter_2 = (EXCJSCC.n2l(col_nr_2)).toLowerCase();
      ref2 = this._walk_row_numbers(me, 'short');
      for (row_nr_1 of ref2) {
        row_nr_2 = row_nr_1 + 1;
        quad = `${col_letter_1}${row_nr_1}`;
        yield ['tex', `\\coordinate (quad ${quad} top left)      at ($ (r${row_nr_1} S) + (c${col_letter_1} E) $);%\n`];
        yield ['tex', `\\coordinate (quad ${quad} top right)     at ($ (r${row_nr_1} S) + (c${col_letter_2} W) $);%\n`];
        yield ['tex', `\\coordinate (quad ${quad} bottom left)   at ($ (r${row_nr_2} N) + (c${col_letter_1} E) $);%\n`];
        yield ['tex', `\\coordinate (quad ${quad} bottom right)  at ($ (r${row_nr_2} N) + (c${col_letter_2} W) $);%\n`];
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_cellgrid_events = function*(me) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter_1, col_letter_2, col_nr_1, col_nr_2, quad, ref1, ref2, row_nr_1, row_nr_2, z;
    if (!me.cellgrid) {
      return null;
    }
    ref1 = this._walk_column_letters_and_numbers(me, 'short');
    //.........................................................................................................
    /* TAINT code duplication; use iterator */
    for (z of ref1) {
      [col_letter_1, col_nr_1] = z;
      col_nr_2 = col_nr_1 + 1;
      col_letter_2 = (EXCJSCC.n2l(col_nr_2)).toLowerCase();
      ref2 = this._walk_row_numbers(me, 'short');
      for (row_nr_1 of ref2) {
        row_nr_2 = row_nr_1 + 1;
        quad = `${col_letter_1}${row_nr_1}`;
        yield ['tex', `\\draw[ red, line width = 0.2mm ] (quad ${quad} top    left)  -- (quad ${quad} top    right); % Quad a1 top\n`];
        yield ['tex', `\\draw[ red, line width = 0.2mm ] (quad ${quad} top    left)  -- (quad ${quad} bottom left);  % Quad a1 left\n`];
        yield ['tex', `\\draw[ red, line width = 0.2mm ] (quad ${quad} bottom left)  -- (quad ${quad} bottom right); % Quad a1 bottom\n`];
        yield ['tex', `\\draw[ red, line width = 0.2mm ] (quad ${quad} top    right) -- (quad ${quad} bottom right); % Quad a1 right\n`];
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_debugging_events = function*(me) {
    var col_letter, col_nr, joint, ref1, ref2, row_nr, z;
    this._ensure_joint_coordinates(me);
    ref1 = this._walk_column_letters_and_numbers(me, 'long');
    //.........................................................................................................
    /* TAINT code duplication; use iterator */
    for (z of ref1) {
      [col_letter, col_nr] = z;
      ref2 = this._walk_row_numbers(me, 'long');
      for (row_nr of ref2) {
        joint = `${col_letter}${row_nr}`;
        yield ['tex', `\\node[ color = gray ] at ($(joint ${joint})+(2mm,2mm)$) {{\\mktsStyleCode{}${joint}}}; `];
        yield ['tex', `\\node[ color = gray, shape = circle, draw ] at (joint ${joint}) {};%\n`];
      }
    }
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // ENSURERS
  //-----------------------------------------------------------------------------------------------------------
  this._ensure_unitvector = function(me) {
    if (me.unitwidth == null) {
      this.unitwidth(me, me.default.unitwidth);
    }
    if (me.unitheight == null) {
      this.unitheight(me, me.default.unitheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_joint_coordinates = function(me) {
    if (me.joint_coordinates != null) {
      return null;
    }
    this._ensure_quadwidths(me);
    this._ensure_quadheights(me);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_gridwidth = function(me) {
    if (me.gridwidth != null) {
      return null;
    }
    me.gridwidths = me.default.gridwidth;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_gridheight = function(me) {
    if (me.gridheight != null) {
      return null;
    }
    me.gridheights = me.default.gridheight;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_quadwidths = function(me) {
    var col_nr;
    if (me.quadwidths != null) {
      return null;
    }
    this._ensure_gridwidth(me);
    me.quadwidths = (function() {
      var i, ref1, results;
      results = [];
      for (col_nr = i = 1, ref1 = me.gridwidth + 1; (1 <= ref1 ? i <= ref1 : i >= ref1); col_nr = 1 <= ref1 ? ++i : --i) {
        results.push(me.default.quadwidth);
      }
      return results;
    })();
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_quadheights = function(me) {
    var col_nr;
    if (me.quadheights != null) {
      return null;
    }
    this._ensure_gridheight(me);
    me.quadheights = (function() {
      var i, ref1, results;
      results = [];
      for (col_nr = i = 1, ref1 = me.gridheight + 1; (1 <= ref1 ? i <= ref1 : i >= ref1); col_nr = 1 <= ref1 ? ++i : --i) {
        results.push(me.default.quadheight);
      }
      return results;
    })();
    return null;
  };

  //===========================================================================================================
  // ITERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_column_letters_and_numbers = function*(me, mode) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter, col_nr, delta, i, ref1, results;
    this._ensure_gridwidth(me);
    delta = mode === 'short' ? 0 : 1;
    results = [];
    for (col_nr = i = 1, ref1 = me.gridwidth + delta; (1 <= ref1 ? i <= ref1 : i >= ref1); col_nr = 1 <= ref1 ? ++i : --i) {
      col_letter = (EXCJSCC.n2l(col_nr)).toLowerCase();
      results.push((yield [col_letter, col_nr]));
    }
    return results;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_row_numbers = function*(me, mode) {
    var delta, i, ref1, results, row_nr;
    this._ensure_gridheight(me);
    delta = mode === 'short' ? 0 : 1;
    results = [];
    for (row_nr = i = 1, ref1 = me.gridheight + delta; (1 <= ref1 ? i <= ref1 : i >= ref1); row_nr = 1 <= ref1 ? ++i : --i) {
      results.push((yield row_nr));
    }
    return results;
  };

  //===========================================================================================================
  // HELPERS
  //-----------------------------------------------------------------------------------------------------------
  _stackerr = function(ref, message, error = null) {
    message = `(MKTS/TABLE#${ref}) ${message}`;
    if (error != null) {
      error.message = `${message}\n${error.message}`;
    } else {
      error = new Error(message);
    }
    return error;
  };

}).call(this);

//# sourceMappingURL=mkts-table.js.map
