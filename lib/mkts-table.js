// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, D, ECS, EXCJSCC, MD_READER, MKTS, _stackerr, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, rpr, select, stamp, unstamp, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS/TABLE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  //...........................................................................................................
  ECS = require('./eval-cs');

  MKTS = require('./main');

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  //...........................................................................................................
  copy = function(x) {
    return Object.assign({}, x);
  };

  EXCJSCC = require('./exceljs-spreadsheet-address-codec');

  //===========================================================================================================
  // INITIALIZATION
  //-----------------------------------------------------------------------------------------------------------
  this._new_description = function(S) {
    var R;
    R = {
      '~isa': 'MKTS/TABLE/description',
      cellquads: {},
      /* cell extents in terms of quads, by designations */quad_dimensions: {},
      cellborders: {},
      /* cell borders, as TikZ styles by sides */cell_dimensions: {},
      /* cell extents in terms of (unitwidth,unitheight), by designations */border_dimensions: {},
      /* border extents in terms of (unitwidth,unitheight), by designations */pod_dimensions: {},
      /* pod extents in terms of (unitwidth,unitheight), by designations */quadwidths: [null],
      /* [ 0 ] is default, [ 1 .. gridwidth ] explicit or implicit widths */quadheights: [null],
      /* [ 0 ] is default, [ 1 .. gridheight ] explicit or implicit heights */joint_coordinates: null,
      debug: false,
      //.......................................................................................................
      styles: {
        sThin: 'thin',
        sThick: 'thick',
        sDotted: 'dotted',
        sDashed: 'dashed',
        sRed: 'red',
        sBlack: 'black',
        sDebugQuadgrid: 'gray!30,sThin',
        sDebugCellgrid: 'gray!30,sThin',
        sDebugJoints: 'gray!30,sThick'
      },
      //.......................................................................................................
      default: {
        // gridwidth:     4
        // gridheight:    4
        unitwidth: '1mm',
        unitheight: '1mm',
        // quadwidth:     10
        // quadheight:    10
        marginwidth: 0,
        marginheight: 0,
        paddingwidth: 0,
        paddingheight: 0
      }
    };
    return R;
  };

  //===========================================================================================================
  // PUBLIC API
  //-----------------------------------------------------------------------------------------------------------
  this.gridwidth = function(me, text) {
    var match, type;
    //.........................................................................................................
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 4517) need a text for mkts-table/gridwidth, got a ${type}`);
    }
    if ((match = text.match(/^\s*(\d+)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 4300) need a text like '3' or similar for mkts-table/gridwidth, got ${rpr(text)}`);
    }
    if (me.gridwidth != null) {
      throw new Error("(MKTS/TABLE 5827) unable to re-define gridwidth");
    }
    //.........................................................................................................
    me.gridwidth = parseInt(match[1], 10);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.gridheight = function(me, text) {
    var match, type;
    //.........................................................................................................
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9150) need a text for mkts-table/gridheight, got a ${type}`);
    }
    if ((match = text.match(/^\s*(\d+)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 6572) need a text like '3' or similar for mkts-table/gridheight, got ${rpr(text)}`);
    }
    if (me.gridheight != null) {
      throw new Error("(MKTS/TABLE 6501) unable to re-define gridheight");
    }
    //.........................................................................................................
    me.gridheight = parseInt(match[1], 10);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitwidth = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9131) need a text for mkts-table/unitwidth, got a ${type}`);
    }
    if (me.unitwidth != null) {
      throw new Error("(MKTS/TABLE 6477) unable to re-define unitheight");
    }
    //.........................................................................................................
    me.unitwidth = text;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitheight = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 7680) need a text for mkts-table/unitheight, got a ${type}`);
    }
    if (me.unitheight != null) {
      throw new Error("(MKTS/TABLE 2142) unable to re-define unitheight");
    }
    //.........................................................................................................
    me.unitheight = text;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.quadwidths = function(me, text) {
    var i, nr, ref1, value;
    /* TAINT should validate */
    this._ensure_gridwidth(me);
    value = parseFloat(text);
    me.quadwidths[0] = value/* set default */
    for (nr = i = 1, ref1 = me.gridwidth; (1 <= ref1 ? i <= ref1 : i >= ref1); nr = 1 <= ref1 ? ++i : --i) {
      me.quadwidths[nr] = value;
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.quadheights = function(me, text) {
    var i, nr, ref1, value;
    /* TAINT should validate */
    this._ensure_gridheight(me);
    value = parseFloat(text);
    me.quadheights[0] = value/* set default */
    for (nr = i = 1, ref1 = me.gridheight; (1 <= ref1 ? i <= ref1 : i >= ref1); nr = 1 <= ref1 ? ++i : --i) {
      me.quadheights[nr] = value;
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cellquads = function(me, text) {
    var d, designation, type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8532) need a text for mkts-table/cellquads, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_gridwidth(me);
    this._ensure_gridheight(me);
    this._ensure_unitvector(me);
    d = this._parse_range_quadref(me, text);
    designation = d.tl.toUpperCase();
    if (d.right > me.gridwidth) {
      throw new Error(`(MKTS/TABLE 2282) cell exceeds grid width: ${rpr(text)}`);
    }
    if (d.bottom > me.gridheight) {
      throw new Error(`(MKTS/TABLE 2523) cell exceeds grid height: ${rpr(text)}`);
    }
    if (me.cellquads[designation] != null) {
      throw new Error(`(MKTS/TABLE 1246) unable to redefine cell ${designation}: ${rpr(text)}`);
    }
    //.........................................................................................................
    me.cellquads[designation] = d;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cellborder = function(me, text) {
    var base, cell, d, i, j, len, len1, ref1, ref2, side, type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 2034) need a text for mkts-table/cellborder, got a ${type}`);
    }
    //.........................................................................................................
    d = this._parse_cellborder(me, text);
    ref1 = d.cells;
    for (i = 0, len = ref1.length; i < len; i++) {
      cell = ref1[i];
      ref2 = d.side;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        side = ref2[j];
        ((base = me.cellborders)[cell] != null ? base[cell] : base[cell] = {})[side] = d.style;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.debug = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8055) need a text for mkts-table/cell, got a ${type}`);
    }
    //.........................................................................................................
    switch (text) {
      case 'true':
        me.debug = true;
        break;
      case 'false':
        me.debug = false;
        break;
      default:
        throw new Error(`(MKTS/TABLE 9035) expected 'true' or 'false' for mkts-table/debug, got ${rpr(text)}`);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.marginwidth = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 1811) need a text for mkts-table/marginwidth, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.marginwidth = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.marginheight = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9480) need a text for mkts-table/marginheight, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.marginheight = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.paddingwidth = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8254) need a text for mkts-table/paddingwidth, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.paddingwidth = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.paddingheight = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 7209) need a text for mkts-table/paddingheight, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.paddingheight = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // PARSERS ETC
  //-----------------------------------------------------------------------------------------------------------
  this._idx_from_col_and_row = function(col, row) {
    var col_idx, row_idx, type;
    if ((type = CND.type_of(col)) !== 'text') {
      throw new Error(`(MKTS/TABLE 4182) expected a text for col, got a ${rpr(type)}`);
    }
    if ((type = CND.type_of(row)) !== 'text') {
      throw new Error(`(MKTS/TABLE 5931) expected a text for row, got a ${rpr(type)}`);
    }
    //.........................................................................................................
    col_idx = (col.codePointAt(0)) - ('a'.codePointAt(0));
    row_idx = (parseInt(row, 10)) - 1;
    return {
      col: col_idx,
      row: row_idx
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_range_quadref = function(me, quad_range) {
    /* TAINT don't use EXCJSCC directly */
    var R, match, type;
    if ((type = CND.type_of(quad_range)) !== 'text') {
      throw new Error(`(MKTS/TABLE 6402) expected a text for quad_range, got a ${rpr(type)}`);
    }
    if ((match = quad_range.match(/^([a-z]{1,3})([0-9]{1,4}):([a-z]{1,3})([0-9]{1,4})$/)) == null) {
      throw new Error(`(MKTS/TABLE 2499) expected a quad range like 'a1:d4', got ${rpr(quad_range)}`);
    }
    R = EXCJSCC.decode(quad_range.toUpperCase());
    delete R.dimensions;
    R.tl = R.tl.toLowerCase();
    R.br = R.br.toLowerCase();
    R.tr = `${(EXCJSCC.n2l(R.right)).toLowerCase()}${R.top}`;
    R.bl = `${(EXCJSCC.n2l(R.left)).toLowerCase()}${R.bottom}`;
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_coordinate_with_units = function(me, coordinate) {
    var _, match, type, x, y;
    if ((type = CND.type_of(coordinate)) !== 'text') {
      throw new Error(`(MKTS/TABLE 1045) expected a text for coordinate, got a ${rpr(type)}`);
    }
    if ((match = coordinate.match(/^\s*\(\s*([-0-9.]{1,8}[a-z]{0,3})\s*,\s*([-0-9.]{1,8}[a-z]{0,3})\s*\)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 2032) expected a coordinate with units like '( 1mm, 2.4cm )', got ${rpr(coordinate)}`);
    }
    [_, x, y] = match;
    return {x, y};
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_coordinate_without_units = function(me, coordinate) {
    var _, match, type, x, y;
    if ((type = CND.type_of(coordinate)) !== 'text') {
      throw new Error(`(MKTS/TABLE 2262) expected a text for coordinate, got a ${rpr(type)}`);
    }
    if ((match = coordinate.match(/^\s*\(\s*([-0-9.]{1,8})\s*,\s*([-0-9.]{1,8})\s*\)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 6904) expected a unitless coordinate like '( 1, 2.4 )', got ${rpr(coordinate)}`);
    }
    [_, x, y] = match;
    return {x, y};
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_cellborder = function(me, cellborder) {
    var _, cells, groups, sides, style, type;
    if ((type = CND.type_of(cellborder)) !== 'text') {
      throw new Error(`(MKTS/TABLE 6043) expected a text for cellborder, got a ${rpr(type)}`);
    }
    if ((groups = cellborder.match(/^(.+):(.+):(.*)$/)) == null) {
      throw new Error(`(MKTS/TABLE 5822) expected a cellborder like 'a1:left:sDashed,sThick', got ${rpr(cellborder)}`);
    }
    [_, cells, sides, style] = groups;
    cells = indexOf.call(cells, '*') >= 0 ? Object.keys(me.cellquads) : (function() {
      var i, len, ref1, results;
      ref1 = cells.split(',');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        _ = ref1[i];
        results.push(_.trim());
      }
      return results;
    })();
    sides = indexOf.call(sides, '*') >= 0 ? ['top', 'left', 'bottom', 'right'] : (function() {
      var i, len, ref1, results;
      ref1 = sides.split(',');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        _ = ref1[i];
        results.push(_.trim());
      }
      return results;
    })();
    style = style.trim();
    if (style === 'none' || style === '') {
      style = null;
    }
    return {cells, sides, style};
  };

  //===========================================================================================================
  // EVENT GENERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_events = function*(me) {
    this._compute_quad_dimensions(me);
    this._compute_cell_dimensions(me);
    this._compute_border_dimensions(me);
    this._compute_pod_dimensions(me);
    yield* this._walk_opening_events(me);
    yield* this._walk_style_events(me);
    yield* this._walk_debug_quadgrid_events(me);
    yield* this._walk_debug_cellgrid_events(me);
    yield* this._walk_cell_borders_events(me);
    yield* this._walk_pod_events(me);
    yield* this._walk_closing_events(me);
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  // ### dump description for debugging ###
  // ### TAINT make dump configurable ###
  // ### TAINT print in smaller type ###
  // yield [ 'tex', '\\par{}', ]
  // yield [ 'text', "MKTS Table Description:\n\n", ( copy me.meta ), ]
  // yield [ '(', 'code', [],                       ( copy me.meta ), ]
  // yield [ '.', 'text', ( rpr me ),               ( copy me.meta ), ]
  // yield [ ')', 'code', [],                       ( copy me.meta ), ]
  // yield [ 'tex', '\\par{}', ]
  //.........................................................................................................
  this._walk_opening_events = function*(me) {
    this._ensure_unitvector(me);
    yield ['tex', "\n\n"];
    yield ['tex', "\\par% Beginning of MKTS Table ==============================================================================\n"];
    yield ['tex', "{\\setlength{\\fboxsep}{0mm}%\n"];
    /* TAINT insert proper dimensions */
    // yield [ 'tex', "\\framebox{%\n", ] ### framebox ###
    yield ['tex', "\\begin{minipage}[t][45mm][t]{100mm}%\n"];
    yield ['tex', `\\newdimen\\mktsTableUnitwidth\\setlength{\\mktsTableUnitwidth}{${me.unitwidth}}%\n`];
    yield ['tex', `\\newdimen\\mktsTableUnitheight\\setlength{\\mktsTableUnitheight}{${me.unitheight}}%\n`];
    yield ['tex', "\\begin{tikzpicture}[ overlay, yshift = 0mm, yscale = -1, line cap = round ]%\n"];
    yield ['tex', `\\tikzset{x=${me.unitwidth}};\\tikzset{y=${me.unitheight}};%\n`];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_closing_events = function*(me) {
    yield ['tex', "\\end{tikzpicture}%\n"];
    yield ['tex', "\\end{minipage}}%\n"];
    // yield [ 'tex', "}%\n", ] ### framebox ###
    yield ['tex', "\\par% End of MKTS Table ====================================================================================\n\n"];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_style_events = function*(me) {
    var key, ref1, value;
    ref1 = me.styles;
    for (key in ref1) {
      value = ref1[key];
      yield ['tex', `\\tikzset{${key}/.style={${value}}}%\n`];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_cell_borders_events = function*(me) {
    var borderstyle, cellborders, d, designation, ref1;
    ref1 = me.border_dimensions;
    //.........................................................................................................
    for (designation in ref1) {
      d = ref1[designation];
      if ((cellborders = me.cellborders[designation]) == null) {
        continue;
      }
      if ((borderstyle = cellborders['left']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.left},${d.top}) -- (${d.left},${d.bottom});\n`];
      }
      if ((borderstyle = cellborders['right']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.right},${d.top}) -- (${d.right},${d.bottom});\n`];
      }
      if ((borderstyle = cellborders['top']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.left},${d.top}) -- (${d.right},${d.top});\n`];
      }
      if ((borderstyle = cellborders['bottom']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.left},${d.bottom}) -- (${d.right},${d.bottom});\n`];
      }
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_pod_events = function*(me) {
    var cellquads, d, designation, ref1;
    ref1 = me.cellquads;
    for (designation in ref1) {
      cellquads = ref1[designation];
      d = me.pod_dimensions[designation];
      yield ['tex', `\\node[anchor=north west,inner sep=0mm] at (${d.left},${d.top})%\n`];
      yield ['tex', `{\\begin{minipage}[t][${d.height_u}\\mktsTableUnitheight][t]{${d.width_u}\\mktsTableUnitwidth}%\n`];
      yield ['tex', "A\\hfill{}B\\hfill{}C\\end{minipage}};%\n"];
    }
  };

  //===========================================================================================================
  // EVENT GENERATORS: DEBUGGING EVENTS
  //-----------------------------------------------------------------------------------------------------------
  // yield [ 'tex', "{\\framebox{\\begin{minipage}[t][#{d.height_u}\\mktsTableUnitheight][t]{#{d.width_u}\\mktsTableUnitwidth}%\n", ]
  // yield [ 'tex', "A\\hfill{}B\\hfill{}C\\end{minipage}}};%\n", ]
  //.........................................................................................................
  this._walk_debug_quadgrid_events = function*(me) {
    var bottom, col_nr, i, j, left, ref1, ref2, right, row_nr, top, x, y;
    if (!me.debug) {
      return;
    }
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    top = (this._top_from_row_nr(me, 1)) - 3;
    bottom = (this._bottom_from_row_nr(me, me.gridheight)) + 3;
    for (col_nr = i = 1, ref1 = me.gridwidth + 1; (1 <= ref1 ? i <= ref1 : i >= ref1); col_nr = 1 <= ref1 ? ++i : --i) {
      x = this._left_from_col_nr(me, col_nr);
      yield ['tex', `\\draw[sDebugQuadgrid] (${x},${top}) -- (${x},${bottom});\n`];
    }
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    left = (this._left_from_col_nr(me, 1)) - 3;
    right = (this._right_from_col_nr(me, me.gridwidth)) + 3;
    for (row_nr = j = 1, ref2 = me.gridheight + 1; (1 <= ref2 ? j <= ref2 : j >= ref2); row_nr = 1 <= ref2 ? ++j : --j) {
      y = this._top_from_row_nr(me, row_nr);
      yield ['tex', `\\draw[sDebugQuadgrid] (${left},${y}) -- (${right},${y});\n`];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_debug_cellgrid_events = function*(me) {
    /* TAINT use fixed size like 1mm */
    var bottom, d, designation, left, ref1, right, top;
    if (!me.debug) {
      return;
    }
    ref1 = me.cell_dimensions;
    //.........................................................................................................
    for (designation in ref1) {
      d = ref1[designation];
      left = d.left + 0.5;
      right = d.right - 0.5;
      top = d.top + 0.5;
      bottom = d.bottom - 0.5;
      yield ['tex', `\\draw[sDebugCellgrid] (${left},${bottom})` + ` -- (${left},${top})` + ` -- (${right},${top});`];
      yield ['tex', ` \\draw[sDebugCellgrid] (${right},${top}) ` + ` -- (${right},${bottom});`];
      yield ['tex', ` \\draw[sDebugCellgrid] (${left},${bottom}) ` + ` -- (${right},${bottom});`];
      yield ['tex', "\n"];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_debug_joints_events = function*(me) {
    var col_letter, col_nr, joint, ref1, ref2, row_nr, z;
    if (!me.debug) {
      return;
    }
    this._ensure_joint_coordinates(me);
    ref1 = this._walk_column_letters_and_numbers(me, 'long');
    //.........................................................................................................
    /* TAINT code duplication; use iterator */
    for (z of ref1) {
      [col_letter, col_nr] = z;
      ref2 = this._walk_row_numbers(me, 'long');
      for (row_nr of ref2) {
        joint = `${col_letter}${row_nr}`;
        yield ['tex', `\\node[sDebugJoints] at ($(joint_${joint})+(2mm,2mm)$) {{\\mktsStyleCode{}${joint}}}; `];
        yield ['tex', `\\node[sDebugJoints, shape = circle, draw ] at (joint_${joint}) {};%\n`];
      }
    }
  };

  //===========================================================================================================
  // ENSURERS
  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._ensure_unitvector = function(me) {
    if (me.unitwidth == null) {
      this.unitwidth(me, me.default.unitwidth);
    }
    if (me.unitheight == null) {
      this.unitheight(me, me.default.unitheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_joint_coordinates = function(me) {
    if (me.joint_coordinates != null) {
      return null;
    }
    this._ensure_quadwidths(me);
    this._ensure_quadheights(me);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_gridwidth = function(me) {
    if (me.gridwidth != null) {
      return null;
    }
    throw new Error("(MKTS/TABLE 5822) gridwidth must be set");
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_gridheight = function(me) {
    if (me.gridheight != null) {
      return null;
    }
    throw new Error("(MKTS/TABLE 5822) gridheight must be set");
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_quadwidths = function(me) {
    if ((me.quadwidths.length === me.gridwidth + 1) && (indexOf.call(me.quadwidths.slice(1), null) < 0)) {
      return null;
    }
    throw new Error(`(MKTS/TABLE 5822) quadwidths must be all set; got ${rpr(me.quadwidths)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_quadheights = function(me) {
    if ((me.quadheights.length === me.gridheight + 1) && (indexOf.call(me.quadheights.slice(1), null) < 0)) {
      return null;
    }
    throw new Error(`(MKTS/TABLE 5822) quadheights must be all set; got ${rpr(me.quadheights)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_margin = function(me) {
    if (me.marginwidth == null) {
      this.marginwidth(me, me.default.marginwidth);
    }
    if (me.marginheight == null) {
      this.marginheight(me, me.default.marginheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_padding = function(me) {
    if (me.paddingwidth == null) {
      this.paddingwidth(me, me.default.paddingwidth);
    }
    if (me.paddingheight == null) {
      this.paddingheight(me, me.default.paddingheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_quad_dimensions = function(me) {
    var bottom, col_letter, col_nr, designation, left, ref1, ref2, right, row_nr, top, z;
    ref1 = this._walk_column_letters_and_numbers(me, 'short');
    for (z of ref1) {
      [col_letter, col_nr] = z;
      ref2 = this._walk_row_numbers(me, 'short');
      for (row_nr of ref2) {
        designation = `${col_letter}${row_nr}`;
        left = this._left_from_col_nr(me, col_nr);
        right = this._right_from_col_nr(me, col_nr);
        top = this._top_from_row_nr(me, row_nr);
        bottom = this._bottom_from_row_nr(me, row_nr);
        // ### TAINT must not become negative ###
        // quadwidth_u   = right  - left # - 2 * me.marginwidth
        // quadheight_u  = bottom - top  # - 2 * me.marginheight
        me.quad_dimensions[designation] = {col_nr, row_nr, left, right, top, bottom};
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_cell_dimensions = function(me) {
    var bottom, cellquads, designation, height_u, left, ref1, right, top, width_u;
    ref1 = me.cellquads;
    /* TAINT use me.cell_dimensions */
    for (designation in ref1) {
      cellquads = ref1[designation];
      left = this._left_from_col_nr(me, cellquads.left);
      right = this._right_from_col_nr(me, cellquads.right);
      top = this._top_from_row_nr(me, cellquads.top);
      bottom = this._bottom_from_row_nr(me, cellquads.bottom);
      width_u = right - left;
      height_u = bottom - top;
      me.cell_dimensions[designation] = {left, right, width_u, top, bottom, height_u};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_border_dimensions = function(me) {
    /* TAINT must not become negative */
    var bottom, d, designation, height_u, left, ref1, right, top, width_u;
    ref1 = me.cell_dimensions;
    for (designation in ref1) {
      d = ref1[designation];
      left = d.left + me.marginwidth;
      right = d.right - me.marginwidth;
      top = d.top + me.marginheight;
      bottom = d.bottom - me.marginheight;
      width_u = right - left;
      height_u = bottom - top;
      me.border_dimensions[designation] = {left, right, width_u, top, bottom, height_u};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_pod_dimensions = function(me) {
    /* TAINT must not become negative */
    var bottom, d, designation, height_u, left, ref1, right, top, width_u;
    ref1 = me.cell_dimensions;
    for (designation in ref1) {
      d = ref1[designation];
      left = d.left + me.paddingwidth;
      right = d.right - me.paddingwidth;
      top = d.top + me.paddingheight;
      bottom = d.bottom - me.paddingheight;
      width_u = right - left;
      height_u = bottom - top;
      me.pod_dimensions[designation] = {left, right, width_u, top, bottom, height_u};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._left_from_col_nr = function(me, col_nr) {
    var R, i, nr, ref1;
    /* TAINT should precompute */
    this._ensure_quadwidths(me);
    R = 0;
    for (nr = i = 1, ref1 = col_nr; (1 <= ref1 ? i < ref1 : i > ref1); nr = 1 <= ref1 ? ++i : --i) {
      R += me.quadwidths[nr];
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._right_from_col_nr = function(me, col_nr) {
    return (this._left_from_col_nr(me, col_nr)) + me.quadwidths[col_nr];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._top_from_row_nr = function(me, row_nr) {
    var R, i, nr, ref1;
    /* TAINT should precompute */
    this._ensure_quadheights(me);
    R = 0;
    for (nr = i = 1, ref1 = row_nr; (1 <= ref1 ? i < ref1 : i > ref1); nr = 1 <= ref1 ? ++i : --i) {
      R += me.quadheights[nr];
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._bottom_from_row_nr = function(me, row_nr) {
    return (this._top_from_row_nr(me, row_nr)) + me.quadheights[row_nr];
  };

  //===========================================================================================================
  // ITERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_column_letters_and_numbers = function*(me, mode) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter, col_nr, delta, i, ref1;
    this._ensure_gridwidth(me);
    delta = mode === 'short' ? 0 : 1;
    for (col_nr = i = 1, ref1 = me.gridwidth + delta; (1 <= ref1 ? i <= ref1 : i >= ref1); col_nr = 1 <= ref1 ? ++i : --i) {
      col_letter = (EXCJSCC.n2l(col_nr)).toLowerCase();
      yield [col_letter, col_nr];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_row_numbers = function*(me, mode) {
    var delta, i, ref1, row_nr;
    this._ensure_gridheight(me);
    delta = mode === 'short' ? 0 : 1;
    for (row_nr = i = 1, ref1 = me.gridheight + delta; (1 <= ref1 ? i <= ref1 : i >= ref1); row_nr = 1 <= ref1 ? ++i : --i) {
      yield row_nr;
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_cellquads_sides = function*(me, cellquads, side) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter, col_nr, col_nr_1, col_nr_2, i, j, quad, ref1, ref2, ref3, ref4, row_nr, row_nr_1, row_nr_2;
    switch (side) {
      case 'left':
        row_nr_1 = cellquads.top;
        row_nr_2 = cellquads.bottom;
        col_nr_1 = cellquads.left;
        col_nr_2 = cellquads.left;
        break;
      case 'right':
        row_nr_1 = cellquads.top;
        row_nr_2 = cellquads.bottom;
        col_nr_1 = cellquads.right;
        col_nr_2 = cellquads.right;
        break;
      case 'top':
        row_nr_1 = cellquads.top;
        row_nr_2 = cellquads.top;
        col_nr_1 = cellquads.left;
        col_nr_2 = cellquads.right;
        break;
      case 'bottom':
        row_nr_1 = cellquads.bottom;
        row_nr_2 = cellquads.bottom;
        col_nr_1 = cellquads.left;
        col_nr_2 = cellquads.right;
        break;
      case '*':
        yield* this._walk_cellquads_sides(me, cellquads, 'left');
        yield* this._walk_cellquads_sides(me, cellquads, 'right');
        yield* this._walk_cellquads_sides(me, cellquads, 'top');
        yield* this._walk_cellquads_sides(me, cellquads, 'bottom');
        return;
      default:
        throw new Error(`(MKTS/TABLE 4550) illegal argument for side ${rpr(side)}`);
    }
    for (row_nr = i = ref1 = row_nr_1, ref2 = row_nr_2; (ref1 <= ref2 ? i <= ref2 : i >= ref2); row_nr = ref1 <= ref2 ? ++i : --i) {
      for (col_nr = j = ref3 = col_nr_1, ref4 = col_nr_2; (ref3 <= ref4 ? j <= ref4 : j >= ref4); col_nr = ref3 <= ref4 ? ++j : --j) {
        col_letter = (EXCJSCC.n2l(col_nr)).toLowerCase();
        quad = `${col_letter}${row_nr}`;
        yield ({col_nr, row_nr, col_letter, quad, side});
      }
    }
  };

  //===========================================================================================================
  // HELPERS
  //-----------------------------------------------------------------------------------------------------------
  _stackerr = function(ref, message, error = null) {
    message = `(MKTS/TABLE#${ref}) ${message}`;
    if (error != null) {
      error.message = `${message}\n${error.message}`;
    } else {
      error = new Error(message);
    }
    return error;
  };

}).call(this);

//# sourceMappingURL=mkts-table.js.map
