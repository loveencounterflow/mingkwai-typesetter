// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, IG, MD_READER, MKTS, UNITS, _TMP_BORDERSEGMENTS, _fail, _record, _record_fail, _stackerr, alert, badge, contains, copy, debug, echo, help, hide, info, is_hidden, is_stamped, jr, log, rpr, select, stamp, tex, texr, unstamp, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS/TABLE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  // #...........................................................................................................
  // D                         = require 'pipedreams'
  // $                         = D.remit.bind D
  // $async                    = D.remit_async.bind D
  // #...........................................................................................................
  // ECS                       = require './eval-cs'
  MKTS = require('./main');

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  //...........................................................................................................
  copy = function(x) {
    return Object.assign({}, x);
  };

  jr = JSON.stringify;

  IG = require('intergrid');

  _TMP_BORDERSEGMENTS = require('intergrid/lib/experiments/border-segment-finder');

  UNITS = require('./mkts-table-units');

  //-----------------------------------------------------------------------------------------------------------
  tex = function(source) {
    return ['tex', source];
  };

  //-----------------------------------------------------------------------------------------------------------
  texr = function(ref, source) {
    source = ref != null ? `${source}% MKTSTBL ${ref}\n` : `${source}%\n`;
    return tex(source);
  };

  //-----------------------------------------------------------------------------------------------------------
  contains = function(text, pattern) {
    switch (CND.type_of(pattern)) {
      case 'regex':
        return (text.match(pattern)) != null;
      default:
        throw new Error(`pattern not supported: ${rpr(pattern)}`);
    }
    return null;
  };

  //===========================================================================================================
  // INITIALIZATION
  //-----------------------------------------------------------------------------------------------------------
  this._new_description = function(S, meta, id) {
    var R;
    R = {
      '~isa': 'MKTS/TABLE/description',
      /* TAINT rename field */
      name: id != null ? id : null,
      meta: meta != null ? meta : null,
      debug: false,
      /* FTTB, we make a subset of stream state available here: */
      options: {
        layout: S.options.layout,
        defs: S.options.defs
      },
      _tmp: {
        prv_fieldnr: 0
      },
      fails: [],
      /* recoverable errors / fails warnings */fieldcells: {},
      /* field extents in terms of cells, by fieldnrs */fieldnrs_by_aliases: {},
      /* lists of fieldnrs indexed by field aliases */cellfields: {},
      /* which cells belong to what fields, by cellkeys */table_dimensions: {},
      /* width and height of enclosing `\minipage`, in terms of (unitwidth,unitheight) */cell_dimensions: {},
      fieldborders: {},
      /* field borders, as TikZ styles by edges */gaps: {
        background: {},
        /* gaps between grid and background, by fieldnrs */margins: {},
        /* field margins, by fieldnrs */paddings: {}
      },
      /* field paddings, by fieldnrs */field_dimensions: {},
      /* field extents in terms of (unitwidth,unitheight), by fieldnrs */border_dimensions: {},
      /* border extents in terms of (unitwidth,unitheight), by fieldnrs */pod_dimensions: {},
      /* pod extents in terms of (unitwidth,unitheight), by fieldnrs */valigns: {},
      /* vertical pod alignments, by fieldnrs */haligns: {},
      /* horizontal pod alignments, by fieldnrs */colwidths: [null],
      /* [ 0 ] is default, [ 1 .. grid.width ] explicit or implicit widths */rowheights: [null],
      /* [ 0 ] is default, [ 1 .. grid.height ] explicit or implicit heights */joint_coordinates: null,
      //.......................................................................................................
      styles: {
        sThin: 'thin',
        sThick: 'thick',
        sDotted: 'dotted',
        sDashed: 'dashed',
        sRed: 'red',
        sBlack: 'black',
        sDebugCellgrid: 'gray!30,sThin',
        sDebugFieldgrid: 'gray!30,sThin',
        sDebugJoints: 'gray!30,sThick'
      },
      //.......................................................................................................
      default: {
        unitwidth: '1mm',
        unitheight: '1mm',
        colwidth: 10,
        rowheight: 10,
        gaps: {
          background: 0,
          margins: 0,
          paddings: 1
        }
      }
    };
    return R;
  };

  //===========================================================================================================
  // PUBLIC API
  //-----------------------------------------------------------------------------------------------------------
  this._set_unitsize = function(me, direction, text) {
    var p;
    if (direction !== 'width' && direction !== 'height') {
      throw _stackerr(me, 'µ4613', `expected 'width' or 'height', got ${rpr(direction)}`);
    }
    p = `unit${direction}`;
    //.........................................................................................................
    /* Do nothing if dimension already defined: */
    if (me[p] != null) {
      return _record_fail(me, 'µ5661', `unable to re-define ${p}`);
    }
    //.........................................................................................................
    me[p] = UNITS.new_quantity(text);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_lanesizes = function(me, direction, text) {
    var base, base1, fail, j, k, lane_count, lanenr, length, match, nr, p, ps, ref1, ref2, ref3, selector, z;
    if (direction !== 'width' && direction !== 'height') {
      throw _stackerr(me, 'µ2352', `expected 'width' or 'height', got ${rpr(direction)}`);
    }
    //.........................................................................................................
    p = direction === 'width' ? 'colwidth' : 'rowheight';
    ps = direction === 'width' ? 'colwidths' : 'rowheights';
    //.........................................................................................................
    this._ensure_grid(me);
    lane_count = me.grid[direction];
    //.........................................................................................................
    if ((match = text.match(/^(?:(?<selector>[^:]+):)?(?<length>[+\d.]+)$/)) == null) {
      _record_fail(me, 'µ6377', `need a text like '2.7', 'A*,C3:20' or similar for mkts-table/${p}, got ${rpr(text)}`);
      return null;
    }
    //.........................................................................................................
    ({selector, length} = match.groups);
    length = parseFloat(length);
    //.........................................................................................................
    if (selector != null) {
      if ((base = me[ps])[0] == null) {
        base[0] = me.default[p];
      }
      for (nr = j = 1, ref1 = lane_count; (1 <= ref1 ? j <= ref1 : j >= ref1); nr = 1 <= ref1 ? ++j : --j) {
        if ((base1 = me[ps])[nr] == null) {
          base1[nr] = me.default[p];
        }
      }
      ref2 = this._walk_fails_and_lanenrs_from_direction_and_selector(me, direction, selector);
      /* set defaults where missing */
      for (z of ref2) {
        [fail, lanenr] = z;
        if (fail != null) {
          _record(me, fail);
        } else {
          me[ps][lanenr] = length;
        }
      }
    } else {
      me[ps][0] = length/* set default */
      for (nr = k = 1, ref3 = lane_count; (1 <= ref3 ? k <= ref3 : k >= ref3); nr = 1 <= ref3 ? ++k : --k) {
        me[ps][nr] = length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.grid = function(me, text) {
    if (me.grid != null) {
      return _record_fail(me, 'µ5689', "unable to re-define grid");
    }
    me.grid = IG.GRID.new_grid_from_cellkey(text);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitwidth = function(me, text) {
    return this._set_unitsize(me, 'width', text);
  };

  this.unitheight = function(me, text) {
    return this._set_unitsize(me, 'height', text);
  };

  this.columnwidth = function(me, text) {
    return this._set_lanesizes(me, 'width', text);
  };

  this.rowheight = function(me, text) {
    return this._set_lanesizes(me, 'height', text);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldcells = function(me, source) {
    var alias, aliases, base, base1, d, fieldcell, fieldnr, j, len, match, name, ref1, selector;
    this._ensure_grid(me);
    //.........................................................................................................
    if ((match = source.match(this.fieldcells.source_pattern)) == null) {
      _record_fail(me, 'µ6379', `need a text like 'A1:B2:"alias"' or similar for mkts-table/${fieldcell}, got ${rpr(source)}`);
      return null;
    }
    //.........................................................................................................
    ({selector, aliases} = match.groups);
    if (!contains(selector, /\.\./)) {
      selector = selector + '..' + selector;
    }
    aliases = this._parse_aliases(me, aliases);
    fieldnr = (me._tmp.prv_fieldnr += +1);
    d = IG.GRID.parse_rangekey(me.grid, selector);
    if (me.fieldcells[fieldnr] != null) {
      throw new /* should never happen */Error(`(MKTS/TABLE µ5375) unable to redefine field ${fieldnr}: ${rpr(source)}`);
    }
    //.........................................................................................................
    me.fieldcells[fieldnr] = d;
    ref1 = IG.GRID.walk_cells_from_rangeref(me.grid, d);
    for (fieldcell of ref1) {
      ((base = me.cellfields)[name = fieldcell.cellkey] != null ? base[name] : base[name] = []).push(fieldnr);
    }
//.........................................................................................................
    for (j = 0, len = aliases.length; j < len; j++) {
      alias = aliases[j];
      ((base1 = me.fieldnrs_by_aliases)[alias] != null ? base1[alias] : base1[alias] = []).push(fieldnr);
    }
    //.........................................................................................................
    this._set_default_gaps(me, fieldnr);
    return null;
  };

  this.fieldcells.source_pattern = /^\s*(?<selector>[^:\s]+)\s*(?::\s*(?<aliases>\S.+))?\s*$/;

  //-----------------------------------------------------------------------------------------------------------
  this._parse_aliases = function(me, source) {
    var R, alias, j, len, part, ref1;
    if ((source == null) || (source.length === 0)) {
      return [];
    }
    R = (function() {
      var j, len, ref1, results;
      ref1 = source.split(',');
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        part = ref1[j];
        results.push(part.trim());
      }
      return results;
    })();
    if (R[R.length - 1] === '') {
      R.pop();
    }
    for (j = 0, len = R.length; j < len; j++) {
      alias = R[j];
      if ((ref1 = alias[0]) !== '@' && ref1 !== '#') {
        throw new Error(`(MKTS/TABLE µ5376) aliases must be prefixed with '@' or '#', got ${rpr(alias)}`);
      }
    }
    return [...(new Set(R))];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._resolve_aliases = function(me, selector) {
    var R, fieldnr, fieldnrs, j, k, len, len1, term;
    if (CND.isa_text(selector)) {
      /* TAINT now done in API walk_fieldnrs_from_selectors */
      /* Given a comma-separated string or a list of cellkeys, cellrange literals, and / or aliases, return a
      list of cellkeys and / or cellrange literals. */
      return this._resolve_aliases(me, selector.split(/\s*,\s*/));
    }
    R = new Set();
    for (j = 0, len = selector.length; j < len; j++) {
      term = selector[j];
      if ((CND.isa_text(term)) && ((term.startsWith('@')) || (term.startsWith('#')))) {
        if ((fieldnrs = me.fieldnrs_by_aliases[term]) == null) {
          /* TAINT error or failure? */
          throw new Error(`(MKTS/TABLE µ5446) unknown alias ${rpr(term)}`);
        }
        for (k = 0, len1 = fieldnrs.length; k < len1; k++) {
          fieldnr = fieldnrs[k];
          R.add(fieldnr);
        }
      } else {
        R.add(term);
      }
    }
    return [...R];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_default_gaps = function(me, fieldnr) {
    var base, edge, gap, j, k, len, len1, ref1, ref2;
    ref1 = ['background', 'margins', 'paddings'];
    for (j = 0, len = ref1.length; j < len; j++) {
      gap = ref1[j];
      ref2 = ['left', 'right', 'top', 'bottom'];
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        edge = ref2[k];
        ((base = me.gaps[gap])[fieldnr] != null ? base[fieldnr] : base[fieldnr] = {})[edge] = me.default.gaps[gap];
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldalignvertical = function(me, text) {
    var _, fail, field_designation, match, ref1, selector, value, z;
    if ((match = text.match(/^(.+?):([^:]+)$/)) == null) {
      throw new Error(`(MKTS/TABLE µ5229) expected something like 'C3:top' for mkts-table/fieldalignvertical, got ${rpr(text)}`);
    }
    [_, selector, value] = match;
    //.........................................................................................................
    if (value !== 'top' && value !== 'bottom' && value !== 'center' && value !== 'spread') {
      throw new Error(`(MKTS/TABLE µ1876) expected one of 'top', 'bottom', 'center', 'spread' for mkts-table/fieldalignvertical, got ${rpr(value)}`);
    }
    ref1 = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (z of ref1) {
      [fail, field_designation] = z;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({field_designation})})`);
      } else {
        me.valigns[field_designation] = value;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldalignhorizontal = function(me, text) {
    var _, fail, field_designation, match, ref1, selector, value, z;
    if ((match = text.match(/^(.+?):([^:]+)$/)) == null) {
      throw new Error(`(MKTS/TABLE µ5229) expected something like 'C3:left' for mkts-table/fieldalignhorizontal, got ${rpr(text)}`);
    }
    [_, selector, value] = match;
    //.........................................................................................................
    if (value !== 'left' && value !== 'right' && value !== 'center' && value !== 'justified') {
      throw new Error(`(MKTS/TABLE µ1876) expected one of 'left', 'right', 'center', 'justified' for mkts-table/fieldalignhorizontal, got ${rpr(value)}`);
    }
    ref1 = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (z of ref1) {
      [fail, field_designation] = z;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({field_designation})})`);
      } else {
        me.haligns[field_designation] = value;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.name = function(me, text) {
    if (me.name != null) {
      throw new Error(`(MKTS/TABLE µ1344) refused to rename table layout ${rpr(me.name)} to ${rpr(text)}`);
    }
    //.........................................................................................................
    /* TAINT should check syntax (no whitespace etc) */
    me.name = text;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.debug = function(me, text) {
    switch (text) {
      case 'true':
        me.debug = true;
        break;
      case 'false':
        me.debug = false;
        break;
      default:
        throw new Error(`(MKTS/TABLE µ1343) expected 'true' or 'false' for mkts-table/debug, got ${rpr(text)}`);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldborder = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, j, k, len, len1, ref1, ref2;
    d = this._parse_fieldborder(me, text);
    ref1 = d.fieldnames;
    for (j = 0, len = ref1.length; j < len; j++) {
      fieldname = ref1[j];
      ref2 = d.edges;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        edge = ref2[k];
        ((base = me.fieldborders)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.style;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.margin = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, j, k, len, len1, ref1, ref2;
    d = this._parse_fieldgap(me, 'margin', text);
    ref1 = d.fieldnames;
    for (j = 0, len = ref1.length; j < len; j++) {
      fieldname = ref1[j];
      ref2 = d.edges;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        edge = ref2[k];
        ((base = me.gaps.margins)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.padding = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, j, k, len, len1, ref1, ref2;
    d = this._parse_fieldgap(me, 'padding', text);
    ref1 = d.fieldnames;
    for (j = 0, len = ref1.length; j < len; j++) {
      fieldname = ref1[j];
      ref2 = d.edges;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        edge = ref2[k];
        ((base = me.gaps.paddings)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.background_gap = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, j, k, len, len1, ref1, ref2;
    d = this._parse_fieldgap(me, 'background', text);
    ref1 = d.fieldnames;
    for (j = 0, len = ref1.length; j < len; j++) {
      fieldname = ref1[j];
      ref2 = d.edges;
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        edge = ref2[k];
        ((base = me.gaps.background)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // PARSERS ETC
  //-----------------------------------------------------------------------------------------------------------
  this._idx_from_col_and_row = function(col, row) {
    var col_idx, row_idx, type;
    if ((type = CND.type_of(col)) !== 'text') {
      throw new Error(`(MKTS/TABLE µ6848) expected a text for col, got a ${rpr(type)}`);
    }
    if ((type = CND.type_of(row)) !== 'text') {
      throw new Error(`(MKTS/TABLE µ1080) expected a text for row, got a ${rpr(type)}`);
    }
    //.........................................................................................................
    col_idx = (col.codePointAt(0)) - ('a'.codePointAt(0));
    row_idx = (parseInt(row, 10)) - 1;
    return {
      col: col_idx,
      row: row_idx
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_fieldborder = function(me, fieldborder) {
    var _, edges, fail, field_designation, fieldnames, groups, ref1, selector, style, type, z;
    if ((type = CND.type_of(fieldborder)) !== 'text') {
      throw new Error(`(MKTS/TABLE µ1225) expected a text for fieldborder, got a ${rpr(type)}`);
    }
    if ((groups = fieldborder.match(/^(.+):(.+):(.*)$/)) == null) {
      throw new Error(`(MKTS/TABLE µ2582) expected a fieldborder like 'a1:left:sDashed,sThick', got ${rpr(fieldborder)}`);
    }
    [_, selector, edges, style] = groups;
    //.........................................................................................................
    edges = (function() {
      var j, len, ref1, results;
      ref1 = edges.split(',');
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        _ = ref1[j];
        results.push(_.trim());
      }
      return results;
    })();
    if (indexOf.call(edges, '*') >= 0) {
      edges = ['top', 'left', 'bottom', 'right'];
    }
    fieldnames = [];
    ref1 = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (z of ref1) {
      [fail, field_designation] = z;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({field_designation})})`);
      } else {
        fieldnames.push(field_designation);
      }
    }
    //.........................................................................................................
    style = style.trim();
    if (style === 'none' || style === '') {
      style = null;
    }
    //.........................................................................................................
    return {fieldnames, edges, style};
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  /* TAINT unify parsing routines */
  this._parse_fieldgap = function(me, gaptype, source) {
    var _, edges, fail, fieldname, fieldnames, length, match, ref1, selector, type, z;
    if ((type = CND.type_of(source)) !== 'text') {
      throw new Error(`(MKTS/TABLE µ1225) expected a text for source, got a ${rpr(type)}`);
    }
    //.........................................................................................................
    if ((match = source.match(/^(?<selector>[^:]+):(?<edges>[^:]+):(?<length>-?[+\d.]+)$/)) == null) {
      _record_fail(me, 'µ6377', `need a text like 'A*,C3:top:2' or similar for mkts-table/${gaptype}, got ${rpr(source)}`);
      return null;
    }
    //.........................................................................................................
    ({selector, edges, length} = match.groups);
    length = parseFloat(length);
    //.........................................................................................................
    edges = (function() {
      var j, len, ref1, results;
      ref1 = edges.split(',');
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        _ = ref1[j];
        results.push(_.trim());
      }
      return results;
    })();
    if (indexOf.call(edges, '*') >= 0) {
      edges = ['top', 'left', 'bottom', 'right'];
    }
    fieldnames = [];
    ref1 = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (z of ref1) {
      [fail, fieldname] = z;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({fieldname})})`);
      } else {
        fieldnames.push(fieldname);
      }
    }
    //.........................................................................................................
    return {fieldnames, edges, length};
  };

  //===========================================================================================================
  // EVENT GENERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_events = function*(me, selectors_and_content_events, layout_name_stack, field_selector_stack) {
    this._compute_cell_dimensions(me);
    this._compute_field_dimensions(me);
    this._compute_border_dimensions(me);
    this._compute_pod_dimensions(me);
    this._compute_table_height(me);
    //.........................................................................................................
    me._tmp_is_outermost = layout_name_stack.length < 2;
    me._tmp_name = layout_name_stack.join('/');
    yield* this._walk_opening_events(me, layout_name_stack, field_selector_stack);
    yield* this._walk_style_events(me);
    yield* this._walk_field_borders_events(me);
    yield* this._walk_pod_events(me, selectors_and_content_events);
    yield* this._walk_debug_joints_events(me);
    yield* this._walk_debug_cellgrid_events(me);
    yield* this._walk_debug_fieldgrid_events(me);
    yield* this._walk_closing_events(me);
    yield* this._convert_fails_to_warnings(me);
    //.........................................................................................................
    // ### dump description for debugging ###
    // ### TAINT make dump configurable ###
    // ### TAINT print in smaller type ###
    // yield [ 'tex', '\\par{}', ]
    // yield [ 'text', "MKTS Table Description:\n\n", ( copy me.meta ), ]
    // yield [ '(', 'code', [],                       ( copy me.meta ), ]
    // yield [ '.', 'text', ( rpr me ),               ( copy me.meta ), ]
    // yield [ ')', 'code', [],                       ( copy me.meta ), ]
    // yield [ 'tex', '\\par{}', ]
    //.........................................................................................................
    delete me._tmp_name;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_opening_events = function*(me, layout_name_stack, field_selector_stack) {
    var layout_name;
    this._ensure_unitvector(me);
    layout_name = me.name;
    me._tmp.unitwidth_txt = UNITS.as_text(me.unitwidth);
    me._tmp.unitheight_txt = UNITS.as_text(me.unitheight);
    me._tmp.table_height_txt = UNITS.as_text(me.unitheight, '*', me.table_dimensions.height);
    me._tmp.table_width_txt = UNITS.as_text(me.unitwidth, '*', me.table_dimensions.width);
    /* TAINT in order to be used in \vspace, must subtract equivalent of one \mktsLineheight; in order te
    used in \mktsVspace, must subtract one. */
    UNITS.set_factor('mktsLineheight', me.options.layout.lineheight.value, me.options.layout.lineheight.unit);
    me._tmp.table_height_lh = (UNITS.integer_multiple(me._tmp.table_height_txt, 'mktsLineheight')).value;
    /* TAINT valign center, top, bottom do not work well for nested tables; need dimensions of enclosing
    field to introduce explicit vertical spaces */
    yield tex("\n\n");
    yield tex("% ==========================================================================================================\n");
    yield tex(`% Beginning of MKTS Table (layout: ${rpr(layout_name)})\n`);
    /* TAINT undocumented kludge */
    if (me.nosamepage) {
      yield texr('ð1003', "\\setlength{\\fboxsep}{0mm}");
    } else {
      yield texr('ð1003', "\\begin{mktsSamepage}\\setlength{\\fboxsep}{0mm}");
    }
    yield texr('ð1003', "{\\tfRaise{1.35}\\begin{tikzpicture}[ overlay, yshift = 0mm, yscale = -1, line cap = rect ]");
    yield texr('ð1004', `\\tikzset{x=${me._tmp.unitwidth_txt}};\\tikzset{y=${me._tmp.unitheight_txt}};`);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_closing_events = function*(me) {
    var layout_name;
    layout_name = me.name;
    yield texr('ð1005', `\\end{tikzpicture}}\\makebox[${me._tmp.table_width_txt}][t]{~~}\\mktsVspaceAbsolute{${me._tmp.table_height_lh}}`);
    //.........................................................................................................
    // ### alternative solution with individual newlines: ###
    // yield texr 'ð1005', "~\\\\" for _ in [ 1 .. me._tmp.table_height_lh ]
    // yield texr 'ð1005', "\\end{tikzpicture}"
    //.........................................................................................................
    yield tex(`~\\par% End of MKTS Table (layout: ${rpr(layout_name)})\n`);
    /* TAINT undocumented kludge */
    if (me.nosamepage) {
      null;
    } else {
      yield texr('ð1005', "\\end{mktsSamepage}");
    }
    yield tex("% ==========================================================================================================\n");
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_style_events = function*(me) {
    var key, ref1, value;
    ref1 = me.styles;
    for (key in ref1) {
      value = ref1[key];
      yield texr('ð1009', `\\tikzset{${key}/.style={${value}}}`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_field_borders_events = function*(me) {
    /* TAINT refactor to method */
    var borders, d, edge, fieldnr, i, j, len, parts, ref1, ref2, ref3, v;
    ref1 = me.border_dimensions;
    //.........................................................................................................
    for (fieldnr in ref1) {
      d = ref1[fieldnr];
      if ((borders = me.fieldborders[fieldnr]) == null) {
        continue;
      }
      ref2 = _TMP_BORDERSEGMENTS.walk_segments(fieldnr, borders);
      for (i of ref2) {
        // urge '33455', "#{me.name}/#{fieldnr}", jr i
        // yield texr 'ð1010', "%>>> #{me.name}/#{fieldnr} #{jr i}% #{fieldnr} border "
        switch (i.mode) {
          case 'rectangle':
            yield texr('ð1011', `\\draw[${i.style}] (${d.left},${d.top}) rectangle (${d.right},${d.bottom});% ${fieldnr} border `);
            break;
          case 'single':
            edge = i.edges[0];
            v = this._line_xy_from_edge_and_dimensions(edge, d);
            yield texr('ð1012', `\\draw[${i.style}] (${v.from.x},${v.from.y}) -- (${v.to.x},${v.to.y});% ${fieldnr} ${edge} `);
            break;
          case 'connect':
            v = this._line_xy_from_edge_and_dimensions(i.edges[0], d);
            parts = [`\\draw[${i.style}] (${v.from.x},${v.from.y})`];
            ref3 = i.edges;
            for (j = 0, len = ref3.length; j < len; j++) {
              edge = ref3[j];
              v = this._line_xy_from_edge_and_dimensions(edge, d);
              parts.push(`(${v.to.x},${v.to.y})`);
            }
            yield texr('ð1013', (parts.join(' -- ')) + ';');
            break;
          default:
            throw new Error(`(MKTS/TABLE µ4801) unknown border instruction mode ${rpr(i.mode)} in table ${me.name}/${fieldnr} ${jr(i)}`);
        }
      }
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._line_xy_from_edge_and_dimensions = function(edge, d) {
    switch (edge) {
      case 'left':
        return {
          from: {
            x: d.left,
            y: d.bottom
          },
          to: {
            x: d.left,
            y: d.top
          }
        };
      case 'top':
        return {
          from: {
            x: d.left,
            y: d.top
          },
          to: {
            x: d.right,
            y: d.top
          }
        };
      case 'right':
        return {
          from: {
            x: d.right,
            y: d.top
          },
          to: {
            x: d.right,
            y: d.bottom
          }
        };
      case 'bottom':
        return {
          from: {
            x: d.right,
            y: d.bottom
          },
          to: {
            x: d.left,
            y: d.bottom
          }
        };
      default:
        throw new Error(`(MKTS/TABLE µ4800) illegal value for edge ${rpr(edge)}`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._get_halign_tex = function(me, halign) {
    switch (halign) {
      case 'left':
        return '\\mktsLeft{}';
      case 'right':
        return '\\mktsRight{}';
      case 'center':
        return '\\mktsCenter{}';
      case 'justified':
        return '';
      default:
        throw new Error(`(MKTS/TABLE µ4799) illegal value for halign ${rpr(halign)}`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._get_valign_tex = function(me, valign) {
    switch (valign) {
      case 'top':
        return 't';
      case 'bottom':
        return 'b';
      case 'center':
        return 'c';
      case 'spread':
        return 's';
      default:
        throw new Error(`(MKTS/TABLE µ4799) illegal value for valign ${rpr(valign)}`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_pod_events = function*(me, selectors_and_content_events) {
    var _ref, content, d, halign_tex, j, len, pod_height_txt, pod_width_txt, ref1, ref2, ref3, ref4, ref5, selector, sub_event, valign_tex, z;
    ref1 = this._walk_most_recent_field_designations(me, selectors_and_content_events);
    for (z of ref1) {
      [selector, ...content] = z;
      if (content.length === 0) {
        // debug '88733', selector, content if me.name is 'small-table'
        continue;
      }
      d = me.pod_dimensions[selector];
      pod_height_txt = UNITS.as_text(me.unitheight, '*', d.height);
      pod_width_txt = UNITS.as_text(me.unitwidth, '*', d.width);
      // ### TAINT faulty, should look at whether sub-table is only content, then set valign to top ###
      // if me._tmp_is_outermost then  valign_tex  = @_get_valign_tex me, me.valigns[ selector ] ? me.valigns[ '*' ] ? 'center'
      // else                          valign_tex  = @_get_valign_tex me, 'top'
      valign_tex = this._get_valign_tex(me, (ref2 = (ref3 = me.valigns[selector]) != null ? ref3 : me.valigns['*']) != null ? ref2 : 'center');
      halign_tex = this._get_halign_tex(me, (ref4 = (ref5 = me.haligns[selector]) != null ? ref5 : me.haligns['*']) != null ? ref4 : 'left');
      _ref = ` field ${me._tmp_name}:${selector} `;
      yield texr('ð1014', `\\node[anchor=north west,inner sep=0mm] at (${d.left},${d.top}) {%${_ref}`);
      if (me.debug) {
        yield texr('ð1015', `\\mktsColorframebox{orange}{%${_ref} debugging sub-framebox `);
      }
      yield texr('ð1016', `\\begin{minipage}[t][${pod_height_txt}][${valign_tex}]{${pod_width_txt}}${halign_tex}%${_ref}`);
      yield ['.', 'noindent', null, {}];
      for (j = 0, len = content.length; j < len; j++) {
        sub_event = content[j];
        yield sub_event;
      }
      if (me.debug) {
        yield texr('ð1017', `\\end{minipage}}};%${_ref} debugging sub-framebox`);
      } else {
        yield texr('ð1018', `\\end{minipage}};%${_ref}`);
      }
    }
  };

  //===========================================================================================================
  // EVENT GENERATORS: DEBUGGING EVENTS
  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._should_debug = function(me) {
    return me.debug || (me.fails.length !== 0);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_debug_cellgrid_events = function*(me) {
    var bottom, colnr, j, k, left, ref1, ref2, right, rownr, top, x, y;
    if (!this._should_debug(me)) {
      return;
    }
    //.........................................................................................................
    yield texr('ð1019', "\\begin{scope}[on background layer]");
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    top = this._top_from_rownr(me, 1);
    bottom = this._bottom_from_rownr(me, me.grid.height);
    for (colnr = j = 1, ref1 = me.grid.width + 1; (1 <= ref1 ? j <= ref1 : j >= ref1); colnr = 1 <= ref1 ? ++j : --j) {
      x = this._left_from_colnr(me, colnr);
      yield texr('ð1020', `\\draw[sDebugCellgrid] (${x},${top}) -- (${x},${bottom});`);
    }
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    left = this._left_from_colnr(me, 1);
    right = this._right_from_colnr(me, me.grid.width);
    for (rownr = k = 1, ref2 = me.grid.height + 1; (1 <= ref2 ? k <= ref2 : k >= ref2); rownr = 1 <= ref2 ? ++k : --k) {
      y = this._top_from_rownr(me, rownr);
      yield texr('ð1021', `\\draw[sDebugCellgrid] (${left},${y}) -- (${right},${y});`);
    }
    //.........................................................................................................
    yield texr('ð1022', "\\end{scope}");
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_debug_fieldgrid_events = function*(me) {
    /* TAINT use fixed size like 1mm */
    var bottom, d, designation, left, ref1, right, top;
    if (!this._should_debug(me)) {
      return;
    }
    //.........................................................................................................
    yield texr('ð1023', "\\begin{scope}[on background layer]");
    ref1 = me.field_dimensions;
    //.........................................................................................................
    for (designation in ref1) {
      d = ref1[designation];
      left = d.left + 0.5;
      right = d.right - 0.5;
      top = d.top + 0.5;
      bottom = d.bottom - 0.5;
      yield ['tex', `\\draw[sDebugFieldgrid] (${left},${bottom})` + ` -- (${left},${top})` + ` -- (${right},${top});`];
      yield ['tex', ` \\draw[sDebugFieldgrid] (${right},${top}) ` + ` -- (${right},${bottom});`];
      yield ['tex', ` \\draw[sDebugFieldgrid] (${left},${bottom}) ` + ` -- (${right},${bottom});`];
      yield ['tex', "% MKTSTBL@26\n"];
    }
    //.........................................................................................................
    yield texr('ð1024', "\\end{scope}");
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_debug_joints_events = function*(me) {
    var cellkey, colletters, colnr, ref1, ref2, rownr, x, y, z;
    if (!this._should_debug(me)) {
      return;
    }
    this._ensure_grid(me);
    this._ensure_joint_coordinates(me);
    //.........................................................................................................
    yield texr('ð1025', "\\begin{scope}[on background layer]");
    ref1 = IG.GRID.walk_colletters_and_colnrs(me.grid);
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    for (z of ref1) {
      [colletters, colnr] = z;
      ref2 = IG.GRID.walk_rownrs(me.grid);
      for (rownr of ref2) {
        x = (this._left_from_colnr(me, colnr)) + 2;
        y = (this._top_from_rownr(me, rownr)) + 2;
        cellkey = `${colletters}${rownr}`;
        yield tex(`\\node[sDebugJoints] at (${x},${y}) {{\\mktsStyleCode{}${cellkey}}}; `);
      }
    }
    //.........................................................................................................
    yield texr('ð1026', "\\end{scope}");
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._convert_fails_to_warnings = function*(me) {
    var fail, j, len, ref1;
    ref1 = me.fails;
    for (j = 0, len = ref1.length; j < len; j++) {
      fail = ref1[j];
      yield ['.', 'warning', fail, copy(me.meta)];
      yield ['tex', '\\par\n'];
    }
  };

  //===========================================================================================================
  // ENSURERS
  //-----------------------------------------------------------------------------------------------------------
  this._ensure_unitvector = function(me) {
    if (me.unitwidth == null) {
      this.unitwidth(me, me.default.unitwidth);
    }
    if (me.unitheight == null) {
      this.unitheight(me, me.default.unitheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_joint_coordinates = function(me) {
    if (me.joint_coordinates != null) {
      return null;
    }
    this._ensure_cellwidths(me);
    this._ensure_cellheights(me);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_grid = function(me) {
    if (me.grid != null) {
      return null;
    }
    throw new Error("(MKTS/TABLE µ5307) grid must be set");
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_cellwidths = function(me) {
    if ((me.colwidths.length === me.grid.width + 1) && (indexOf.call(me.colwidths.slice(1), null) < 0)) {
      return null;
    }
    throw new Error(`(MKTS/TABLE µ4039) colwidths must be all set; got ${rpr(me.colwidths)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_cellheights = function(me) {
    if ((me.rowheights.length === me.grid.height + 1) && (indexOf.call(me.rowheights.slice(1), null) < 0)) {
      return null;
    }
    throw new Error(`(MKTS/TABLE µ8054) rowheights must be all set; got ${rpr(me.rowheights)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_cell_dimensions = function(me) {
    var bottom, colletters, colnr, designation, left, ref1, ref2, right, rownr, top, z;
    this._ensure_grid(me);
    ref1 = IG.GRID.walk_colletters_and_colnrs(me.grid);
    for (z of ref1) {
      [colletters, colnr] = z;
      ref2 = IG.GRID.walk_rownrs(me.grid);
      for (rownr of ref2) {
        designation = `${colletters}${rownr}`;
        left = this._left_from_colnr(me, colnr);
        right = this._right_from_colnr(me, colnr);
        top = this._top_from_rownr(me, rownr);
        bottom = this._bottom_from_rownr(me, rownr);
        me.cell_dimensions[designation] = {colnr, rownr, left, right, top, bottom};
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_field_dimensions = function(me) {
    var bottom, designation, fieldcells, height, left, ref1, right, top, width;
    ref1 = me.fieldcells;
    /* TAINT use me.field_dimensions */
    for (designation in ref1) {
      fieldcells = ref1[designation];
      left = this._left_from_colnr(me, fieldcells.left_colnr);
      right = this._right_from_colnr(me, fieldcells.right_colnr);
      top = this._top_from_rownr(me, fieldcells.top_rownr);
      bottom = this._bottom_from_rownr(me, fieldcells.bottom_rownr);
      width = right - left;
      height = bottom - top;
      me.field_dimensions[designation] = {left, right, width, top, bottom, height};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_border_dimensions = function(me) {
    /* TAINT must not become negative */
    var bottom, d, designation, height, left, ref1, right, target, top, width;
    ref1 = me.field_dimensions;
    /* TAINT code duplication */
    for (designation in ref1) {
      d = ref1[designation];
      if ((target = me.gaps.margins[designation]) == null) {
        throw new Error(`(MKTS/TABLE µ8054) unknown field designation ${rpr(designation)}`);
      }
      left = d.left + target.left;
      right = d.right - target.right;
      top = d.top + target.top;
      bottom = d.bottom - target.bottom;
      width = right - left;
      height = bottom - top;
      me.border_dimensions[designation] = {left, right, width, top, bottom, height};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_pod_dimensions = function(me) {
    /* TAINT must not become negative */
    var bottom, d, designation, height, left, ref1, right, target, top, width;
    ref1 = me.field_dimensions;
    /* TAINT code duplication */
    for (designation in ref1) {
      d = ref1[designation];
      if ((target = me.gaps.paddings[designation]) == null) {
        throw new Error(`(MKTS/TABLE µ8054) unknown field designation ${rpr(designation)}`);
      }
      left = d.left + target.left;
      right = d.right - target.right;
      top = d.top + target.top;
      bottom = d.bottom - target.bottom;
      width = right - left;
      height = bottom - top;
      me.pod_dimensions[designation] = {left, right, width, top, bottom, height};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_table_height = function(me) {
    me.table_dimensions.height = this._bottom_from_rownr(me, me.grid.height);
    me.table_dimensions.width = this._right_from_colnr(me, me.grid.width);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._left_from_colnr = function(me, colnr) {
    var R, j, nr, ref1;
    /* TAINT should precompute */
    this._ensure_cellwidths(me);
    R = 0;
    for (nr = j = 1, ref1 = colnr; (1 <= ref1 ? j < ref1 : j > ref1); nr = 1 <= ref1 ? ++j : --j) {
      R += me.colwidths[nr];
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._right_from_colnr = function(me, colnr) {
    return (this._left_from_colnr(me, colnr)) + me.colwidths[colnr];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._top_from_rownr = function(me, rownr) {
    var R, j, nr, ref1;
    /* TAINT should precompute */
    this._ensure_cellheights(me);
    R = 0;
    for (nr = j = 1, ref1 = rownr; (1 <= ref1 ? j < ref1 : j > ref1); nr = 1 <= ref1 ? ++j : --j) {
      R += me.rowheights[nr];
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._bottom_from_rownr = function(me, rownr) {
    return (this._top_from_rownr(me, rownr)) + me.rowheights[rownr];
  };

  //===========================================================================================================
  // ITERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_fails_and_fieldnrs_from_selector = function*(me, selector) {
    /* TAINT this will have to be changed to allow for named fields */
    var cell, count, fieldnr, fieldnrs, j, k, len, len1, ref1, seen_fieldnrs, term;
    count = 0;
    seen_fieldnrs = new Set();
    selector = this._resolve_aliases(me, selector);
//.........................................................................................................
/* TAINT must resolve aliases */
    for (j = 0, len = selector.length; j < len; j++) {
      term = selector[j];
      if (CND.isa_text(term)) {
        ref1 = IG.GRID.walk_cells_from_selector(me.grid, selector);
        for (cell of ref1) {
          if ((fieldnrs = me.cellfields[cell.cellkey]) == null) {
            continue;
          }
          for (k = 0, len1 = fieldnrs.length; k < len1; k++) {
            fieldnr = fieldnrs[k];
            if (seen_fieldnrs.has(fieldnr)) {
              /* TAINT code duplication */
              continue;
            }
            seen_fieldnrs.add(fieldnr);
            count += +1;
            yield [null, fieldnr];
          }
        }
      } else {
        fieldnr = term;
        if (seen_fieldnrs.has(fieldnr)) {
          /* TAINT code duplication */
          continue;
        }
        seen_fieldnrs.add(fieldnr);
        count += +1;
        yield [null, fieldnr];
      }
    }
    //.........................................................................................................
    if (count === 0) {
      yield [_fail(me, 'µ5131', `selector ${rpr(selector)} does not match any field`), null];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_fails_and_lanenrs_from_direction_and_selector = function*(me, direction, selector) {
    var cell, count, lanenr, p, ref1, seen_lanenrs;
    if (direction !== 'width' && direction !== 'height') {
      throw _stackerr(me, 'µ4656', `expected 'width' or 'height', got ${rpr(direction)}`);
    }
    //.........................................................................................................
    count = 0;
    seen_lanenrs = new Set();
    p = direction === 'width' ? 'colnr' : 'rownr';
    ref1 = IG.GRID.walk_cells_from_selector(me.grid, selector);
    //.........................................................................................................
    /* TAINT should implement this in intergrid */
    for (cell of ref1) {
      lanenr = cell[p];
      if (seen_lanenrs.has(lanenr)) {
        continue;
      }
      seen_lanenrs.add(lanenr);
      count += +1;
      yield [null, lanenr];
    }
    //.........................................................................................................
    if (count === 0) {
      /* should never happen */
      yield [_fail(me, 'µ5131', `selector ${rpr(selector)} doesn't match any lane`), null];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_most_recent_field_designations = function*(me, fieldhints_and_stuff) {
    /* Given a list of `[ fieldhints, x... ]` lists, return a list of `[ designation, x... ]` lists such
    that each `designation` that resulted from each of the `fieldhints` is only kept from the instance
    that appeared last in the list. Each `fieldhints` can produce an arbitrary number of matching field
    designations, and later occurrences of a given field will replace earlier appearances. */
    var R, fail, field_designation, fieldhints, j, len, ref1, stuff, z;
    R = {};
    for (j = 0, len = fieldhints_and_stuff.length; j < len; j++) {
      [fieldhints, ...stuff] = fieldhints_and_stuff[j];
      ref1 = this._walk_fails_and_fieldnrs_from_selector(me, fieldhints);
      for (z of ref1) {
        [fail, field_designation] = z;
        if (fail != null) {
          _record(me, fail);
        } else {
          R[field_designation] = stuff;
        }
      }
    }
    for (field_designation in R) {
      stuff = R[field_designation];
      yield [field_designation, ...stuff];
    }
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @_walk_table_edge_field_designations = ( me, edge ) ->
  //   seen_field_designations = new Set()
  //   for d from IG.GRID.walk_edge_cellrefs me.grid, edge
  //     continue unless ( field_designations = me.cellfields[ d.cellkey ] )?
  //     for field_designation in field_designations
  //       continue if seen_field_designations.has field_designation
  //       seen_field_designations.add field_designation
  //       yield field_designation
  //   yield return

  //===========================================================================================================
  // HELPERS
  //-----------------------------------------------------------------------------------------------------------
  _stackerr = function(me, ref, message, error = null) {
    /*
    Prepends local error message to the original one so we get more informative traces. Usage:

    ```
    try
      ...
    catch error
      throw _stackerr error, "(MKTS/TABLE µ4781) ... new message ..."
    ```
    */
    var filename, line_nr, ref1, ref2, ref3, ref4;
    filename = (ref1 = (ref2 = me.meta) != null ? ref2.filename : void 0) != null ? ref1 : '<NOFILENAME>';
    line_nr = (ref3 = (ref4 = me.meta) != null ? ref4.line_nr : void 0) != null ? ref3 : '(NOLINENR)';
    message = `[${badge}#${ref}: ${filename}#${line_nr}]: ${message}`;
    if (error != null) {
      error.message = `${message}\n${error.message}`;
    } else {
      error = new Error(message);
    }
    return error;
  };

  //-----------------------------------------------------------------------------------------------------------
  _fail = function(me, ref, message) {
    /* TAINT using strings as error values is generally being frowned upon */
    var filename, line_nr, ref1, ref2, ref3, ref4;
    filename = (ref1 = (ref2 = me.meta) != null ? ref2.filename : void 0) != null ? ref1 : '<NOFILENAME>';
    line_nr = (ref3 = (ref4 = me.meta) != null ? ref4.line_nr : void 0) != null ? ref3 : '(NOLINENR)';
    return `[${badge}#${ref}: ${filename}#${line_nr}]: ${message}`;
  };

  //-----------------------------------------------------------------------------------------------------------
  _record = function(me, message) {
    me.fails.push(message);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  _record_fail = function(me, ref, message) {
    return _record(me, _fail(me, ref, message));
  };

}).call(this);

//# sourceMappingURL=mkts-table.js.map
