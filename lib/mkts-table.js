// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var $, $async, CND, D, ECS, EXCJSCC, MD_READER, MKTS, _stackerr, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, jr, log, rpr, select, stamp, unstamp, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS/TABLE';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  //...........................................................................................................
  ECS = require('./eval-cs');

  MKTS = require('./main');

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  //...........................................................................................................
  copy = function(x) {
    return Object.assign({}, x);
  };

  EXCJSCC = require('./exceljs-spreadsheet-address-codec');

  jr = JSON.stringify;

  //===========================================================================================================
  // INITIALIZATION
  //-----------------------------------------------------------------------------------------------------------
  this._new_description = function(S) {
    var R;
    R = {
      '~isa': 'MKTS/TABLE/description',
      fieldcells: {},
      /* field extents in terms of cells, by field designations */cellfields: {},
      /* which cells belong to what fields, by cellkeys */cell_dimensions: {},
      fieldborders: {},
      /* field borders, as TikZ styles by sides */field_dimensions: {},
      /* field extents in terms of (unitwidth,unitheight), by field designations */border_dimensions: {},
      /* border extents in terms of (unitwidth,unitheight), by field designations */pod_dimensions: {},
      /* pod extents in terms of (unitwidth,unitheight), by field designations */valigns: {},
      /* vertical pod alignments, by field designations */cellwidths: [null],
      /* [ 0 ] is default, [ 1 .. gridwidth ] explicit or implicit widths */cellheights: [null],
      /* [ 0 ] is default, [ 1 .. gridheight ] explicit or implicit heights */joint_coordinates: null,
      debug: false,
      //.......................................................................................................
      styles: {
        sThin: 'thin',
        sThick: 'thick',
        sDotted: 'dotted',
        sDashed: 'dashed',
        sRed: 'red',
        sBlack: 'black',
        sDebugCellgrid: 'gray!30,sThin',
        sDebugFieldgrid: 'gray!30,sThin',
        sDebugJoints: 'gray!30,sThick'
      },
      //.......................................................................................................
      default: {
        // gridwidth:     4
        // gridheight:    4
        unitwidth: '1mm',
        unitheight: '1mm',
        // cellwidth:     10
        // cellheight:    10
        marginwidth: 0,
        marginheight: 0,
        paddingwidth: 0,
        paddingheight: 0
      }
    };
    return R;
  };

  //===========================================================================================================
  // PUBLIC API
  //-----------------------------------------------------------------------------------------------------------
  this.gridwidth = function(me, text) {
    var match, type;
    //.........................................................................................................
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 4517) need a text for mkts-table/gridwidth, got a ${type}`);
    }
    if ((match = text.match(/^\s*(\d+)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 4300) need a text like '3' or similar for mkts-table/gridwidth, got ${rpr(text)}`);
    }
    if (me.gridwidth != null) {
      throw new Error("(MKTS/TABLE 5827) unable to re-define gridwidth");
    }
    //.........................................................................................................
    me.gridwidth = parseInt(match[1], 10);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.gridheight = function(me, text) {
    var match, type;
    //.........................................................................................................
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9150) need a text for mkts-table/gridheight, got a ${type}`);
    }
    if ((match = text.match(/^\s*(\d+)\s*$/)) == null) {
      throw new Error(`(MKTS/TABLE 6572) need a text like '3' or similar for mkts-table/gridheight, got ${rpr(text)}`);
    }
    if (me.gridheight != null) {
      throw new Error("(MKTS/TABLE 6501) unable to re-define gridheight");
    }
    //.........................................................................................................
    me.gridheight = parseInt(match[1], 10);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitwidth = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9131) need a text for mkts-table/unitwidth, got a ${type}`);
    }
    if (me.unitwidth != null) {
      throw new Error("(MKTS/TABLE 6477) unable to re-define unitheight");
    }
    //.........................................................................................................
    me.unitwidth = text;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitheight = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 7680) need a text for mkts-table/unitheight, got a ${type}`);
    }
    if (me.unitheight != null) {
      throw new Error("(MKTS/TABLE 2142) unable to re-define unitheight");
    }
    //.........................................................................................................
    me.unitheight = text;
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cellwidths = function(me, text) {
    var i, nr, ref1, value;
    /* TAINT should validate */
    this._ensure_gridwidth(me);
    value = parseFloat(text);
    me.cellwidths[0] = value/* set default */
    for (nr = i = 1, ref1 = me.gridwidth; (1 <= ref1 ? i <= ref1 : i >= ref1); nr = 1 <= ref1 ? ++i : --i) {
      me.cellwidths[nr] = value;
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.cellheights = function(me, text) {
    var i, nr, ref1, value;
    /* TAINT should validate */
    this._ensure_gridheight(me);
    value = parseFloat(text);
    me.cellheights[0] = value/* set default */
    for (nr = i = 1, ref1 = me.gridheight; (1 <= ref1 ? i <= ref1 : i >= ref1); nr = 1 <= ref1 ? ++i : --i) {
      me.cellheights[nr] = value;
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldcells = function(me, text) {
    var base, d, designation, fieldcell, name, ref1, type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8532) need a text for mkts-table/fieldcells, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_gridwidth(me);
    this._ensure_gridheight(me);
    this._ensure_unitvector(me);
    d = this._parse_range_cellref(me, text);
    designation = d.tl;
    if (d.right > me.gridwidth) {
      throw new Error(`(MKTS/TABLE 2282) field exceeds grid width: ${rpr(text)}`);
    }
    if (d.bottom > me.gridheight) {
      throw new Error(`(MKTS/TABLE 2523) field exceeds grid height: ${rpr(text)}`);
    }
    if (me.fieldcells[designation] != null) {
      throw new Error(`(MKTS/TABLE 1246) unable to redefine field ${designation}: ${rpr(text)}`);
    }
    //.........................................................................................................
    me.fieldcells[designation] = d;
    ref1 = this._walk_fieldcells(me, d);
    for (fieldcell of ref1) {
      ((base = me.cellfields)[name = fieldcell.designation] != null ? base[name] : base[name] = []).push(designation);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldborder = function(me, text) {
    var base, d, field, i, j, len, len1, ref1, ref2, side, type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 2034) need a text for mkts-table/fieldborder, got a ${type}`);
    }
    //.........................................................................................................
    d = this._parse_fieldborder(me, text);
    ref1 = d.fields;
    for (i = 0, len = ref1.length; i < len; i++) {
      field = ref1[i];
      ref2 = d.sides;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        side = ref2[j];
        ((base = me.fieldborders)[field] != null ? base[field] : base[field] = {})[side] = d.style;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldalignvertical = function(me, text) {
    var _, field_designation, fieldhints, match, ref1, type, value;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 2034) need a text for mkts-table/fieldalignvertical, got a ${type}`);
    }
    //.........................................................................................................
    if ((match = text.match(/^(.+?):([^:]+)$/)) == null) {
      throw new Error(`(MKTS/TABLE 2034) expected something like 'c3:top' for mkts-table/fieldalignvertical, got ${rpr(text)}`);
    }
    [_, fieldhints, value] = match;
    //.........................................................................................................
    if (value !== 'top' && value !== 'bottom' && value !== 'center' && value !== 'spread') {
      throw new Error(`(MKTS/TABLE 2034) expected one of 'top', 'bottom', 'center', 'spread' for mkts-table/fieldalignvertical, got ${rpr(value)}`);
    }
    ref1 = this._walk_field_designations_from_hints(me, fieldhints);
    //.........................................................................................................
    for (field_designation of ref1) {
      me.valigns[field_designation] = value;
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.debug = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8055) need a text for mkts-table/field, got a ${type}`);
    }
    //.........................................................................................................
    switch (text) {
      case 'true':
        me.debug = true;
        break;
      case 'false':
        me.debug = false;
        break;
      default:
        throw new Error(`(MKTS/TABLE 9035) expected 'true' or 'false' for mkts-table/debug, got ${rpr(text)}`);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.marginwidth = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 1811) need a text for mkts-table/marginwidth, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.marginwidth = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.marginheight = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 9480) need a text for mkts-table/marginheight, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.marginheight = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.paddingwidth = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 8254) need a text for mkts-table/paddingwidth, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.paddingwidth = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.paddingheight = function(me, text) {
    var type;
    if ((type = CND.type_of(text)) !== 'text') {
      throw new Error(`(MKTS/TABLE 7209) need a text for mkts-table/paddingheight, got a ${type}`);
    }
    //.........................................................................................................
    this._ensure_unitvector(me);
    /* TAINT use parser, validate syntax */
    me.paddingheight = parseFloat(text);
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // PARSERS ETC
  //-----------------------------------------------------------------------------------------------------------
  this._idx_from_col_and_row = function(col, row) {
    var col_idx, row_idx, type;
    if ((type = CND.type_of(col)) !== 'text') {
      throw new Error(`(MKTS/TABLE 4182) expected a text for col, got a ${rpr(type)}`);
    }
    if ((type = CND.type_of(row)) !== 'text') {
      throw new Error(`(MKTS/TABLE 5931) expected a text for row, got a ${rpr(type)}`);
    }
    //.........................................................................................................
    col_idx = (col.codePointAt(0)) - ('a'.codePointAt(0));
    row_idx = (parseInt(row, 10)) - 1;
    return {
      col: col_idx,
      row: row_idx
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_range_cellref = function(me, cell_range) {
    /* TAINT don't use EXCJSCC directly */
    var R, match, type;
    if ((type = CND.type_of(cell_range)) !== 'text') {
      throw new Error(`(MKTS/TABLE 6402) expected a text for cell_range, got a ${rpr(type)}`);
    }
    if ((match = cell_range.match(/^([a-z]{1,3})([0-9]{1,4}):([a-z]{1,3})([0-9]{1,4})$/)) == null) {
      throw new Error(`(MKTS/TABLE 2499) expected a cell range like 'a1:d4', got ${rpr(cell_range)}`);
    }
    R = EXCJSCC.decode(cell_range.toUpperCase());
    delete R.dimensions;
    R.tl = R.tl.toLowerCase();
    R.br = R.br.toLowerCase();
    R.tr = `${(EXCJSCC.n2l(R.right)).toLowerCase()}${R.top}`;
    R.bl = `${(EXCJSCC.n2l(R.left)).toLowerCase()}${R.bottom}`;
    return R;
  };

  // #-----------------------------------------------------------------------------------------------------------
  // ### TAINT use proper parsing tool ###
  // @_parse_coordinate_with_units = ( me, coordinate ) ->
  //   unless ( type = CND.type_of coordinate ) is 'text'
  //     throw new Error "(MKTS/TABLE 1045) expected a text for coordinate, got a #{rpr type}"
  //   unless ( match = coordinate.match /^\s*\(\s*([-0-9.]{1,8}[a-z]{0,3})\s*,\s*([-0-9.]{1,8}[a-z]{0,3})\s*\)\s*$/ )?
  //     throw new Error "(MKTS/TABLE 2032) expected a coordinate with units like '( 1mm, 2.4cm )', got #{rpr coordinate}"
  //   [ _, x, y, ] = match
  //   return { x, y, }

  // #-----------------------------------------------------------------------------------------------------------
  // ### TAINT use proper parsing tool ###
  // @_parse_coordinate_without_units = ( me, coordinate ) ->
  //   unless ( type = CND.type_of coordinate ) is 'text'
  //     throw new Error "(MKTS/TABLE 2262) expected a text for coordinate, got a #{rpr type}"
  //   unless ( match = coordinate.match /^\s*\(\s*([-0-9.]{1,8})\s*,\s*([-0-9.]{1,8})\s*\)\s*$/ )?
  //     throw new Error "(MKTS/TABLE 6904) expected a unitless coordinate like '( 1, 2.4 )', got #{rpr coordinate}"
  //   [ _, x, y, ] = match
  //   return { x, y, }

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT use proper parsing tool */
  this._parse_fieldborder = function(me, fieldborder) {
    var _, cellkeys, d, fieldhint, fieldhints, fields, groups, i, len, ref1, side, sides, style, type;
    if ((type = CND.type_of(fieldborder)) !== 'text') {
      throw new Error(`(MKTS/TABLE 6043) expected a text for fieldborder, got a ${rpr(type)}`);
    }
    if ((groups = fieldborder.match(/^(.+):(.+):(.*)$/)) == null) {
      throw new Error(`(MKTS/TABLE 5822) expected a fieldborder like 'a1:left:sDashed,sThick', got ${rpr(fieldborder)}`);
    }
    [_, fieldhints, sides, style] = groups;
    //.........................................................................................................
    sides = (function() {
      var i, len, ref1, results;
      ref1 = sides.split(',');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        _ = ref1[i];
        results.push(_.trim());
      }
      return results;
    })();
    if (indexOf.call(sides, '*') >= 0) {
      sides = ['top', 'left', 'bottom', 'right'];
    }
    //.........................................................................................................
    /* TAINT code duplication */
    /* TAINT this will have to be changed to allow for named fields */
    fieldhints = new Set((function() {
      var i, len, ref1, results;
      ref1 = fieldhints.split(',');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        _ = ref1[i];
        results.push(_.trim());
      }
      return results;
    })());
    if (fieldhints.has('*')) {
      fields = Object.keys(me.fieldcells);
    } else {
      /* TAINT as it stands, `fieldborder'table:bottom,right:red'` will style all bottom and right borders
      of all fields that have real estate along the bottom and right borders of the table. An improved version
      should probably only affect the bottom borders of table-bottom fields and the right borders of
      table-right fields. Use two statements `fieldborder'table:bottom:red'`, `fieldborder'table:right:red'` to
      express that meaning FTTB. */
      if (fieldhints.has('table')) {
        fieldhints.delete('table');
        for (i = 0, len = sides.length; i < len; i++) {
          side = sides[i];
          ref1 = this._walk_table_edge_cells(me, side);
          for (d of ref1) {
            fieldhints.add(d.cellkey);
          }
        }
      }
      cellkeys = (function() {
        var results;
        results = [];
        for (fieldhint of fieldhints) {
          results.push(fieldhint);
        }
        return results;
      })();
      fields = this._fieldnames_from_cellkeys(me, cellkeys);
    }
    //.........................................................................................................
    style = style.trim();
    if (style === 'none' || style === '') {
      style = null;
    }
    //.........................................................................................................
    return {fields, sides, style};
  };

  //===========================================================================================================
  // EVENT GENERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_events = function*(me, fieldhints_and_content_events) {
    this._compute_cell_dimensions(me);
    this._compute_field_dimensions(me);
    this._compute_border_dimensions(me);
    this._compute_pod_dimensions(me);
    yield* this._walk_opening_events(me);
    yield* this._walk_style_events(me);
    yield* this._walk_debug_joints_events(me);
    yield* this._walk_debug_cellgrid_events(me);
    yield* this._walk_debug_fieldgrid_events(me);
    yield* this._walk_field_borders_events(me);
    yield* this._walk_pod_events(me, fieldhints_and_content_events);
    yield* this._walk_closing_events(me);
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  // ### dump description for debugging ###
  // ### TAINT make dump configurable ###
  // ### TAINT print in smaller type ###
  // yield [ 'tex', '\\par{}', ]
  // yield [ 'text', "MKTS Table Description:\n\n", ( copy me.meta ), ]
  // yield [ '(', 'code', [],                       ( copy me.meta ), ]
  // yield [ '.', 'text', ( rpr me ),               ( copy me.meta ), ]
  // yield [ ')', 'code', [],                       ( copy me.meta ), ]
  // yield [ 'tex', '\\par{}', ]
  //.........................................................................................................
  this._walk_opening_events = function*(me) {
    this._ensure_unitvector(me);
    yield ['tex', "\n\n"];
    yield ['tex', "\\par% Beginning of MKTS Table ==============================================================================\n"];
    yield ['tex', "{\\setlength{\\fboxsep}{0mm}%\n"];
    /* TAINT insert proper dimensions */
    // yield [ 'tex', "\\framebox{%\n", ] ### framebox ###
    yield ['tex', "\\begin{minipage}[t][45mm][t]{100mm}%\n"];
    yield ['tex', `\\newdimen\\mktsTableUnitwidth\\setlength{\\mktsTableUnitwidth}{${me.unitwidth}}%\n`];
    yield ['tex', `\\newdimen\\mktsTableUnitheight\\setlength{\\mktsTableUnitheight}{${me.unitheight}}%\n`];
    yield ['tex', "\\begin{tikzpicture}[ overlay, yshift = 0mm, yscale = -1, line cap = rect ]%\n"];
    yield ['tex', `\\tikzset{x=${me.unitwidth}};\\tikzset{y=${me.unitheight}};%\n`];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_closing_events = function*(me) {
    yield ['tex', "\\end{tikzpicture}%\n"];
    yield ['tex', "\\end{minipage}}%\n"];
    // yield [ 'tex', "}%\n", ] ### framebox ###
    yield ['tex', "\\par% End of MKTS Table ====================================================================================\n\n"];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_style_events = function*(me) {
    var key, ref1, value;
    ref1 = me.styles;
    for (key in ref1) {
      value = ref1[key];
      yield ['tex', `\\tikzset{${key}/.style={${value}}}%\n`];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_field_borders_events = function*(me) {
    var borderstyle, d, designation, fieldborders, ref1;
    ref1 = me.border_dimensions;
    //.........................................................................................................
    for (designation in ref1) {
      d = ref1[designation];
      if ((fieldborders = me.fieldborders[designation]) == null) {
        continue;
      }
      if ((borderstyle = fieldborders['left']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.left},${d.top}) -- (${d.left},${d.bottom});\n`];
      }
      if ((borderstyle = fieldborders['right']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.right},${d.top}) -- (${d.right},${d.bottom});\n`];
      }
      if ((borderstyle = fieldborders['top']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.left},${d.top}) -- (${d.right},${d.top});\n`];
      }
      if ((borderstyle = fieldborders['bottom']) != null) {
        yield ['tex', `\\draw[${borderstyle}] (${d.left},${d.bottom}) -- (${d.right},${d.bottom});\n`];
      }
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._get_valign_tex = function(me, valign) {
    switch (valign) {
      case 'top':
        return 't';
      case 'bottom':
        return 'b';
      case 'center':
        return 'c';
      case 'spread':
        return 's';
      default:
        throw new Error(`(MKTS/TABLE 5822) illegal value for valign ${rpr(valign)}`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_most_recent_field_designations = function*(me, fieldhints_and_stuff) {
    /* Given a list of `[ fieldhints, x... ]` lists, return a list of `[ designation, x... ]` lists such
    that each `designation` that resulted from each of the `fieldhints` is only kept from the instance
    that appeared last in the list. Each `fieldhints` can produce an arbitrary number of matching field
    designations, and later occurrences of a given field will replace earlier appearances. */
    var R, field_designation, fieldhints, i, len, ref1, stuff;
    R = {};
    for (i = 0, len = fieldhints_and_stuff.length; i < len; i++) {
      [fieldhints, ...stuff] = fieldhints_and_stuff[i];
      ref1 = this._walk_field_designations_from_hints(me, fieldhints);
      for (field_designation of ref1) {
        R[field_designation] = stuff;
      }
    }
    for (field_designation in R) {
      stuff = R[field_designation];
      yield [field_designation, ...stuff];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_pod_events = function*(me, fieldhints_and_content_events) {
    var content, d, field_designation, i, len, ref1, ref2, ref3, sub_event, valign_tex, z;
    ref1 = this._walk_most_recent_field_designations(me, fieldhints_and_content_events);
    for (z of ref1) {
      [field_designation, content] = z;
      d = me.pod_dimensions[field_designation];
      valign_tex = this._get_valign_tex(me, (ref2 = (ref3 = me.valigns[field_designation]) != null ? ref3 : me.valigns['*']) != null ? ref2 : 'center');
      yield ['tex', `\\node[anchor=north west,inner sep=0mm] at (${d.left},${d.top})%\n`];
      yield ['tex', `{\\begin{minipage}[t][${d.height}\\mktsTableUnitheight][${valign_tex}]{${d.width}\\mktsTableUnitwidth}%\n`];
      // yield [ 'tex', "\\vfill{}", ]
      yield ['.', 'noindent', null, {}];
      for (i = 0, len = content.length; i < len; i++) {
        sub_event = content[i];
        // yield [ 'tex', "\\begin{flushright}", ]
        yield sub_event;
      }
      // yield [ 'tex', "\\par\\end{flushright}", ]
      // yield [ 'tex', "\\par", ]
      // yield [ 'tex', "\\vfill{}", ]
      yield ['tex', "\\end{minipage}};%\n"];
    }
  };

  //===========================================================================================================
  // EVENT GENERATORS: DEBUGGING EVENTS
  //-----------------------------------------------------------------------------------------------------------
  // yield [ 'tex', "{\\framebox{\\begin{minipage}[t][#{d.height}\\mktsTableUnitheight][t]{#{d.width}\\mktsTableUnitwidth}%\n", ]
  // yield [ 'tex', "A\\hfill{}B\\hfill{}C\\end{minipage}}};%\n", ]
  //.........................................................................................................
  this._walk_debug_cellgrid_events = function*(me) {
    var bottom, col_nr, i, j, left, ref1, ref2, right, row_nr, top, x, y;
    if (!me.debug) {
      return;
    }
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    top = (this._top_from_row_nr(me, 1)) - 3;
    bottom = (this._bottom_from_row_nr(me, me.gridheight)) + 3;
    for (col_nr = i = 1, ref1 = me.gridwidth + 1; (1 <= ref1 ? i <= ref1 : i >= ref1); col_nr = 1 <= ref1 ? ++i : --i) {
      x = this._left_from_col_nr(me, col_nr);
      yield ['tex', `\\draw[sDebugCellgrid] (${x},${top}) -- (${x},${bottom});\n`];
    }
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    left = (this._left_from_col_nr(me, 1)) - 3;
    right = (this._right_from_col_nr(me, me.gridwidth)) + 3;
    for (row_nr = j = 1, ref2 = me.gridheight + 1; (1 <= ref2 ? j <= ref2 : j >= ref2); row_nr = 1 <= ref2 ? ++j : --j) {
      y = this._top_from_row_nr(me, row_nr);
      yield ['tex', `\\draw[sDebugCellgrid] (${left},${y}) -- (${right},${y});\n`];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_debug_fieldgrid_events = function*(me) {
    /* TAINT use fixed size like 1mm */
    var bottom, d, designation, left, ref1, right, top;
    if (!me.debug) {
      return;
    }
    ref1 = me.field_dimensions;
    //.........................................................................................................
    for (designation in ref1) {
      d = ref1[designation];
      left = d.left + 0.5;
      right = d.right - 0.5;
      top = d.top + 0.5;
      bottom = d.bottom - 0.5;
      yield ['tex', `\\draw[sDebugFieldgrid] (${left},${bottom})` + ` -- (${left},${top})` + ` -- (${right},${top});`];
      yield ['tex', ` \\draw[sDebugFieldgrid] (${right},${top}) ` + ` -- (${right},${bottom});`];
      yield ['tex', ` \\draw[sDebugFieldgrid] (${left},${bottom}) ` + ` -- (${right},${bottom});`];
      yield ['tex', "\n"];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._walk_debug_joints_events = function*(me) {
    var cellkey, col_letter, col_nr, ref1, ref2, row_nr, x, y, z;
    if (!me.debug) {
      return;
    }
    this._ensure_joint_coordinates(me);
    ref1 = this._walk_column_letters_and_numbers(me, 'short');
    //.........................................................................................................
    /* TAINT use fixed size like 1mm */
    for (z of ref1) {
      [col_letter, col_nr] = z;
      ref2 = this._walk_row_numbers(me, 'short');
      for (row_nr of ref2) {
        x = (this._left_from_col_nr(me, col_nr)) + 2;
        y = (this._top_from_row_nr(me, row_nr)) + 2;
        cellkey = `${col_letter}${row_nr}`;
        yield ['tex', `\\node[sDebugJoints] at (${x},${y}) {{\\mktsStyleCode{}${cellkey}}}; `];
      }
    }
  };

  //===========================================================================================================
  // ENSURERS
  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._ensure_unitvector = function(me) {
    if (me.unitwidth == null) {
      this.unitwidth(me, me.default.unitwidth);
    }
    if (me.unitheight == null) {
      this.unitheight(me, me.default.unitheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_joint_coordinates = function(me) {
    if (me.joint_coordinates != null) {
      return null;
    }
    this._ensure_cellwidths(me);
    this._ensure_cellheights(me);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_gridwidth = function(me) {
    if (me.gridwidth != null) {
      return null;
    }
    throw new Error("(MKTS/TABLE 5822) gridwidth must be set");
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_gridheight = function(me) {
    if (me.gridheight != null) {
      return null;
    }
    throw new Error("(MKTS/TABLE 5822) gridheight must be set");
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_cellwidths = function(me) {
    if ((me.cellwidths.length === me.gridwidth + 1) && (indexOf.call(me.cellwidths.slice(1), null) < 0)) {
      return null;
    }
    throw new Error(`(MKTS/TABLE 5822) cellwidths must be all set; got ${rpr(me.cellwidths)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_cellheights = function(me) {
    if ((me.cellheights.length === me.gridheight + 1) && (indexOf.call(me.cellheights.slice(1), null) < 0)) {
      return null;
    }
    throw new Error(`(MKTS/TABLE 5822) cellheights must be all set; got ${rpr(me.cellheights)}`);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_margin = function(me) {
    if (me.marginwidth == null) {
      this.marginwidth(me, me.default.marginwidth);
    }
    if (me.marginheight == null) {
      this.marginheight(me, me.default.marginheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._ensure_padding = function(me) {
    if (me.paddingwidth == null) {
      this.paddingwidth(me, me.default.paddingwidth);
    }
    if (me.paddingheight == null) {
      this.paddingheight(me, me.default.paddingheight);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_cell_dimensions = function(me) {
    var bottom, col_letter, col_nr, designation, left, ref1, ref2, right, row_nr, top, z;
    ref1 = this._walk_column_letters_and_numbers(me, 'short');
    for (z of ref1) {
      [col_letter, col_nr] = z;
      ref2 = this._walk_row_numbers(me, 'short');
      for (row_nr of ref2) {
        designation = `${col_letter}${row_nr}`;
        left = this._left_from_col_nr(me, col_nr);
        right = this._right_from_col_nr(me, col_nr);
        top = this._top_from_row_nr(me, row_nr);
        bottom = this._bottom_from_row_nr(me, row_nr);
        // ### TAINT must not become negative ###
        // cellwidth_u   = right  - left # - 2 * me.marginwidth
        // cellheight_u  = bottom - top  # - 2 * me.marginheight
        me.cell_dimensions[designation] = {col_nr, row_nr, left, right, top, bottom};
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_field_dimensions = function(me) {
    var bottom, designation, fieldcells, height, left, ref1, right, top, width;
    ref1 = me.fieldcells;
    /* TAINT use me.field_dimensions */
    for (designation in ref1) {
      fieldcells = ref1[designation];
      left = this._left_from_col_nr(me, fieldcells.left);
      right = this._right_from_col_nr(me, fieldcells.right);
      top = this._top_from_row_nr(me, fieldcells.top);
      bottom = this._bottom_from_row_nr(me, fieldcells.bottom);
      width = right - left;
      height = bottom - top;
      me.field_dimensions[designation] = {left, right, width, top, bottom, height};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_border_dimensions = function(me) {
    /* TAINT must not become negative */
    var bottom, d, designation, height, left, ref1, right, top, width;
    ref1 = me.field_dimensions;
    for (designation in ref1) {
      d = ref1[designation];
      left = d.left + me.marginwidth;
      right = d.right - me.marginwidth;
      top = d.top + me.marginheight;
      bottom = d.bottom - me.marginheight;
      width = right - left;
      height = bottom - top;
      me.border_dimensions[designation] = {left, right, width, top, bottom, height};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._compute_pod_dimensions = function(me) {
    /* TAINT must not become negative */
    var bottom, d, designation, height, left, ref1, right, top, width;
    ref1 = me.field_dimensions;
    for (designation in ref1) {
      d = ref1[designation];
      left = d.left + me.paddingwidth;
      right = d.right - me.paddingwidth;
      top = d.top + me.paddingheight;
      bottom = d.bottom - me.paddingheight;
      width = right - left;
      height = bottom - top;
      me.pod_dimensions[designation] = {left, right, width, top, bottom, height};
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._left_from_col_nr = function(me, col_nr) {
    var R, i, nr, ref1;
    /* TAINT should precompute */
    this._ensure_cellwidths(me);
    R = 0;
    for (nr = i = 1, ref1 = col_nr; (1 <= ref1 ? i < ref1 : i > ref1); nr = 1 <= ref1 ? ++i : --i) {
      R += me.cellwidths[nr];
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._right_from_col_nr = function(me, col_nr) {
    return (this._left_from_col_nr(me, col_nr)) + me.cellwidths[col_nr];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._top_from_row_nr = function(me, row_nr) {
    var R, i, nr, ref1;
    /* TAINT should precompute */
    this._ensure_cellheights(me);
    R = 0;
    for (nr = i = 1, ref1 = row_nr; (1 <= ref1 ? i < ref1 : i > ref1); nr = 1 <= ref1 ? ++i : --i) {
      R += me.cellheights[nr];
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._bottom_from_row_nr = function(me, row_nr) {
    return (this._top_from_row_nr(me, row_nr)) + me.cellheights[row_nr];
  };

  //-----------------------------------------------------------------------------------------------------------
  this._fieldnames_from_cellkeys = function(me, cellkeys) {
    var R, cellfields, cellkey, fieldname, i, j, len, len1;
    R = new Set();
    for (i = 0, len = cellkeys.length; i < len; i++) {
      cellkey = cellkeys[i];
      if ((cellfields = me.cellfields[cellkey]) == null) {
        continue;
      }
      for (j = 0, len1 = cellfields.length; j < len1; j++) {
        fieldname = cellfields[j];
        R.add(fieldname);
      }
    }
    return (function() {
      var results;
      results = [];
      for (fieldname of R) {
        results.push(fieldname);
      }
      return results;
    })();
  };

  //===========================================================================================================
  // ITERATORS
  //-----------------------------------------------------------------------------------------------------------
  this._walk_column_letters_and_numbers = function*(me, mode) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter, col_nr, delta, i, ref1;
    this._ensure_gridwidth(me);
    delta = mode === 'short' ? 0 : 1;
    for (col_nr = i = 1, ref1 = me.gridwidth + delta; (1 <= ref1 ? i <= ref1 : i >= ref1); col_nr = 1 <= ref1 ? ++i : --i) {
      col_letter = (EXCJSCC.n2l(col_nr)).toLowerCase();
      yield [col_letter, col_nr];
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_row_numbers = function*(me, mode) {
    var delta, i, ref1, row_nr;
    this._ensure_gridheight(me);
    delta = mode === 'short' ? 0 : 1;
    for (row_nr = i = 1, ref1 = me.gridheight + delta; (1 <= ref1 ? i <= ref1 : i >= ref1); row_nr = 1 <= ref1 ? ++i : --i) {
      yield row_nr;
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_fieldcells = function*(me, fieldcells) {
    /* TAINT don't use EXCJSCC directly */
    var col_letter, col_nr, designation, i, j, ref1, ref2, ref3, ref4, row_nr;
    for (row_nr = i = ref1 = fieldcells.top, ref2 = fieldcells.bottom; (ref1 <= ref2 ? i <= ref2 : i >= ref2); row_nr = ref1 <= ref2 ? ++i : --i) {
      for (col_nr = j = ref3 = fieldcells.left, ref4 = fieldcells.right; (ref3 <= ref4 ? j <= ref4 : j >= ref4); col_nr = ref3 <= ref4 ? ++j : --j) {
        col_letter = (EXCJSCC.n2l(col_nr)).toLowerCase();
        designation = `${col_letter}${row_nr}`;
        yield ({col_nr, row_nr, col_letter, designation});
      }
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_field_designations_from_hints = function*(me, fieldhints) {
    /* TAINT this will have to be changed to allow for named fields */
    var _, count, field_designation, field_designations, fieldhint, fieldhints_set, i, j, key, keys, len, len1, seen_field_designations;
    count = 0;
    fieldhints_set = new Set((function() {
      var i, len, ref1, results;
      ref1 = fieldhints.split(',');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        _ = ref1[i];
        results.push(_.trim());
      }
      return results;
    })());
    if (fieldhints_set.has('*')) {
      keys = Object.keys(me.fieldcells);
      count += keys.length;
      for (i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        yield key;
      }
    } else {
      seen_field_designations = new Set();
      for (fieldhint of fieldhints_set) {
        if ((field_designations = me.cellfields[fieldhint]) == null) {
          continue;
        }
        for (j = 0, len1 = field_designations.length; j < len1; j++) {
          field_designation = field_designations[j];
          if (seen_field_designations.has(field_designation)) {
            continue;
          }
          seen_field_designations.add(field_designation);
          count += +1;
          yield field_designation;
        }
      }
    }
    if (count === 0) {
      throw new Error(`(MKTS/TABLE 5822) field hints ${rpr(fieldhints)} do not match any field`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_table_edge_field_designations = function*(me, edge) {
    var d, field_designation, field_designations, i, len, ref1, seen_field_designations;
    seen_field_designations = new Set();
    ref1 = this._walk_table_edge_cells(me, edge);
    for (d of ref1) {
      if ((field_designations = me.cellfields[d.cellkey]) == null) {
        continue;
      }
      for (i = 0, len = field_designations.length; i < len; i++) {
        field_designation = field_designations[i];
        if (seen_field_designations.has(field_designation)) {
          continue;
        }
        seen_field_designations.add(field_designation);
        yield field_designation;
      }
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this._walk_table_edge_cells = function*(me, edge) {
    /* TAINT don't use EXCJSCC directly */
    var cellkey, col_letter, col_nr, col_nr_1, col_nr_2, i, j, ref1, ref2, ref3, ref4, row_nr, row_nr_1, row_nr_2;
    switch (edge) {
      case 'left':
        col_nr_1 = 1;
        col_nr_2 = 1;
        row_nr_1 = 1;
        row_nr_2 = me.gridheight;
        break;
      case 'right':
        col_nr_1 = me.gridwidth;
        col_nr_2 = me.gridwidth;
        row_nr_1 = 1;
        row_nr_2 = me.gridheight;
        break;
      case 'top':
        col_nr_1 = 1;
        col_nr_2 = me.gridwidth;
        row_nr_1 = 1;
        row_nr_2 = 1;
        break;
      case 'bottom':
        col_nr_1 = 1;
        col_nr_2 = me.gridwidth;
        row_nr_1 = me.gridheight;
        row_nr_2 = me.gridheight;
        break;
      case '*':
        yield* this._walk_table_edge_cells(me, 'left');
        yield* this._walk_table_edge_cells(me, 'right');
        yield* this._walk_table_edge_cells(me, 'top');
        yield* this._walk_table_edge_cells(me, 'bottom');
        return;
      default:
        throw new Error(`(MKTS/TABLE 4550) illegal argument for edge ${rpr(edge)}`);
    }
    for (row_nr = i = ref1 = row_nr_1, ref2 = row_nr_2; (ref1 <= ref2 ? i <= ref2 : i >= ref2); row_nr = ref1 <= ref2 ? ++i : --i) {
      for (col_nr = j = ref3 = col_nr_1, ref4 = col_nr_2; (ref3 <= ref4 ? j <= ref4 : j >= ref4); col_nr = ref3 <= ref4 ? ++j : --j) {
        col_letter = (EXCJSCC.n2l(col_nr)).toLowerCase();
        cellkey = `${col_letter}${row_nr}`;
        yield ({col_nr, row_nr, col_letter, cellkey, edge});
      }
    }
  };

  //===========================================================================================================
  // HELPERS
  //-----------------------------------------------------------------------------------------------------------
  _stackerr = function(ref, message, error = null) {
    message = `(MKTS/TABLE#${ref}) ${message}`;
    if (error != null) {
      error.message = `${message}\n${error.message}`;
    } else {
      error = new Error(message);
    }
    return error;
  };

}).call(this);

//# sourceMappingURL=mkts-table.js.map
