// Generated by CoffeeScript 2.3.1
(function() {
  //###########################################################################################################
  // njs_path                  = require 'path'
  // njs_fs                    = require 'fs'
  //...........................................................................................................
  var $, CND, D, MKTS, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper,
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/MACRO-INTERPRETER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //-----------------------------------------------------------------------------------------------------------
  D = require('pipedreams');

  $ = D.remit.bind(D);

  // $async                    = D.remit_async.bind D
  //...........................................................................................................
  // Markdown_parser           = require 'markdown-it'
  // # Html_parser               = ( require 'htmlparser2' ).Parser
  // new_md_inline_plugin      = require 'markdown-it-regexp'
  //...........................................................................................................
  // HELPERS                   = require './HELPERS'
  //...........................................................................................................
  // misfit                    = Symbol 'misfit'
  MKTS = require('./main');

  //===========================================================================================================
  // PREPARE SANDBOX
  //-----------------------------------------------------------------------------------------------------------
  this.$prepare_sandbox = (S) => {
    var copy, hide, local_filename, sandbox, select, stamp;
    local_filename = 'XXXXXXXXXXXXX';
    copy = MKTS.MD_READER.copy.bind(MKTS.MD_READER);
    stamp = MKTS.MD_READER.stamp.bind(MKTS.MD_READER);
    hide = MKTS.MD_READER.hide.bind(MKTS.MD_READER);
    select = MKTS.MD_READER.select.bind(MKTS.MD_READER);
    //.........................................................................................................
    sandbox = {
      'rpr': CND.rpr,
      urge: CND.get_logger('urge', local_filename),
      help: CND.get_logger('help', local_filename),
      setImmediate: setImmediate,
      echo: function(...P) {
        return macro_output.push(CND.pen(...P));
      },
      mkts: {
        signature_reader: function(...P) {
          return P;
        },
        output: [],
        __filename: local_filename
      }
    };
    //.........................................................................................................
    return $((event, send) => {
      var changeset, meta;
      if (MKTS.MD_READER.select(event, '~', 'start')) {
        [meta] = slice.call(event, -1);
        send(event);
        changeset = MKTS.DIFFPATCH.diff({}, sandbox);
        return send(['~', 'change', changeset, copy(meta)]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._sandboxes = [];

  //-----------------------------------------------------------------------------------------------------------
  this.track_changes = function() {
    var idx;
    idx = this._sandboxes.length;
    this._sandboxes.push({});
    return () => {
      return this._sandboxes[idx];
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$capture_change_events = (S) => {
    /* This stream transform should be added somewhere near the end of the output stream; it will alow
    `~change` events—for example, those generated by plugin initializations—to be captured and made
    accessisble to `@$process_actions`. */
    var select;
    select = MKTS.MD_READER.select.bind(MKTS.MD_READER);
    return $((event, send) => {
      var _, changeset, i, idx, len, ref, sandbox;
      //.......................................................................................................
      if (select(event, '~', 'change')) {
        [_, _, changeset, _] = event;
        ref = this._sandboxes;
        for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
          sandbox = ref[idx];
          this._sandboxes[idx] = MK.TS.DIFFPATCH.patch(changeset, sandbox);
        }
        send(event);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$process_actions = (S) => {
    /* TAINT this is an essentially synchronous solution that will not work for async code */
    var CS, VM, copy, get_sandbox, hide, local_filename, macro_output, select, stamp;
    copy = MKTS.MD_READER.copy.bind(MKTS.MD_READER);
    stamp = MKTS.MD_READER.stamp.bind(MKTS.MD_READER);
    hide = MKTS.MD_READER.hide.bind(MKTS.MD_READER);
    select = MKTS.MD_READER.select.bind(MKTS.MD_READER);
    get_sandbox = this.track_changes();
    //.........................................................................................................
    CS = require('coffeescript');
    VM = require('vm');
    local_filename = 'XXXXXXXXXXXXX';
    macro_output = [];
    //.........................................................................................................
    return $((event, send) => {
      /* TAINT send `tex` or `text`??? */
      /* TAINT should preserve stack trace of error */
      /* TAINT use method to assemble warning event */
      /* TAINT write error log with full trace, insert reference (error nr) */
      var _, action_value, action_value_rpr, changeset, error, error_message, js_source, language, line_nr, macro_output_rpr, meta, mode, raw_source, ref, ref1, sandbox, sandbox_backup, wrapped_source;
      if (select(event, '.', 'action')) {
        [_, _, raw_source, meta] = event;
        send(stamp(hide(event)));
        ({mode, language, line_nr} = meta);
        error_message = null;
        sandbox = get_sandbox();
        sandbox_backup = MK.TS.DIFFPATCH.snapshot(sandbox);
        VM.createContext(sandbox);
        //.....................................................................................................
        switch (language) {
          case 'js':
            js_source = raw_source;
            break;
          case 'coffee':
            wrapped_source = "do =>\n  " + raw_source.replace(/\n/g, "\n  ");
            try {
              js_source = CS.compile(wrapped_source, {
                bare: true,
                filename: local_filename
              });
            } catch (error1) {
              error = error1;
              error_message = (ref = error['message']) != null ? ref : rpr(error);
            }
            break;
          default:
            error_message = `unknown language ${rpr(language)}`;
        }
        try {
          //.....................................................................................................
          action_value = VM.runInContext(js_source, sandbox, {
            filename: local_filename
          });
        } catch (error1) {
          //.....................................................................................................
          error = error1;
          error_message = (ref1 = error['message']) != null ? ref1 : rpr(error);
        }
        //.....................................................................................................
        if (error_message != null) {
          warn(error_message);
          error_message = `action on line ${line_nr}: ${error_message}`;
          return send(['.', 'warning', error_message, copy(meta)]);
        } else {
          /* TAINT join using empty string? spaces? newlines? */
          //.....................................................................................................
          if (macro_output.length > 0) {
            macro_output_rpr = macro_output.join('');
            macro_output.length = 0;
            send(['.', 'text', macro_output_rpr, copy(meta)]);
          }
          //...................................................................................................
          switch (mode) {
            case 'silent':
              null;
              break;
            case 'vocal':
              break;
            default:
              action_value_rpr = CND.isa_text(action_value) ? action_value : rpr(action_value);
              send(['.', 'text', action_value_rpr, copy(meta)]);
          }
          // action_value_rpr = if CND.isa_text action_value then action_value else rpr action_value
          // send [ '~', 'update', action_value_rpr, ( copy meta ), ]
          /* TAINT use more specific change event ('change sandbox')? */
          // debug '34821', sandbox.COLUMNS
          changeset = MK.TS.DIFFPATCH.diff(sandbox_backup, sandbox);
          if (changeset.length > 0) {
            return send(['~', 'change', changeset, copy(meta)]);
          }
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$process_values = (S) => {
    var copy, get_sandbox, hide, stamp;
    copy = MKTS.MD_READER.copy.bind(MKTS.MD_READER);
    stamp = MKTS.MD_READER.stamp.bind(MKTS.MD_READER);
    hide = MKTS.MD_READER.hide.bind(MKTS.MD_READER);
    get_sandbox = this.track_changes();
    //.........................................................................................................
    return $((event, send) => {
      /* TAINT should preserve stack trace of error */
      /* TAINT use method to assemble warning event */
      /* TAINT write error log with full trace, insert reference (error nr) */
      var _, action_value, action_value_rpr, error_message, i, identifier, len, line_nr, meta, ref, sandbox, sub_identifier;
      if (MKTS.MD_READER.select(event, '@')) {
        [_, identifier, _, meta] = event;
        sandbox = get_sandbox();
        action_value = sandbox;
        ref = identifier.split('.');
        for (i = 0, len = ref.length; i < len; i++) {
          sub_identifier = ref[i];
          action_value = action_value[sub_identifier];
          if (action_value === void 0) {
            ({line_nr} = meta);
            error_message = `value on line ${line_nr}: unknown identifier ${rpr(identifier)}`;
            return send(['.', 'warning', error_message, copy(meta)]);
          }
        }
        if (!CND.isa_text(action_value)) {
          action_value_rpr = rpr(action_value);
        }
        return send(['.', 'text', action_value_rpr, copy(meta)]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$process_commands = (S) => {
    var copy, hide, stamp;
    copy = MKTS.MD_READER.copy.bind(MKTS.MD_READER);
    stamp = MKTS.MD_READER.stamp.bind(MKTS.MD_READER);
    hide = MKTS.MD_READER.hide.bind(MKTS.MD_READER);
    //.........................................................................................................
    // throw new Error "internal error: need S.SANDBOX, must use `$prepare_sandbox`" unless S.SANDBOX?
    //.........................................................................................................
    return $((event, send) => {
      var _, call_signature, error_message, identifier, language, line_nr, meta, mode, parameters, parameters_txt;
      if (MKTS.MD_READER.select(event, '!')) {
        [_, call_signature, _, meta] = event;
        [_, identifier, parameters_txt] = call_signature.match(/^\s*([^\s]*)\s*(.*)$/);
        ({mode, language, line_nr} = meta);
        [error_message, parameters] = this._parameters_from_text(S, line_nr, parameters_txt);
        if (error_message != null) {
          return send(['.', 'warning', error_message, meta]);
        }
        return send(['!', identifier, parameters, meta]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$process_regions = (S) => {
    var copy, hide, select, stamp;
    copy = MKTS.MD_READER.copy.bind(MKTS.MD_READER);
    stamp = MKTS.MD_READER.stamp.bind(MKTS.MD_READER);
    hide = MKTS.MD_READER.hide.bind(MKTS.MD_READER);
    select = MKTS.MD_READER.select.bind(MKTS.MD_READER);
    //.........................................................................................................
    // throw new Error "internal error: need S.SANDBOX, must use `$prepare_sandbox`" unless S.SANDBOX?
    //.........................................................................................................
    return $((event, send) => {
      var _, call_signature, error_message, extra, identifier, language, line_nr, meta, mode, parameters, parameters_txt;
      /* TAINT code duplication */
      if (select(event, '(')) {
        [_, call_signature, extra, meta] = event;
        [_, identifier, parameters_txt] = call_signature.match(/^\s*([^\s]*)\s*(.*)$/);
        //.....................................................................................................
        /* Refuse to overwrite 3rd event parameter when already set. This is a makeshift solution that will
        be removed when we implement a simplified and more unified event syntax. */
        if (extra != null) {
          if (parameters_txt.length > 0) {
            warn("encountered start region event with parameters and extra");
          }
          return send(event);
        }
        //.....................................................................................................
        ({mode, language, line_nr} = meta);
        [error_message, parameters] = this._parameters_from_text(S, line_nr, parameters_txt);
        if (error_message != null) {
          //.....................................................................................................
          send(['.', 'warning', error_message, meta]);
        }
        return send(['(', identifier, parameters, meta]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$consolidate_regions = (S) => {
    var copy, hide, select, stamp, tag_stack;
    copy = MKTS.MD_READER.copy.bind(MKTS.MD_READER);
    stamp = MKTS.MD_READER.stamp.bind(MKTS.MD_READER);
    hide = MKTS.MD_READER.hide.bind(MKTS.MD_READER);
    select = MKTS.MD_READER.select.bind(MKTS.MD_READER);
    tag_stack = [];
    //.........................................................................................................
    // throw new Error "internal error: need S.SANDBOX, must use `$prepare_sandbox`" unless S.SANDBOX?
    //.........................................................................................................
    return $((event, send) => {
      var _, call_signature, error_message, expected, extra, identifier, line_nr, message, meta, parameters, parameters_txt;
      /* TAINT code duplication */
      if (select(event, '(')) {
        [_, call_signature, extra, meta] = event;
        [_, identifier, parameters_txt] = call_signature.match(/^\s*([^\s]*)\s*(.*)$/);
        //.....................................................................................................
        /* Refuse to overwrite 3rd event parameter when already set. This is a makeshift solution that will
        be removed when we implement a simplified and more unified event syntax. */
        if (extra != null) {
          if (parameters_txt.length > 0) {
            warn("encountered start region event with parameters and extra");
          }
          tag_stack.push(identifier);
          return send(event); // and extra.length > 0
        }
        //.....................................................................................................
        ({line_nr} = meta);
        [error_message, parameters] = this._parameters_from_text(S, line_nr, parameters_txt);
        if (error_message != null) {
          //.....................................................................................................
          send(['.', 'warning', error_message, meta]);
        }
        send(['(', identifier, parameters, meta]);
        tag_stack.push(identifier);
      //.......................................................................................................
      } else if (select(event, ')')) {
        [_, identifier, extra, meta] = event;
        //.....................................................................................................
        if (tag_stack.length < 1) {
          return send(['.', 'warning', "too many closing regions", copy(meta)]);
        }
        //.....................................................................................................
        expected = tag_stack.pop();
        //.....................................................................................................
        if ((identifier.length > 0) && (expected !== identifier)) {
          message = `expected closing region ${rpr(expected)}, got ${rpr(identifier)}`;
          send(['.', 'warning', message, copy(meta)]);
          if (identifier === 'document') {
            send(event);
          }
        }
        //.....................................................................................................
        identifier = expected;
        send([')', identifier, extra, copy(meta)]);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$process_code_blocks = (S) => {
    var copy, hide, select, stamp;
    copy = MKTS.MD_READER.copy.bind(MKTS.MD_READER);
    stamp = MKTS.MD_READER.stamp.bind(MKTS.MD_READER);
    hide = MKTS.MD_READER.hide.bind(MKTS.MD_READER);
    select = MKTS.MD_READER.select.bind(MKTS.MD_READER);
    //.........................................................................................................
    // throw new Error "internal error: need S.SANDBOX, must use `$prepare_sandbox`" unless S.SANDBOX?
    //.........................................................................................................
    return $((event, send) => {
      var _, call_signature, error_message, identifier, line_nr, meta, parameters, parameters_txt, type;
      /* TAINT code duplication */
      // debug '0123', event
      if (select(event, ['(', ')'], 'code')) {
        // debug '4234', event
        [type, _, call_signature, meta] = event;
        ({line_nr} = meta);
        [_, identifier, parameters_txt] = call_signature.match(/^\s*([^\s]*)\s*(.*)$/);
        //.....................................................................................................
        [error_message, parameters] = this._parameters_from_text(S, line_nr, parameters_txt);
        parameters.unshift(identifier);
        if (error_message != null) {
          //.....................................................................................................
          send(['.', 'warning', error_message, meta]);
        }
        return send([type, 'code', parameters, meta]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._parameters_from_text = (S, line_nr, text) => {
    var CS, R, VM, error, error_message, js_source, ref, ref1, sandbox, source;
    if (/^\s*$/.test(text)) {
      return [null, []];
    }
    //.........................................................................................................
    /* TAINT replicates some code from MACRO_INTERPRETER.process_actions */
    /* TAINT move to CND? COFFEESCRIPT? */
    CS = require('coffeescript');
    VM = require('vm');
    source = `mkts.signature_reader ${text}`;
    error_message = null;
    //.........................................................................................................
    warn("using makeshift solution for sandbox in `_parameters_from_text`");
    sandbox = {
      mkts: {
        signature_reader: function(...P) {
          return P;
        }
      }
    };
    VM.createContext(sandbox);
    try {
      //.....................................................................................................
      js_source = CS.compile(source, {
        bare: true,
        filename: 'parameter resolution'
      });
    } catch (error1) {
      error = error1;
      error_message = (ref = error['message']) != null ? ref : rpr(error);
    }
    //.....................................................................................................
    if (error_message == null) {
      try {
        R = VM.runInContext(js_source, sandbox, {
          filename: 'parameter resolution'
        });
      } catch (error1) {
        error = error1;
        error_message = (ref1 = error['message']) != null ? ref1 : rpr(error);
      }
    }
    //.....................................................................................................
    if (error_message != null) {
      warn(error_message);
      return [/* TAINT should preserve stack trace of error */ /* TAINT use method to assemble warning event */ /* TAINT write error log with full trace, insert reference (error nr) */ `action on line ${line_nr}: ${error_message}`, null];
    }
    // return done [ '.', 'warning', error_message, ( copy meta ), ]
    return [null, R];
  };

  // #-----------------------------------------------------------------------------------------------------------
// @MKTX.COMMAND.$expansion = ( S ) =>
//   remark = MD_READER._get_remark()
//   #.........................................................................................................
//   return $ ( event, send ) =>
//     if MKTS.MD_READER.select event, '!'
//       [ type, identifier, _, meta, ] = event
//       if ( definition = S.local.definitions.get identifier )?
//         # send stamp hide event
//         send stamp hide [ '(', '!', identifier, ( copy meta ), ]
//         # send copy sub_event for sub_event in definition
//         # debug '@16', rpr definition
//         send remark 'resend', "expanding `#{identifier}`", ( copy meta )
//         S.resend definition # [ '.', 'text', definition, ( copy meta ), ]
//         send stamp hide [ ')', '!', identifier, ( copy meta ), ]
//       else
//         send event
//     #.......................................................................................................
//     else
//       send event

}).call(this);

//# sourceMappingURL=macro-interpreter.js.map
