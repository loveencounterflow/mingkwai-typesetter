(function() {
  var $, $async, ASYNC, CACHE, CND, D, HELPERS, MACRO_ESCAPER, MD_READER, MKTS, MKTSCRIPT_WRITER, OPTIONS, SEMVER, TEXLIVEPACKAGEINFO, XNCHR, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, njs_fs, njs_path, options_route, ref, rpr, select, stamp, step, suspend, urge, warn, whisper, ƒ,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'mkts/tex-writer';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  ASYNC = require('async');

  ƒ = CND.format_number.bind(CND);

  HELPERS = require('./helpers');

  TEXLIVEPACKAGEINFO = require('./texlivepackageinfo');

  options_route = '../options.coffee';

  ref = require('./options'), CACHE = ref.CACHE, OPTIONS = ref.OPTIONS;

  SEMVER = require('semver');

  XNCHR = require('./xnchr');

  MKTS = require('./main');

  MKTSCRIPT_WRITER = require('./mktscript-writer');

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  MACRO_ESCAPER = require('./macro-escaper');

  this.compile_options = function() {

    /* TAINT this method should go to OPTIONS */
    var cache_locator, cache_route, has_double_slash, has_single_slash, i, len, locator, locators, options_home, options_locator, ref1, route, texinputs_routes;
    options_locator = require.resolve(njs_path.resolve(__dirname, options_route));
    options_home = njs_path.dirname(options_locator);
    this.options = OPTIONS.from_locator(options_locator);
    this.options['home'] = options_home;
    this.options['locator'] = options_locator;
    cache_route = this.options['cache']['route'];
    this.options['cache']['locator'] = cache_locator = njs_path.resolve(options_home, cache_route);
    this.options['xelatex-command'] = njs_path.resolve(options_home, this.options['xelatex-command']);
    if (!njs_fs.existsSync(cache_locator)) {
      this.options['cache']['%self'] = {};
      CACHE.save(this.options);
    }
    this.options['cache']['%self'] = require(cache_locator);
    if ((texinputs_routes = (ref1 = this.options['texinputs']) != null ? ref1['routes'] : void 0) != null) {
      locators = [];
      for (i = 0, len = texinputs_routes.length; i < len; i++) {
        route = texinputs_routes[i];
        has_single_slash = /\/$/.test(route);
        has_double_slash = /\/\/$/.test(route);
        locator = njs_path.resolve(options_home, route);
        if (has_double_slash) {
          locator += '//';
        } else if (has_single_slash) {
          locator += '/';
        }
        locators.push(locator);
      }

      /* TAINT duplication: tex_inputs_home, texinputs_value */

      /* TAINT path separator depends on OS */
      this.options['texinputs']['value'] = locators.join(':');
    }
    return CACHE.update(this.options);
  };

  this.compile_options();

  this.write_mkts_master = function(layout_info, handler) {
    return step((function(_this) {
      return function*(resume) {
        var content_locator, defs, filename, fonts_home, fontspec_version, home, i, len, lines, main_font_name, master_locator, name, newcommands, ref1, ref2, styles, texname, text, use_new_syntax, value, write;
        lines = [];
        write = lines.push.bind(lines);
        master_locator = layout_info['master-locator'];
        content_locator = layout_info['content-locator'];
        help("writing " + master_locator);
        write("");
        write("% " + master_locator);
        write("% do not edit this file");
        write("% generated from " + _this.options['locator']);
        write("% on " + (new Date()));
        write("");
        write("\\documentclass[a4paper,twoside]{book}");
        write("");
        defs = _this.options['defs'];
        write("");
        write("% DEFS");
        if (defs != null) {
          for (name in defs) {
            value = defs[name];
            write("\\def\\" + name + "{" + value + "}");
          }
        }
        newcommands = _this.options['newcommands'];
        write("");
        write("% NEWCOMMANDS");
        if (newcommands != null) {
          for (name in newcommands) {
            value = newcommands[name];
            warn("implicitly converting newcommand value for " + name);
            value = njs_path.resolve(__dirname, '..', value);
            write("\\newcommand{\\" + name + "}{%\n" + value + "%\n}");
          }
        }
        write("");
        write("% PACKAGES");
        write("\\usepackage{mkts2015-consolidated}");
        fontspec_version = (yield TEXLIVEPACKAGEINFO.read_texlive_package_version(_this.options, 'fontspec', resume));
        use_new_syntax = SEMVER.satisfies(fontspec_version, '>=2.4.0');
        fonts_home = _this.options['fonts']['home'];
        write("");
        write("% FONTS");
        write("% assuming fontspec@" + fontspec_version);
        write("\\usepackage{fontspec}");
        ref1 = _this.options['fonts']['files'];
        for (i = 0, len = ref1.length; i < len; i++) {
          ref2 = ref1[i], texname = ref2.texname, home = ref2.home, filename = ref2.filename;
          if (home == null) {
            home = fonts_home;
          }
          if (use_new_syntax) {

            /* TAINT should properly escape values */
            write("\\newfontface{\\" + texname + "}{" + filename + "}[Path=" + home + "/]");
          } else {
            write("\\newfontface\\" + texname + "[Path=" + home + "/]{" + filename + "}");
          }
        }
        write("");
        write("");
        write("% STYLES");
        if ((styles = _this.options['styles']) != null) {
          for (name in styles) {
            value = styles[name];
            write("\\newcommand{\\" + name + "}{%\n" + value + "%\n}");
          }
        }
        main_font_name = _this.options['fonts']['main'];
        if (main_font_name == null) {
          throw new Error("need entry options/fonts/name");
        }
        write("");
        write("% CONTENT");
        write("\\begin{document}" + main_font_name);
        write("");
        write("\\input{" + content_locator + "}");
        write("");
        write("\\end{document}");
        text = lines.join('\n');
        return njs_fs.writeFile(master_locator, text, handler);
      };
    })(this));
  };

  this.MKTX = {
    TEX: {},
    DOCUMENT: {},
    COMMAND: {},
    REGION: {},
    BLOCK: {},
    INLINE: {},
    MIXED: {},
    CLEANUP: {}
  };

  this.MKTX.TEX._tex_escape_replacements = [[/\x01/g, '\x01\x02'], [/\x5c/g, '\x01\x01'], [/\{/g, '\\{'], [/\}/g, '\\}'], [/\$/g, '\\$'], [/\#/g, '\\#'], [/%/g, '\\%'], [/_/g, '\\_'], [/\^/g, '\\textasciicircum{}'], [/~/g, '\\textasciitilde{}'], [/&/g, '\\&'], [/\x01\x01/g, '\\textbackslash{}'], [/\x01\x02/g, '\x01']];

  this.MKTX.TEX.escape_for_tex = (function(_this) {
    return function(text) {
      var R, i, idx, len, pattern, ref1, ref2, replacement;
      R = text;
      ref1 = _this.MKTX.TEX._tex_escape_replacements;
      for (idx = i = 0, len = ref1.length; i < len; idx = ++i) {
        ref2 = ref1[idx], pattern = ref2[0], replacement = ref2[1];
        R = R.replace(pattern, replacement);
      }
      return R;
    };
  })(this);

  this.MKTX.TEX.$fix_typography_for_tex = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, text, type;
        if (select(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          meta['raw'] = text;
          text = _this.MKTX.TEX.fix_typography_for_tex(text, S.options);
          return send([type, name, text, meta]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.TEX.is_cjk_rsg = (function(_this) {
    return function(rsg, options) {
      return indexOf.call(options['tex']['cjk-rsgs'], rsg) >= 0;
    };
  })(this);

  this.MKTX.TEX._get_cjk_interchr_glue = (function(_this) {
    return function(options) {
      var ref1, ref2;
      return (ref1 = (ref2 = options['tex']) != null ? ref2['cjk-interchr-glue'] : void 0) != null ? ref1 : '\ue080';
    };
  })(this);

  this.MKTX.TEX.fix_typography_for_tex = (function(_this) {
    return function(text, options, send) {
      var R, advance, advance_each_chr, chr, chunk, cjk_interchr_glue, command, fncr, glyph_styles, i, is_latin_whitespace, last_command, last_rsg, last_was_cjk, len, message, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, remark, replacement, rsg, tex_command_by_rsgs, this_is_cjk, uchr;
      if (send == null) {
        send = null;
      }

      /* An improved version of `XELATEX.tag_from_chr` */

      /* TAINT should accept settings, fall back to `require`d `options.coffee` */
      glyph_styles = (ref1 = (ref2 = options['tex']) != null ? ref2['glyph-styles'] : void 0) != null ? ref1 : {};

      /* Legacy mode: force one command per non-latin character. This is OK for Chinese texts,
      but a bad idea for all other scripts; in the future, MKTS's TeX formatting commands like
      `\cn{}` will be rewritten to make this setting superfluous.
       */
      advance_each_chr = (ref3 = (ref4 = options['tex']) != null ? ref4['advance-each-chr'] : void 0) != null ? ref3 : false;
      tex_command_by_rsgs = (ref5 = options['tex']) != null ? ref5['tex-command-by-rsgs'] : void 0;
      cjk_interchr_glue = _this.MKTX.TEX._get_cjk_interchr_glue(options);
      last_command = null;
      R = [];
      chunk = [];
      last_rsg = null;
      remark = send != null ? _this._get_remark() : null;
      this_is_cjk = false;
      last_was_cjk = false;
      is_latin_whitespace = null;
      if (tex_command_by_rsgs == null) {
        throw new Error("need setting 'tex-command-by-rsgs'");
      }
      advance = function() {
        if (chunk.length > 0) {
          R.push(chunk.join(''));
          if (last_command !== null && last_command !== 'latin') {
            R.push("}");
          }
        }
        chunk.length = 0;
        return null;
      };
      ref6 = XNCHR.chrs_from_text(text);
      for (i = 0, len = ref6.length; i < len; i++) {
        chr = ref6[i];

        /* Treat whitespace specially */

        /* TAINT better to check against /^\s$/ ??? */
        if (false) {
          command = last_command;
        } else {
          ref7 = XNCHR.analyze(chr), chr = ref7.chr, uchr = ref7.uchr, fncr = ref7.fncr, rsg = ref7.rsg;
          switch (rsg) {
            case 'jzr-fig':
              chr = uchr;
              break;
            case 'u-pua':
              rsg = 'jzr-fig';
              break;
            case 'u-latn':
              chr = _this.MKTX.TEX.escape_for_tex(chr);
          }
          this_is_cjk = _this.MKTX.TEX.is_cjk_rsg(rsg, options);
          if (last_was_cjk && this_is_cjk) {

            /* Avoid to put second glue between glue and CJK character: */
            if (chr !== cjk_interchr_glue) {
              chunk.push(cjk_interchr_glue);
            }
          }
          last_was_cjk = this_is_cjk;

          /* TAINT if chr is a TeX active ASCII chr like `$`, `#`, then it will be escaped at this point
          and no more match entries in `glyph_styles`
           */
          if ((replacement = glyph_styles[chr]) != null) {
            advance();
            R.push(replacement);
            last_command = null;
            continue;
          }
          if ((command = tex_command_by_rsgs[rsg]) == null) {
            command = (ref8 = tex_command_by_rsgs['fallback']) != null ? ref8 : null;
            message = "unknown RSG " + (rpr(rsg)) + ": " + fncr + " " + chr + " (using fallback " + (rpr(command)) + ")";
            if (send != null) {
              send(remark('warn', message, {}));
            } else {
              warn(message);
            }
          }
        }
        if (command == null) {
          advance();
          chunk.push(chr);
          continue;
        }
        if (advance_each_chr || last_command !== command) {
          advance();
          last_command = command;

          /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
          if (command !== 'latin') {
            command = 'cn';
            chunk.push("{\\" + command + "{}");
          }

          /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
        }
        chunk.push(chr);
      }
      advance();
      return R.join('');
    };
  })(this);

  this.MKTX.COMMAND.$new_page = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        if (!select(event, '!', 'new-page')) {
          return send(event);
        }
        send(stamp(event));
        return send(['tex', "\\null\\newpage{}"]);
      });
    };
  })(this);

  this.MKTX.COMMAND.$comment = (function(_this) {
    return function(S) {
      var remark;
      remark = MD_READER._get_remark();
      return $(function(event, send) {
        var meta, name, text, type;
        if (!select(event, '.', 'comment')) {
          return send(event);
        }
        type = event[0], name = event[1], text = event[2], meta = event[3];
        return send(remark('drop', "`.comment`: " + (rpr(text)), copy(meta)));
      });
    };
  })(this);

  this.MKTX.DOCUMENT.$begin = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        if (select(event, '(', 'document')) {
          send(stamp(event));
          return send(['tex', "\n% begin of MD document\n"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.DOCUMENT.$end = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        if (select(event, ')', 'document')) {
          send(stamp(event));
          return send(['tex', "\n% end of MD document\n"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.REGION._begin_multi_column = (function(_this) {
    return function() {

      /* TAINT Column count must come from layout / options / MKTS-MD command */
      return ['tex', '\\begin{multicols}{2}'];
    };
  })(this);

  this.MKTX.REGION._end_multi_column = (function(_this) {
    return function() {
      return ['tex', '\\end{multicols}'];
    };
  })(this);

  this.MKTX.COMMAND.$multi_column = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, text, type;
        if (select(event, '!', 'multi-column')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          send(stamp(hide(['(', '!', name, copy(meta)])));
          send(['(', 'multi-column', text, copy(meta)]);
          send(stamp(hide([')', '!', name, copy(meta)])));
        } else {
          send(event);
        }
        return null;
      });
    };
  })(this);

  this.MKTX.REGION.$multi_column = (function(_this) {
    return function(S) {
      var remark, track;
      track = MD_READER.TRACKER.new_tracker('(multi-column)');
      remark = MD_READER._get_remark();
      return $(function(event, send) {
        var meta, name, text, type, within_multi_column;
        within_multi_column = track.within('(multi-column)');
        track(event);
        if (select(event, ['(', ')'], 'multi-column')) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            if (within_multi_column) {
              send(remark('drop', "`(multi-column` because already within `(multi-column)`", copy(meta)));
            } else {
              send(track(_this.MKTX.REGION._begin_multi_column()));
            }
          } else {
            if (within_multi_column) {
              send(track(_this.MKTX.REGION._end_multi_column()));
            } else {
              send(remark('drop', "`multi-column)` because not within `(multi-column)`", copy(meta)));
            }
          }
        } else {
          send(event);
        }
        return null;
      });
    };
  })(this);

  this.MKTX.REGION.$single_column = (function(_this) {
    return function(S) {

      /* TAINT consider to implement command `change_column_count = ( send, n )` */
      var remark, track;
      track = MD_READER.TRACKER.new_tracker('(multi-column)');
      remark = MD_READER._get_remark();
      return $(function(event, send) {
        var meta, name, text, type, within_multi_column;
        within_multi_column = track.within('(multi-column)');
        track(event);
        if (select(event, ['(', ')'], 'single-column')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            if (within_multi_column) {
              send(remark('insert', "`multi-column}`", copy(meta)));
              send(track(_this.MKTX.REGION._end_multi_column()));
              send(stamp(event));
            } else {
              send(remark('drop', "`single-column` because not within `(multi-column)`", copy(meta)));
            }
          } else {
            if (within_multi_column) {
              send(stamp(event));
              send(remark('insert', "`{multi-column`", copy(meta)));
              send(track(_this.MKTX.REGION._begin_multi_column()));
            } else {
              send(remark('drop', "`single-column` because not within `(multi-column)`", copy(meta)));
            }
          }
        } else {
          send(event);
        }
        return null;
      });
    };
  })(this);

  this.MKTX.REGION.$keep_lines = (function(_this) {
    return function(S) {
      var track;
      track = MD_READER.TRACKER.new_tracker('(keep-lines)');
      return $(function(event, send) {
        var meta, name, text, type, within_keep_lines;
        within_keep_lines = track.within('(keep-lines)');
        track(event);
        if (select(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];

          /* TAINT other replacements possible; use API */

          /* TAINT U+00A0 (nbsp) might be too wide */
          if (within_keep_lines) {
            text = text.replace(/\u0020/g, '\u00a0');
          }
          return send([type, name, text, meta]);
        } else if (select(event, ['(', ')'], 'keep-lines')) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            track.enter('(keep-lines)');
            return send(['tex', "\\begingroup\\mktsObeyAllLines{}"]);
          } else {
            send(['tex', "\\endgroup{}"]);
            return track.leave('(keep-lines)');
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.REGION.$code = (function(_this) {
    return function(S) {

      /* TAINT code duplication with `REGION.$keep_lines` possible */
      var track;
      track = MD_READER.TRACKER.new_tracker('(code)');
      return $(function(event, send) {
        var meta, name, text, type, within_code;
        within_code = track.within('(code)');
        track(event);
        if (select(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (within_code) {
            text = text.replace(/\u0020/g, '\u00a0');
          }
          return send([type, name, text, meta]);
        } else if (select(event, ['(', ')'], 'code')) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            return send(['tex', "\\begingroup\\mktsObeyAllLines\\mktsStyleCode{}"]);
          } else {
            return send(['tex', "\\endgroup{}"]);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK.$heading = (function(_this) {
    return function(S) {
      var restart_multicols, track;
      restart_multicols = false;
      track = MD_READER.TRACKER.new_tracker('(multi-column)');
      return $(function(event, send) {
        var meta, name, text, type, within_multi_column;
        within_multi_column = track.within('(multi-column)');
        track(event);
        if (select(event, ['(', ')'], ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'])) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            if (within_multi_column && (name === 'h1' || name === 'h2')) {
              send(track(_this.MKTX.REGION._end_multi_column(meta)));
              restart_multicols = true;
            }
            send(['tex', "\n"]);
            switch (name) {
              case 'h1':
                return send(['tex', "\\chapter{"]);
              case 'h2':
                return send(['tex', "\\section{"]);
              default:
                return send(['tex', "\\subsection{"]);
            }
          } else {

            /* Placing the closing brace on a new line seems to improve line breaking */
            send(['tex', "\n"]);
            send(['tex', "}"]);
            send(['tex', "\n"]);
            if (restart_multicols) {
              send(track(_this.MKTX.REGION._begin_multi_column(meta)));
              return restart_multicols = false;
            }
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK.$paragraph = (function(_this) {
    return function(S) {

      /* TAINT should unify the two observers */
      var track;
      track = MD_READER.TRACKER.new_tracker('(code)', '(keep-lines)');
      return $(function(event, send) {
        var meta, name, text, type, within_code, within_keep_lines;
        within_code = track.within('(code)');
        within_keep_lines = track.within('(keep-lines)');
        track(event);
        if (select(event, '.', 'p')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (within_code || within_keep_lines) {
            send(stamp(event));
            return send(['tex', '\n\n']);
          } else {
            send(stamp(event));
            return send(_this.MKTX.BLOCK._end_paragraph());
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK._end_paragraph = (function(_this) {
    return function() {

      /* TAINT use command from sty */

      /* TAINT make configurable */
      return ['tex', '\\mktsShowpar\\par\n'];
    };
  })(this);

  this.MKTX.BLOCK.$unordered_list = (function(_this) {
    return function(S) {
      var item_markup_tex, tex_by_md_markup;
      tex_by_md_markup = {
        '*': '$\\star$',
        'fallback': '—'
      };
      item_markup_tex = null;
      return $(function(event, send) {
        var markup, meta, name, ref1, text, type;
        if (select(event, '(', 'ul')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          markup = meta.markup;

          /* TAINT won't work in nested lists */

          /* TAINT make configurable */
          item_markup_tex = (ref1 = tex_by_md_markup[markup]) != null ? ref1 : tex_by_md_markup['fallback'];
          send(stamp(event));
          return send(['tex', '\\begin{itemize}']);
        } else if (select(event, '(', 'li')) {
          send(stamp(event));
          return send(['tex', "\\item[" + item_markup_tex + "] "]);
        } else if (select(event, ')', 'li')) {
          send(stamp(event));
          return send(['tex', '\n']);
        } else if (select(event, ')', 'ul')) {
          send(stamp(event));
          return send(['tex', '\\end{itemize}']);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.BLOCK.$hr = (function(_this) {
    return function(S) {
      var remark;
      remark = MD_READER._get_remark();
      return $(function(event, send) {
        var chr, meta, name, text, type;
        if (select(event, '.', 'hr')) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          switch (chr = text[0]) {
            case '-':
              return send(['tex', '\n--------------\n']);
            case '*':
              return send(['tex', '\n**************\n']);
            default:
              return send(remark('drop', "`[hr] because markup unknown " + (rpr(text)), copy(meta)));
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$code_span = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, text, type;
        if (select(event, ['(', ')'], 'code-span')) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            return send(['tex', '{\\mktsStyleCode{}']);
          } else {
            return send(['tex', "}"]);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$image = (function(_this) {
    return function(S) {
      var alt, alt_cache, event_cache, src, track;
      track = MD_READER.TRACKER.new_tracker('(image)');
      event_cache = [];
      alt_cache = [];
      src = null;
      alt = null;
      return $(function(event, send) {
        var cached_event, i, len, meta, name, text, type, within_image;
        within_image = track.within('(image)');
        track(event);
        type = event[0], name = event[1], text = event[2], meta = event[3];
        if (select(event, '(', 'image')) {
          send(stamp(event));
          return src = njs_path.resolve(S.layout_info['source-home'], meta['src']);
        } else if (select(event, ')', 'image')) {
          alt = alt_cache.join('');
          send(['tex', '\\begin{figure}%\n']);

          /* TAINT escape `src`? */
          send(['tex', "\\includegraphics[width=0.5\\textwidth]{" + src + "}%\n"]);
          send(['tex', "\\caption[" + alt + "]{%\n"]);
          for (i = 0, len = event_cache.length; i < len; i++) {
            cached_event = event_cache[i];
            send(cached_event);
          }
          send(['tex', '}%\n']);
          send(['tex', '\\end{figure}%\n']);
          src = null;
          return alt_cache.length = 0;
        } else if (within_image) {
          event_cache.push(event);
          if (select(event, '.', 'text')) {
            return alt_cache.push(text);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.MIXED.$raw = (function(_this) {
    return function(S) {
      var remark;
      remark = MD_READER._get_remark();
      return $(function(event, send) {
        var meta, name, text, type;
        if (select(event, '.', 'raw')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          send(stamp(hide(event)));
          send(remark('convert', "raw to TeX", copy(meta)));
          text = MACRO_ESCAPER.escape.unescape_escape_chrs(S, text);
          return send(['tex', text]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.MIXED.$footnote = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var id, meta, name, type;
        if (select(event, '(', 'footnote')) {
          send(stamp(event));
          type = event[0], name = event[1], id = event[2], meta = event[3];
          return send(['tex', "\\footnote{"]);
        } else if (select(event, ')', 'footnote')) {
          send(stamp(event));
          return send(['tex', "}"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.MIXED.$remove_footnote_extra_paragraphs = (function(_this) {
    return function(S) {
      var last_event;
      last_event = null;
      return $(function(event, send, end) {
        if (event != null) {
          if (select(event, ')', 'footnote')) {
            if ((last_event != null) && !select(last_event, '.', 'p')) {
              send(last_event);
            }
            last_event = event;
          } else {
            if (last_event != null) {
              send(last_event);
            }
            last_event = event;
          }
        }
        if (end != null) {
          if (last_event != null) {
            send(last_event);
          }
          return end();
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$translate_i_and_b = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, new_name, text, type;
        if (select(event, ['(', ')'], ['i', 'b'])) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          new_name = name === 'i' ? 'em' : 'strong';
          return send([type, new_name, text, meta]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$em_and_strong = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var meta, name, text, type;
        if (select(event, ['(', ')'], ['em', 'strong'])) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (type === '(') {
            if (name === 'em') {
              return send(['tex', '{\\mktsStyleItalic{}']);

              /* TAINT must not be sent when in vertical mode */
            } else {
              return send(['tex', '{\\mktsStyleBold{}']);
            }
          } else {
            if (name === 'em') {
              send(['tex', '\\/']);
            }
            return send(['tex', "}"]);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.INLINE.$link = (function(_this) {
    return function(S) {

      /* TAINT make configurable how link is handled (clickable, footnote, inline...) */

      /* TAINT consider to re-send footnote event */
      return $(function(event, send) {
        var message, meta, name, text, type;
        if (select(event, '(', 'link')) {
          return null;
        } else if (select(event, ')', 'link')) {
          send(stamp(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          message = _this.MKTX.TEX.fix_typography_for_tex(text, S.options);
          return send(['tex', "\\footnote{" + message + "}"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.CLEANUP.$remove_empty_texts = function(S) {
    var remark;
    remark = MD_READER._get_remark();
    return $((function(_this) {
      return function(event, send) {
        var meta, name, text, type;
        if (select(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          if (text === '') {

            /* remain silent to make output an easier read */
            null;
            return send(remark('drop', "empty text", copy(meta)));
          } else {
            return send(event);
          }
        } else {
          return send(event);
        }
      };
    })(this));
  };

  this.MKTX.CLEANUP.$remove_empty_p_tags = (function(_this) {
    return function(S) {

      /* TAINT emptyness of  `p` tags ist tested for by counting intermittend `text` events; however, a
      paragraph could conceivably also consist of e.g. a single image.
       */
      var remark, text_count;
      text_count = 0;
      remark = MD_READER._get_remark();
      return $(function(event, send) {
        var _, meta;
        if (select(event, [')'])) {
          text_count = 0;
          return send(event);
        } else if (select(event, '.', 'text')) {
          text_count += +1;
          return send(event);
        } else if (select(event, '.', 'p')) {
          if (text_count > 0) {
            send(event);
          } else {
            _ = event[0], _ = event[1], _ = event[2], meta = event[3];
            send(remark('drop', "empty `.p`", copy(meta)));
          }
          return text_count = 0;
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.REGION.$correct_p_tags_before_regions = (function(_this) {
    return function(S) {
      var last_was_begin_document, last_was_p, remark;
      last_was_p = false;
      last_was_begin_document = false;
      remark = MD_READER._get_remark();
      return $(function(event, send) {
        var meta;
        if (select(event, 'tex')) {
          return send(event);
        } else if (select(event, '(', 'document')) {
          last_was_p = false;
          last_was_begin_document = true;
          return send(event);
        } else if (select(event, '.', 'p')) {
          last_was_p = true;
          last_was_begin_document = false;
          return send(event);
        } else if (select(event, ['('])) {
          if ((!last_was_begin_document) && (!last_was_p)) {
            meta = event[event.length - 1];
            send(remark('insert', "`.p` because region or block opens", copy(meta)));
            send(['.', 'p', null, copy(meta)]);
          }
          send(event);
          last_was_p = false;
          return last_was_begin_document = false;
        } else {
          last_was_p = false;
          last_was_begin_document = false;
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.$show_unhandled_tags = (function(_this) {
    return function(S) {
      return $(function(event, send) {

        /* TAINT selection could be simpler, less repetitive */
        var event_txt, meta, name, ref1, text, type;
        if (((ref1 = event[0]) === 'tex' || ref1 === 'text') || select(event, '.', ['text', 'raw'])) {
          return send(event);
        } else if (!is_stamped(event)) {
          debug('©04210', JSON.stringify(event));
          type = event[0], name = event[1], text = event[2], meta = event[3];
          event_txt = "unhandled event: " + (JSON.stringify(event, null, ' '));
          warn(event_txt);
          return send(['.', 'warning', event_txt, copy(meta)]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.MKTX.$show_warnings = (function(_this) {
    return function(S) {
      return $(function(event, send) {

        /* TAINT this makes clear why we should not use '.' as type here; `warning` is a meta-event, not
        primarily a formatting instruction
         */
        var message, meta, name, text, type;
        if (select(event, '.', 'warning')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          message = _this.MKTX.TEX.fix_typography_for_tex(text, S.options);

          /* TAINT use location data */
          return send(['tex', "\\begin{mktsEnvWarning}" + message + "\\end{mktsEnvWarning}"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$filter_tex = function(S) {

    /* TAINT reduce number of event types, shapes to simplify this */
    return $((function(_this) {
      return function(event, send) {
        if (select(event, 'tex')) {
          return send(event[1]);
        } else if (select(event, '.', ['text', 'raw'])) {
          return send(event[2]);
        } else if (!is_stamped(event)) {
          warn("unhandled event: " + (JSON.stringify(event)));
          return send.error(new Error("unhandled events not allowed at this point; got " + (JSON.stringify(event))));
        }
      };
    })(this));
  };

  this.create_tex_write_tee = function(S) {

    /* TAINT get state via return value of MKTS.create_mdreadstream */

    /* TAINT make execution of `$produce_mktscript` a matter of settings */
    var readstream, settings, writestream;
    readstream = D.create_throughstream();
    writestream = D.create_throughstream();
    readstream.pipe(MACRO_ESCAPER.$expand.$remove_backslashes(S)).pipe(this.MKTX.TEX.$fix_typography_for_tex(S)).pipe(this.MKTX.DOCUMENT.$begin(S)).pipe(this.MKTX.DOCUMENT.$end(S)).pipe(this.MKTX.MIXED.$raw(S)).pipe(this.MKTX.MIXED.$footnote(S)).pipe(this.MKTX.MIXED.$remove_footnote_extra_paragraphs(S)).pipe(this.MKTX.COMMAND.$new_page(S)).pipe(this.MKTX.COMMAND.$comment(S)).pipe(this.MKTX.COMMAND.$multi_column(S)).pipe(this.MKTX.REGION.$multi_column(S)).pipe(this.MKTX.REGION.$single_column(S)).pipe(this.MKTX.REGION.$keep_lines(S)).pipe(this.MKTX.REGION.$code(S)).pipe(this.MKTX.BLOCK.$heading(S)).pipe(this.MKTX.BLOCK.$hr(S)).pipe(this.MKTX.BLOCK.$unordered_list(S)).pipe(this.MKTX.INLINE.$code_span(S)).pipe(this.MKTX.INLINE.$link(S)).pipe(this.MKTX.INLINE.$translate_i_and_b(S)).pipe(this.MKTX.INLINE.$em_and_strong(S)).pipe(this.MKTX.INLINE.$image(S)).pipe(this.MKTX.CLEANUP.$remove_empty_p_tags(S)).pipe(this.MKTX.BLOCK.$paragraph(S)).pipe(this.MKTX.CLEANUP.$remove_empty_texts(S)).pipe(MKTSCRIPT_WRITER.$show_mktsmd_events(S)).pipe(this.MKTX.$show_unhandled_tags(S)).pipe(this.MKTX.$show_warnings(S)).pipe(this.$filter_tex(S)).pipe(MD_READER.$show_illegal_chrs(S)).pipe(writestream);
    settings = {
      S: S
    };
    return D.TEE.from_readwritestreams(readstream, writestream, settings);
  };

  this._handle_error = (function(_this) {
    return function(error) {
      var ref1, stack;
      alert(error['message']);
      stack = (ref1 = error['stack']) != null ? ref1 : "(no stacktrace available)";
      whisper('\n' + (stack.split('\n')).slice(0, 11).join('\n'));
      whisper('...');
      return process.exit(1);
    };
  })(this);

  this.pdf_from_md = function(source_route, handler) {

    /* TAINT code duplication */

    /* TAIN only works with docs in the filesystem, not with literal texts */
    var f;
    f = (function(_this) {
      return function() {
        return step(function*(resume) {
          var S, content_locator, file_output, layout_info, md_input, md_output, md_readstream, md_source, mkscript_locator, mkscript_output, source_locator, tex_input, tex_output, tex_writestream;
          if (handler == null) {
            handler = function() {};
          }
          layout_info = HELPERS.new_layout_info(_this.options, source_route);
          (yield _this.write_mkts_master(layout_info, resume));
          source_locator = layout_info['source-locator'];
          content_locator = layout_info['content-locator'];
          file_output = njs_fs.createWriteStream(content_locator);
          mkscript_locator = layout_info['mkscript-locator'];
          mkscript_output = njs_fs.createWriteStream(mkscript_locator);
          file_output.on('close', function() {
            return HELPERS.write_pdf(layout_info, function(error) {
              if (error != null) {
                throw error;
              }
              if (handler != null) {
                return handler(null);
              }
            });
          });
          S = {
            options: _this.options,
            layout_info: layout_info
          };

          /* TAINT should read MD source stream */
          md_source = njs_fs.readFileSync(source_locator, {
            encoding: 'utf-8'
          });
          md_readstream = MD_READER.create_md_read_tee(md_source);
          tex_writestream = _this.create_tex_write_tee(S);
          md_input = md_readstream.tee['input'];
          md_output = md_readstream.tee['output'];
          tex_input = tex_writestream.tee['input'];
          tex_output = tex_writestream.tee['output'];
          S.resend = md_readstream.tee['S'].resend;
          md_output.pipe(tex_input);
          tex_output.pipe(file_output);
          return md_input.resume();
        });
      };
    })(this);
    return D.run(f, this._handle_error);
  };

  this.tex_from_md = function(md_source, settings, handler) {

    /* TAINT code duplication */
    var $collect_and_call, S, arity, layout_info, md_input, md_output, md_readstream, ref1, source_route, tex_input, tex_output, tex_writestream;
    switch (arity = arguments.length) {
      case 2:
        handler = settings;
        settings = {};
        break;
      case 3:
        null;
        break;
      default:
        throw new Error("expected 2 or 3 arguments, got " + arity);
    }
    $collect_and_call = (function(_this) {
      return function(handler) {
        var Z;
        Z = [];
        return $(function(event, send, end) {
          if (event != null) {
            Z.push(event);
          }
          if (end != null) {
            handler(null, Z.join(''));
            return end();
          }
        });
      };
    })(this);
    source_route = (ref1 = settings['source-route']) != null ? ref1 : '<STRING>';
    layout_info = HELPERS.new_layout_info(this.options, source_route, false);
    S = {
      options: this.options,
      layout_info: layout_info
    };
    md_readstream = MD_READER.create_md_read_tee(md_source);
    tex_writestream = this.create_tex_write_tee(S);
    md_input = md_readstream.tee['input'];
    md_output = md_readstream.tee['output'];
    tex_input = tex_writestream.tee['input'];
    tex_output = tex_writestream.tee['output'];
    S.resend = md_readstream.tee['S'].resend;
    md_output.pipe(tex_input);
    tex_output.pipe($collect_and_call(handler));
    D.run(((function(_this) {
      return function() {
        return md_input.resume();
      };
    })(this)), this._handle_error);
    return null;
  };

  if (module.parent == null) {
    this.pdf_from_md('texts/demo');
  }

}).call(this);

//# sourceMappingURL=../sourcemaps/tex-writer.js.map
