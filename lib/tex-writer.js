// Generated by CoffeeScript 2.3.1
(function() {
  //###########################################################################################################
  var $, $async, ASYNC, AUX, CACHE, CND, D, HELPERS, LINEBREAKER, MACRO_ESCAPER, MACRO_INTERPRETER, MD_READER, MKTS, MKTSCRIPT_WRITER, OPTIONS, SEMVER, TEXLIVEPACKAGEINFO, TEXT, XNCHR, after, alert, badge, before, copy, debug, echo, help, hide, info, is_hidden, is_stamped, jr, log, njs_fs, njs_path, options_route, rpr, select, stamp, step, suspend, unstamp, urge, warn, whisper, ƒ, Σ_formatted_warning,
    splice = [].splice,
    slice = [].slice;

  njs_path = require('path');

  njs_fs = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/TEX-WRITER';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  suspend = require('coffeenode-suspend');

  step = suspend.step;

  //...........................................................................................................
  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  //...........................................................................................................
  ASYNC = require('async');

  //...........................................................................................................
  ƒ = CND.format_number.bind(CND);

  HELPERS = require('./helpers');

  TEXLIVEPACKAGEINFO = require('./texlivepackageinfo');

  options_route = '../options.coffee';

  ({CACHE, OPTIONS} = require('./options-and-cache'));

  SEMVER = require('semver');

  //...........................................................................................................
  TEXT = require('coffeenode-text');

  XNCHR = require('./xnchr');

  MKTS = require('./main');

  MKTSCRIPT_WRITER = require('./mktscript-writer');

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  MACRO_ESCAPER = require('./macro-escaper');

  MACRO_INTERPRETER = require('./macro-interpreter');

  LINEBREAKER = require('./linebreaker');

  this.COLUMNS = require('./tex-writer-columns');

  AUX = require('./tex-writer-aux');

  //...........................................................................................................
  Σ_formatted_warning = Symbol('formatted-warning');

  jr = JSON.stringify;

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT experimental, should become part of `PIPEDREAMS` to facilitate automated assembly of pipelines
  based on registered precedences using `CND.TSORT` */
  before = function(...names) {
    var method, ref;
    ref = names, [...names] = ref, [method] = splice.call(names, -1);
    return method;
  };

  //-----------------------------------------------------------------------------------------------------------
  after = function(...names) {
    var method, ref;
    ref = names, [...names] = ref, [method] = splice.call(names, -1);
    return method;
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.compile_options = function() {
    /* TAINT this method should go to OPTIONS */
    var cache_locator, cache_route, has_double_slash, has_single_slash, i, len, locator, locators, options_home, options_locator, ref, route, texinputs_routes;
    options_locator = require.resolve(njs_path.resolve(__dirname, options_route));
    // debug '©zNzKn', options_locator
    options_home = njs_path.dirname(options_locator);
    this.options = OPTIONS.from_locator(options_locator);
    this.options['home'] = options_home;
    this.options['locator'] = options_locator;
    cache_route = this.options['cache']['route'];
    this.options['cache']['locator'] = cache_locator = njs_path.resolve(options_home, cache_route);
    this.options['xelatex-command'] = njs_path.resolve(options_home, this.options['xelatex-command']);
    //.........................................................................................................
    if (!njs_fs.existsSync(cache_locator)) {
      this.options['cache']['%self'] = {};
      CACHE.save(this.options);
    }
    //.........................................................................................................
    this.options['cache']['%self'] = require(cache_locator);
    //.........................................................................................................
    if ((texinputs_routes = (ref = this.options['texinputs']) != null ? ref['routes'] : void 0) != null) {
      locators = [];
      for (i = 0, len = texinputs_routes.length; i < len; i++) {
        route = texinputs_routes[i];
        has_single_slash = /\/$/.test(route);
        has_double_slash = /\/\/$/.test(route);
        locator = njs_path.resolve(options_home, route);
        if (has_double_slash) {
          locator += '//';
        } else if (has_single_slash) {
          locator += '/';
        }
        locators.push(locator);
      }
      /* TAINT duplication: tex_inputs_home, texinputs_value */
      /* TAINT path separator depends on OS */
      this.options['texinputs']['value'] = locators.join(':');
    }
    // @options[ 'locators' ] = {}
    // for key, route of @options[ 'routes' ]
    //   @options[ 'locators' ][ key ] = njs_path.resolve options_home, route
    //.........................................................................................................
    // debug '©ed8gv', JSON.stringify @options, null, '  '
    return CACHE.update(this.options);
  };

  //...........................................................................................................
  this.compile_options();

  //-----------------------------------------------------------------------------------------------------------
  this.write_mkts_master = function(layout_info, handler) {
    var self;
    self = this;
    return step(function*(resume) {
      var content_locator, defs, filename, font_settings, font_settings_txt, fonts_home, fontspec_version, home, i, len, lines, main_font_name, master_locator, name, newcommands, otf, ref, styles, subfolder, texname, text, use_new_syntax, value, write;
      lines = [];
      write = lines.push.bind(lines);
      master_locator = layout_info['master-locator'];
      content_locator = layout_info['content-locator'];
      help(`writing ${master_locator}`);
      //-------------------------------------------------------------------------------------------------------
      write("");
      write(`% ${master_locator}`);
      write("% do not edit this file");
      write(`% generated from ${self.options['locator']}`);
      write(`% on ${new Date()}`);
      write("");
      write("\\documentclass[a4paper,twoside]{book}");
      write("");
      //-------------------------------------------------------------------------------------------------------
      // DEFS
      //.......................................................................................................
      defs = self.options['defs'];
      write("");
      write("% DEFS");
      if (defs != null) {
        for (name in defs) {
          value = defs[name];
          write(`\\def\\${name}{${value}}`);
        }
      }
      //-------------------------------------------------------------------------------------------------------
      // NEWCOMMANDS
      //.......................................................................................................
      newcommands = self.options['newcommands'];
      write("");
      write("% NEWCOMMANDS");
      if (newcommands != null) {
        for (name in newcommands) {
          value = newcommands[name];
          warn(`implicitly converting newcommand value for ${name}`);
          value = njs_path.resolve(__dirname, '..', value);
          write(`\\newcommand{\\${name}}{%\n${value}%\n}`);
        }
      }
      //-------------------------------------------------------------------------------------------------------
      // PACKAGES
      //.......................................................................................................
      write("");
      write("% PACKAGES");
      // write "\\usepackage{mkts2015-main}"
      // write "\\usepackage{mkts2015-fonts}"
      // write "\\usepackage{mkts2015-article}"
      write("\\usepackage{mkts2015-consolidated}");
      //-------------------------------------------------------------------------------------------------------
      // FONTS
      //......................................................................................................
      fontspec_version = (yield TEXLIVEPACKAGEINFO.read_texlive_package_version(self.options, 'fontspec', resume));
      use_new_syntax = SEMVER.satisfies(fontspec_version, '>=2.4.0');
      fonts_home = self.options['fonts']['home'];
      //.......................................................................................................
      write("");
      write("% FONTS");
      write(`% assuming fontspec@${fontspec_version}`);
      write("\\usepackage{fontspec}");
      ref = self.options['fonts']['files'];
      //.......................................................................................................
      for (i = 0, len = ref.length; i < len; i++) {
        ({texname, otf, home, subfolder, filename} = ref[i]);
        if (home == null) {
          home = fonts_home;
        }
        if (subfolder != null) {
          home = njs_path.join(home, subfolder);
        }
        if (!home.endsWith('/')) {
          home = `${home}/`;
        }
        font_settings = [`Path=${home}`];
        if (otf != null) {
          font_settings.push(otf);
        }
        font_settings_txt = font_settings.join(',');
        if (use_new_syntax) {
          /* TAINT should properly escape values */
          write(`\\newfontface{\\${texname}}{${filename}}[${font_settings_txt}]`);
        } else {
          // write "\\newcommand{\\#{texname}}{"
          // write "\\typeout{\\trmWhite{redefining #{texname}}}"
          // write "\\newfontface{\\#{texname}XXX}{#{filename}}[#{font_settings_txt}/]"
          // write "\\renewcommand{\\#{texname}}{\\#{texname}XXX}"
          // write "}"
          write(`\\newfontface\\${texname}[${font_settings_txt}]{${filename}}`);
        }
      }
      write("");
      //-------------------------------------------------------------------------------------------------------
      // STYLES
      //......................................................................................................
      write("");
      write("% STYLES");
      if ((styles = self.options['styles']) != null) {
        for (name in styles) {
          value = styles[name];
          write(`\\newcommand{\\${name}}{%\n${value}%\n}`);
        }
      }
      //-------------------------------------------------------------------------------------------------------
      main_font_name = self.options['fonts']['main'];
      if (main_font_name == null) {
        throw new Error("need entry options/fonts/name");
      }
      write("");
      write("% CONTENT");
      // write "\\begin{document}\\mktsStyleNormal"
      //-------------------------------------------------------------------------------------------------------
      // INCLUDES
      //.......................................................................................................
      write("");
      write(`\\input{${content_locator}}`);
      write("");
      //-------------------------------------------------------------------------------------------------------
      write("\\end{document}");
      //-------------------------------------------------------------------------------------------------------
      text = lines.join('\n');
      // whisper text
      return njs_fs.writeFile(master_locator, text, handler);
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX = {
    TYPOFIX: require('./tex-writer-typofix'),
    SH: require('./tex-writer-sh'),
    CALL: require('./tex-writer-call'),
    DOCUMENT: {},
    COMMAND: {},
    REGION: {},
    BLOCK: {},
    INLINE: {},
    MIXED: {},
    CLEANUP: {}
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.COMMAND.$new_page = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, text, type;
      if (!select(event, '!', 'new-page')) {
        return send(event);
      }
      send(stamp(event));
      [type, name, text, meta] = event;
      return send(['tex', "\\null\\newpage{}"]);
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.COMMAND.$comment = (S) => {
    var remark;
    remark = MD_READER._get_remark();
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, text, type;
      if (!select(event, '.', 'comment')) {
        return send(event);
      }
      [type, name, text, meta] = event;
      return send(remark('drop', `\`.comment\`: ${rpr(text)}`, copy(meta)));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$document = (S) => {
    var bare, before_document_command, before_flush, buffer, flush_as, ref, send_, start_document_event;
    buffer = [];
    start_document_event = null;
    before_document_command = true;
    send_ = null;
    before_flush = true;
    bare = (ref = S.bare) != null ? ref : false;
    //.........................................................................................................
    flush_as = (what) => {
      var event, i, j, len, len1;
      send_(['tex', "\n% begin of MD document\n"]);
      if (what === 'preamble' && buffer.length > 0) {
        send_(['tex', "% (extra preamble inserted from MD document)\n"]);
        for (i = 0, len = buffer.length; i < len; i++) {
          event = buffer[i];
          send_(event);
        }
      }
      send_(stamp(start_document_event));
      if (!bare) {
        send_(['tex', "\\begin{document}\\mktsStyleNormal{}"]);
      }
      if (what === 'document') {
        for (j = 0, len1 = buffer.length; j < len1; j++) {
          event = buffer[j];
          send_(event);
        }
      }
      buffer.length = 0;
      return before_document_command = false;
    };
    //.........................................................................................................
    return $((event, send) => {
      send_ = send;
      //.......................................................................................................
      if (before_flush) {
        send(event);
        if (select(event, '~', 'flush')) {
          return before_flush = false;
        }
      //.......................................................................................................
      } else if (select(event, ')', 'document')) {
        if (before_document_command) {
          flush_as('document');
        }
        send(['tex', "\n% end of MD document\n"]);
        return send(stamp(event));
      //.......................................................................................................
      } else if (select(event, '!', 'document')) {
        send(stamp(event));
        return flush_as('preamble');
      //.......................................................................................................
      } else if (before_document_command) {
        if (select(event, '(', 'document')) {
          return start_document_event = event;
        } else {
          return buffer.push(event);
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.REGION.$code = (S) => {
    /* TAINT code duplication with `REGION.$keep_lines` possible */
    var track;
    track = MD_READER.TRACKER.new_tracker('(code)');
    //.........................................................................................................
    return $((event, send) => {
      var keeplines_parameters, language, meta, name, parameters, settings, text, type, within_code;
      within_code = track.within('(code)');
      track(event);
      //.......................................................................................................
      if (select(event, '.', 'text')) {
        [type, name, text, meta] = event;
        if (within_code) {
          text = text.replace(/\u0020/g, '\u00a0');
        }
        return send([type, name, text, meta]);
      //.......................................................................................................
      } else if (select(event, ['(', ')'], 'code')) {
        [type, name, parameters, meta] = event;
        [language, settings] = parameters;
        keeplines_parameters = settings != null ? [settings] : [];
        //.....................................................................................................
        if (type === '(') {
          send(stamp(event));
          send(['(', 'keep-lines', keeplines_parameters, copy(meta)]);
          if (language !== 'keep-lines') {
            return send(['tex', "\n\n{\\mktsStyleCode{}"]);
          }
        } else {
          if (language !== 'keep-lines') {
            send(['tex', "}\n\n"]);
          }
          send([')', 'keep-lines', keeplines_parameters, copy(meta)]);
          return send(stamp(event));
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.REGION.$keep_lines = (S) => {
    var last_was_empty, squish, track;
    track = MD_READER.TRACKER.new_tracker('(keep-lines)');
    last_was_empty = false;
    squish = false;
    //.........................................................................................................
    return $((event, send) => {
      var chunk, chunks, i, len, meta, name, parameters, ref, ref1, results, text, type, within_keep_lines;
      within_keep_lines = track.within('(keep-lines)');
      track(event);
      //.......................................................................................................
      if (within_keep_lines && select(event, '.', 'text')) {
        // send stamp event
        [type, name, text, meta] = event;
        /* TAINT other replacements possible; use API */
        /* TAINT U+00A0 (nbsp) might be too wide */
        // text = text.replace /\n\n/g, "{\\mktsTightParagraphs\\null\\par\n"
        text = text.replace(/\u0020/g, '\u00a0');
        // text    = text.replace /^\n/,     ''
        chunks = text.split(/(\n)/g);
        results = [];
        for (i = 0, len = chunks.length; i < len; i++) {
          chunk = chunks[i];
          if (chunk === '\n') {
            if (last_was_empty) {
              results.push(send(['tex', "\\null\\par\n"]));
            } else {
              results.push(send(['tex', "\\par\n"]));
            }
          } else {
            if (!(last_was_empty = chunk.length === 0)) {
              // debug `0903`, rpr chunk
              // chunk = @MKTX.TYPOFIX.fix_typography_for_tex chunk, S.options
              results.push(send(['.', 'text', chunk, copy(meta)]));
            } else {
              results.push(void 0);
            }
          }
        }
        return results;
      // send [ 'tex', chunk, ]
      //.......................................................................................................
      } else if (select(event, '(', 'keep-lines')) {
        send(stamp(event));
        [type, name, parameters, meta] = event;
        if (!(squish = (ref = parameters != null ? (ref1 = parameters[0]) != null ? ref1['squish'] : void 0 : void 0) != null ? ref : true)) {
          send(['tex', "\\null\\par"]);
        }
        return send(['tex', "{\\mktsTightParagraphs{}"]);
      //.......................................................................................................
      } else if (select(event, ')', 'keep-lines')) {
        send(stamp(event));
        return send(['tex', "}"]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  before('@MKTX.BLOCK.$heading', '@MKTX.COMMAND.$toc', this.MKTX.REGION.$toc = (S) => {
    var buffer, track;
    track = MD_READER.TRACKER.new_tracker('(toc)');
    buffer = null;
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, text, type, within_toc;
      within_toc = track.within('(toc)');
      track(event);
      //.......................................................................................................
      if (select(event, '(', 'toc')) {
        send(stamp(event));
        [type, name, text, meta] = event;
        return buffer = ['!', name, text, meta];
      //.......................................................................................................
      } else if (select(event, ')', 'toc')) {
        send(stamp(event));
        if (buffer != null) {
          send(buffer);
          return buffer = null;
        }
      //.......................................................................................................
      } else if (within_toc && select(event, '.', 'comma')) {
        if (buffer != null) {
          send(buffer);
          return buffer = null;
        }
      //.......................................................................................................
      } else if (within_toc && select(event, ['(', ')'], 'h')) {
        [type, name, text, meta] = event;
        meta['toc'] = 'omit';
        return send(event);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  });

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK.$heading = (S) => {
    /* TAINT make numbering style configurable */
    /* TAINT generalize for more than 3 levels */
    var h_idx, h_nrs;
    h_nrs = [1, 1, 1];
    h_idx = -1;
    //.........................................................................................................
    return $((event, send) => {
      var h_key, level, meta, name, type;
      //.......................................................................................................
      if (select(event, '(', 'h')) {
        [type, name, level, meta] = event;
        h_idx += +1;
        h_key = `h-${h_idx}`;
        if (meta['h'] == null) {
          meta['h'] = {};
        }
        meta['h']['idx'] = h_idx;
        meta['h']['key'] = h_key;
        //.....................................................................................................
        send(['tex', "\n"]);
        send(stamp(event));
        //.....................................................................................................
        switch (level) {
          case 1:
            send([
              '!',
              'columns',
              [1],
              copy(meta,
              {
                toc: 'omit'
              })
            ]);
            send(['tex', "{\\mktsHOne{}"]);
            return send([
              'tex',
              `\\zlabel{${h_key}}`,
              {
                toc: 'omit'
              }
            ]);
          case 2:
            send([
              '!',
              'columns',
              [1],
              copy(meta,
              {
                toc: 'omit'
              })
            ]);
            send(['tex', "{\\mktsHTwo{}"]);
            return send([
              'tex',
              `\\zlabel{${h_key}}`,
              {
                toc: 'omit'
              }
            ]);
          case 3:
            send([
              '!',
              'columns',
              [1],
              copy(meta,
              {
                toc: 'omit'
              })
            ]);
            send(['tex', "{\\mktsHThree{}"]);
            return send([
              'tex',
              `\\zlabel{${h_key}}`,
              {
                toc: 'omit'
              }
            ]);
          default:
            return send(['.', 'warning', `heading level ${level} not implemented`, copy(meta)]);
        }
      //.......................................................................................................
      } else if (select(event, ')', 'h')) {
        [type, name, level, meta] = event;
        //.....................................................................................................
        switch (level) {
          case 1:
            send(['tex', "\\mktsHOneBeg}%\n"]);
            send([
              '!',
              'columns',
              ['pop'],
              copy(meta,
              {
                toc: 'omit'
              })
            ]);
            break;
          case 2:
            send(['tex', "\\mktsHTwoBeg}%\n"]);
            send([
              '!',
              'columns',
              ['pop'],
              copy(meta,
              {
                toc: 'omit'
              })
            ]);
            break;
          case 3:
            send(['tex', "\\mktsHThreeBeg}%\n\n"]);
            send([
              '!',
              'columns',
              ['pop'],
              copy(meta,
              {
                toc: 'omit'
              })
            ]);
            break;
          default:
            return send(['.', 'warning', `heading level ${level} not implemented`, copy(meta)]);
        }
        //.....................................................................................................
        return send(stamp(event));
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.COMMAND.$crossrefs = (S) => {
    var crossrefs;
    crossrefs = {};
    //.........................................................................................................
    return $((event, send) => {
      /* count   = crossrefs[ text ] = ( crossrefs[ text ] ? 0 ) + 1 */
      /* key     = "#{text}-#{count}" */
      var key, meta, name, text, type;
      [type, name, text, meta] = event;
      //.......................................................................................................
      if (select(event, '!', ['crossref-anchor'])) {
        debug('33393', event);
        key = text;
        send(['tex', `\\label{${key}}`]);
        send(stamp(event));
      //.......................................................................................................
      } else if (select(event, '!', ['crossref-link'])) {
        debug('33394', event);
        /* count   = crossrefs[ text ] = ( crossrefs[ text ] ? 0 ) + 1 */
        /* key     = "#{text}-#{count}" */
        key = text;
        send(['tex', `\\mktsPagerefArrow{${key}}`]);
        send(stamp(event));
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  before('@MKTX.COMMAND.$toc', after('@MKTX.BLOCK.$heading', this.MKTX.MIXED.$collect_headings_for_toc = (S) => {
    var buffer, headings, new_heading, remark, this_heading, within_heading;
    within_heading = false;
    this_heading = null;
    headings = [];
    buffer = [];
    remark = MD_READER._get_remark();
    //.........................................................................................................
    new_heading = function(level, meta) {
      var R;
      R = {
        level: level,
        idx: meta['h']['idx'],
        key: meta['h']['key'],
        events: []
      };
      return R;
    };
    //.........................................................................................................
    return $((event, send) => {
      /* TAINT use library method to test event category */
      var i, j, len, len1, level, meta, name, sub_event, text, type;
      // debug '8624', event
      [type, name, text, meta] = event;
      //.......................................................................................................
      if (select(event, '~', ['flush', 'stop'])) {
        send(remark(name, `releasing ${buffer.length} events`, copy(meta)));
        for (i = 0, len = buffer.length; i < len; i++) {
          sub_event = buffer[i];
          send(sub_event);
        }
        buffer.length = 0;
        return send(event);
      //.......................................................................................................
      } else if (select(event, '(', 'document')) {
        return send(event);
      //.......................................................................................................
      } else if (select(event, ')', 'document')) {
        // debug '2139', unstamp [ '.', 'toc-headings', headings, meta, ]
        send(unstamp(['.', 'toc-headings', headings, meta]));
        for (j = 0, len1 = buffer.length; j < len1; j++) {
          sub_event = buffer[j];
          send(sub_event);
        }
        buffer.length = 0;
        return send(event);
      //.......................................................................................................
      } else if ((meta != null) && (meta['toc'] !== 'omit') && select(event, '(', 'h')) {
        level = text;
        within_heading = true;
        this_heading = new_heading(level, meta);
        headings.push(this_heading);
        return buffer.push(event);
      //.......................................................................................................
      } else if (select(event, ')', 'h')) {
        within_heading = false;
        this_heading = null;
        return buffer.push(event);
      //.......................................................................................................
      } else if (within_heading) {
        /* TAINT use library method to determine event category */
        if (event[event.length - 1]['toc'] !== 'omit') {
          if (event.length === 4) {
            this_heading['events'].push([type, name, text, copy(meta)]);
          } else {
            this_heading['events'].push(event);
          }
        }
        if (event[event.length - 1]['toc'] !== 'only') {
          return buffer.push(event);
        }
      } else {
        //.......................................................................................................
        return buffer.push(event);
      }
    });
  }));

  //-----------------------------------------------------------------------------------------------------------
  after('@MKTX.REGION.$toc', '@MKTX.MIXED.$collect_headings_for_toc', this.MKTX.COMMAND.$toc = (S) => {
    var headings;
    headings = null;
    //.........................................................................................................
    return $((event, send) => {
      var _, events, h_event, heading, i, idx, j, key, last_idx, len, len1, level, meta, name, text, type;
      //.......................................................................................................
      /* TAINT use library method to test event category */
      if (select(event, '.', 'toc-headings')) {
        [_, _, headings, _] = event;
        return send(stamp(event));
      //.......................................................................................................
      } else if (select(event, '!', 'toc')) {
        send(stamp(event));
        //.....................................................................................................
        if (headings == null) {
          return send(['.', 'warning', "expecting toc-headings event before this", copy(meta)]);
        }
        //.....................................................................................................
        [type, name, text, meta] = event;
        send(['tex', '{\\mktsToc%\n']);
// send [ '!', 'mark', 'toc', ( copy meta ), ]
        for (i = 0, len = headings.length; i < len; i++) {
          heading = headings[i];
          ({level, events, key} = heading);
          last_idx = events.length - 1;
          for (idx = j = 0, len1 = events.length; j < len1; idx = ++j) {
            h_event = events[idx];
            if (h_event.length === 4) {
              // debug '23432', h_event
              /* TAINT use library method to determine event category */
              h_event = unstamp(h_event);
            }
            if (idx === last_idx) {
              send(['tex', `{\\mktsStyleNormal \\dotfill \\zpageref{${key}}}`]);
            }
            // send [ 'tex', " \\dotfill \\zpageref{#{key}}", ] if idx is last_idx
            send(h_event);
          }
        }
        return send(['tex', '\\mktsTocBeg}%\n']);
      } else {
        // headings.length = 0
        //.......................................................................................................
        return send(event);
      }
    });
  });

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK.$yadda = (S) => {
    var cache, generate_yadda, settings;
    generate_yadda = require('lorem-ipsum');
    cache = [];
    settings = {
      count: 1, // Number of words, sentences, or paragraphs to generate.
      // units:                'sentences'             # Generate words, sentences, or paragraphs.
      units: 'paragraphs', // Generate words, sentences, or paragraphs.
      sentenceLowerBound: 5, // Minimum words per sentence.
      sentenceUpperBound: 15, // Maximum words per sentence.
      paragraphLowerBound: 3, // Minimum sentences per paragraph.
      paragraphUpperBound: 7, // Maximum sentences per paragraph.
      format: 'plain', // Plain text or html
      // words:                ['ad', 'dolor', ... ]   # Custom word dictionary. Uses dictionary.words (in lib/dictionary.js) by default.
      random: CND.get_rnd(42, 3), // A PRNG function. Uses Math.random by default
      suffix: '\n' // The character to insert between paragraphs. Defaults to default EOL for your OS.
    };
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, parameters, type, yadda, yadda_idx;
      if (select(event, '!', 'yadda')) {
        [type, name, parameters, meta] = event;
        [yadda_idx] = parameters;
        if (yadda_idx == null) {
          yadda_idx = cache.length;
        }
        while (cache.length - 1 < yadda_idx) {
          cache.push(generate_yadda(settings));
        }
        yadda = cache[yadda_idx];
        // yadda = @MKTX.TYPOFIX.fix_typography_for_tex yadda, S.options
        send(stamp(event));
        // send [ 'tex', yadda, ]
        return send(['.', 'text', yadda, copy(meta)]);
      } else {
        // send [ '.', 'p', null, ( copy meta ), ]
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$box = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, parameters, type;
      if (select(event, '(', 'box')) {
        [type, name, parameters, meta] = event;
        send(stamp(event));
        if (parameters.frame) {
          return send(['tex', "\\framebox{"]);
        } else {
          return send(['tex', "\\makebox{"]);
        }
      //.......................................................................................................
      } else if (select(event, ')', 'box')) {
        send(stamp(event));
        return send(['tex', "}"]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$custom_entities = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      var _, entry, key, meta, ref;
      if (select(event, '.', 'entity')) {
        [_, _, key, meta] = event;
        entry = (ref = S.options.entities[key]) != null ? ref : [];
        if (entry == null) {
          //.....................................................................................................
          return send(event);
        }
        if (!((entry.type != null) && (entry.value != null))) {
          send(['.', 'warning', `entry for entity ${rpr(key)} needs both 'type' and 'value', got ${rpr(entry)}`, copy(meta)]);
          return null;
        }
        //.....................................................................................................
        switch (entry.type) {
          case 'text':
            send(['.', 'text', entry.value, copy(meta)]);
            return send(stamp(event));
          case 'tex':
            send(['tex', entry.value]);
            return send(stamp(event));
          default:
            return send(event);
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK.$blockquote = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      if (select(event, '(', 'blockquote')) {
        // [ type, name, parameters, meta, ] = event
        send(stamp(event));
        // send [ 'tex', "{\\setlength{\\leftskip}{5mm}\\setlength{\\rightskip}{5mm}", ]
        return send(['tex', "\\begin{mktsEnvBlockquote}"]);
      //.......................................................................................................
      } else if (select(event, ')', 'blockquote')) {
        // [ type, name, parameters, meta, ] = event
        send(stamp(event));
        // send [ 'tex', "}\n\n", ]
        return send(['tex', "\\end{mktsEnvBlockquote}\n\n"]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK.$paragraph_1 = (S) => {
    /* TAINT should unify the two observers */
    var track;
    track = MD_READER.TRACKER.new_tracker('(code)', '(keep-lines)');
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, text, type, within_code, within_keep_lines;
      within_code = track.within('(code)');
      within_keep_lines = track.within('(keep-lines)');
      track(event);
      //.......................................................................................................
      if (select(event, '.', 'p')) {
        [type, name, text, meta] = event;
        if (within_code || within_keep_lines) {
          send(stamp(event));
          // send [ 'tex', "\n%% PARAGRAPH ##{S.paragraph_nr})\n" ]
          return send(['tex', '\n\n']);
        } else {
          // send [ 'tex', "\n%% PARAGRAPH ##{S.paragraph_nr})\n" ]
          send(stamp(event));
          return send(this.MKTX.BLOCK._end_paragraph());
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK.$paragraph_2 = (S) => {
    var close_paragraph, collector, is_first_par, seen_text_event, within_noindent, within_paragraph;
    within_paragraph = false;
    seen_text_event = false;
    collector = [];
    close_paragraph = false;
    within_noindent = false;
    is_first_par = true;
    //.........................................................................................................
    return $((event, send) => {
      var cached_event, has_indent, i, j, len, len1;
      // send [ 'tex', ( '% 73632' + ( jr event ) + '\n' ), ]
      if (select(event, '(', ['h', 'multi-columns', 'blockquote'], true)) {
        is_first_par = true;
      }
      if (select(event, ')', ['blockquote', 'ul', 'code'], true)) {
        is_first_par = true;
      }
      if (select(event, '.', ['hr', 'hr2'], true)) {
        is_first_par = true;
      }
      if (select(event, '(', ['ul', 'keep-lines'], true)) {
        within_noindent = true;
      }
      if (select(event, ')', ['ul', 'keep-lines'], true)) {
        within_noindent = false;
      }
      //.......................................................................................................
      if (select(event, '~', 'start-paragraph', true)) {
        within_paragraph = true;
        seen_text_event = false;
        return S.paragraph_nr += +1;
      // send [ 'tex', "\n%% (PARAGRAPH ##{S.paragraph_nr}\n" ]
      //.......................................................................................................
      } else if (select(event, '.', 'p')) {
        within_paragraph = false;
        seen_text_event = false;
        for (i = 0, len = collector.length; i < len; i++) {
          cached_event = collector[i];
          // send [ 'tex', "\n}\n" ]
          send(cached_event);
        }
        collector.length = 0;
        if (close_paragraph) {
          return close_paragraph = false;
        }
      // send [ 'tex', "\n}% )p\n" ]
      //.......................................................................................................
      } else if (within_paragraph) {
        if (seen_text_event) {
          /* If we're within a paragraph, but some material has aleady gone down the line, then there's
          nothing to do here: */
          return send(event);
        } else {
          /* Otherwise, we either have to cache the current event, or else—if the current event is a text
          event—we have to send all cached events, then the prefix to a new paragraph, and then the text event
          itself. */
          if (!select(event, '.', 'text')) {
            return collector.push(event);
          } else {
            seen_text_event = true;
            close_paragraph = true;
            for (j = 0, len1 = collector.length; j < len1; j++) {
              cached_event = collector[j];
              //.................................................................................................
              /* Send all the events encountered so far; typically, these will include commands to set up
              columns etc.: */
              send(cached_event);
            }
            collector.length = 0;
            //.................................................................................................
            /* Check whether we're typesetting the first text portion after a headline, the start of a
            blockquote or similar and send additional material as needed: */
            has_indent = !is_first_par;
            is_first_par = false;
            //.................................................................................................
            if (within_noindent) {
              null;
            // send [ 'tex', "%% no indent within list\n" ]
            } else if (has_indent) {
              // send [ 'tex', "%% with indent\n" ]
              send(['tex', "\\hskip \\mktsLineheight plus 0mm minus 0mm "]);
            } else {
              // send [ 'tex', "¶ " ]
              //.................................................................................................
              null;
            }
            // send [ 'tex', "%% no indent\n" ]
            // send [ 'tex', "÷ " ]
            //.................................................................................................
            /* Finally, send the first text portion of the paragraph itself: */
            return send(event);
          }
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK._end_paragraph = () => {
    /* TAINT use command from sty */
    /* TAINT make configurable */
    // return [ 'tex', '\\mktsShowpar\\par\n' ]
    return ['tex', '\n\n'];
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK.$unordered_list = (S) => {
    var item_markup_tex, tex_by_md_markup;
    tex_by_md_markup = {
      '*': '$\\star$',
      'fallback': '—'
    };
    item_markup_tex = null;
    //.........................................................................................................
    return $((event, send) => {
      var markup, meta, name, ref, text, type;
      //.......................................................................................................
      if (select(event, '(', 'ul')) {
        [type, name, text, meta] = event;
        ({markup} = meta);
        item_markup_tex = (ref = tex_by_md_markup[markup]) != null ? ref : tex_by_md_markup['fallback'];
        return send(stamp(event));
      // send [ 'tex', '\\begin{itemize}' ]
      //.......................................................................................................
      } else if (select(event, '(', 'li')) {
        send(stamp(event));
        // send [ 'tex', "\\item[#{item_markup_tex}] " ]
        // send [ 'tex', "{\\mktsFontfileHanamina{}.⚫.▪.⏹.◼.⬛.}\\hspace{3mm}y" ]
        /* TAINT Horizontal space should depend on other metrics */
        // send [ 'tex', "{\\mktsFontfileHanamina{}\\prPushRaise{-0.4}{-0.1}{⚫}\\hspace{-0.75mm}}" ]
        // send [ 'tex', "{\\mktsFontfileCwtexqheibold{}\\prPushRaise{-0.4}{-0.1}{▷}\\hspace{-1.75mm}}" ]
        // send [ 'tex', "{\\mktsFontfileHanamina{}◼}\\hspace{3mm}L" ]
        // send [ 'tex', "{\\mktsFontfileCwtexqheibold{}\\prPushRaise{-0.4}{-0.1}{▷}}" ]
        return send(['tex', "\\makebox[\\mktsLineheight][l]{\\prPushRaise{-0.2}{-0.1}{\\mktsFontfileHanamina{}◼}}"]);
      //.......................................................................................................
      } else if (select(event, ')', 'li')) {
        send(stamp(event));
        return send(['tex', '\n']);
      //.......................................................................................................
      } else if (select(event, ')', 'ul')) {
        return send(stamp(event));
      } else {
        // send [ 'tex', '\\end{itemize}' ]
        //.......................................................................................................
        return send(event);
      }
    });
  };

  // #-----------------------------------------------------------------------------------------------------------
  // # before '@MKTX.REGION.$single_column', '@MKTX.REGION.$multi_column', \
  // @MKTX.BLOCK.$hr = ( S ) =>
  //   plain_rule  = [ 'tex', "\\mktsRulePlain{}", ]
  //   swell_rule  = [ 'tex', "\\mktsRuleSwell{}", ]
  //   #.........................................................................................................
  //   return $ ( event, send ) =>
  //     #.......................................................................................................
  //     if select event, '.', 'hr'
  //       [ type, name, text, meta, ] = event
  //       switch chr = text[ 0 ]
  //         when '.'
  //           send stamp copy event
  //           send plain_rule
  //         when '-'
  //           send stamp copy event
  //           send swell_rule
  //         when '°'
  //           send stamp hide copy event
  //           send [ '!', 'slash', [], ( copy meta ), ]
  //         when ':'
  //           send stamp hide copy event
  //           send [ '!', 'slash', [ plain_rule, ], ( copy meta ), ]
  //         when '='
  //           send stamp hide copy event
  //           send [ '!', 'slash', [ swell_rule, ], ( copy meta ), ]
  //         when '^'
  //           send stamp hide copy event
  //           send [ '(', 'slash', [], ( copy meta ), ]
  //         when 'v'
  //           send stamp hide copy event
  //           send [ ')', 'slash', [], ( copy meta ), ]
  //         else
  //           send stamp hide copy event
  //           send [ '.', 'warning', "horizontal rule with unknown markup #{rpr text}", ( copy meta ), ]
  //     #.......................................................................................................
  //     else
  //       send event

  //-----------------------------------------------------------------------------------------------------------
  // before '@MKTX.REGION.$single_column', '@MKTX.REGION.$multi_column', \
  this.MKTX.BLOCK.$hr2 = (S) => {
    // plain_rule  = [ 'tex', "\\mktsRulePlain{}", ]
    // swell_rule  = [ 'tex', "\\mktsRuleSwell{}", ]
    // tight_rule  = [ 'tex', "\\mktsRulePlainTight{}", ]
    /*

    / slash
    - plain (line)
    = bold (line)
    -= plain with bold (2 stacked lines)
    =- bold with plain (2 stacked lines)
    -=- plain, bold, plain (3 stacked lines)
    . dotted (line)
    * asterisks (line)
    + swole (line)
    0 compress (above & below; default)
    1 normal (spacing, one line above & below)
    2,1 custom (2 above, 1 below)
    2 splendid (2 above & below)

    // <!-- just a slash -->
    /0-------/
    0-------
    /2+++++2/
    /0--------============1/
     */
    //.........................................................................................................
    return $((event, send) => {
      var above, below, i, len, meta, mid, name, one, parameters, results, rule_command, slash, sub_event, sub_events, three, two, type;
      // #.......................................................................................................
      // ### re-interpret `<hr>`: ###
      // if select event, '(', 'hr'
      //   is_synthetic_event                        = true
      //   [ type, name, parameters, meta, ]         = event
      //   event[ 0 ]                                = '.'
      //   event[ 1 ]                                = 'hr2'
      //   event[ 2 ]                                = { slash: false, above: 0, one: '-', two: null, three: null, below: 0 }
      // #.......................................................................................................
      // if select event, ')', 'hr'
      //   return send stamp event
      //.......................................................................................................
      if (select(event, '.', 'hr2')) {
        send(stamp(event));
        [type, name, parameters, meta] = event;
        ({slash, above, one, two, three, below} = parameters);
        switch (one) {
          case '-':
            rule_command = 'mktsRulePlainTight';
            break;
          case '=':
            rule_command = 'mktsRuleBoldTight';
            break;
          case '#':
            rule_command = 'mktsRuleBlackTight';
            break;
          case '+':
            rule_command = 'mktsRuleEnglish';
            break;
          case '°':
            rule_command = 'mktsRuleZero';
            break;
          default:
            return send(['.', 'warning', `unknown hrule markup ${rpr(one)}`, copy(meta)]);
        }
        below += -1;
        sub_events = [];
        if (above !== 0) {
          sub_events.push(['tex', `\\mktsVspace{${above}}`]);
        }
        sub_events.push(['tex', `\\${rule_command}{}`]);
        if (below !== 0) {
          sub_events.push(['tex', `\\mktsVspace{${below}}`]);
        }
        sub_events.push(['tex', "\n\n"]);
        if (slash) {
          // send [ 'tex', "\\gdef\\mktsNextVspaceCount{#{above}}%TEX-WRITER/$hr2\n", ]
          // send [ '!', 'slash', null, ( copy meta ), ]
          mid = sub_events;
          return send(['!', 'slash', {above, mid, below}, copy(meta)]);
        } else {
          results = [];
          for (i = 0, len = sub_events.length; i < len; i++) {
            sub_event = sub_events[i];
            // send [ 'tex', "\\gdef\\mktsNextVspaceCount{#{above}}\\mktsVspace{}" ] if above > 0
            // send [ 'tex', "\\mktsRulePlainTight{}", ]
            // send [ 'tex', "\\gdef\\mktsNextVspaceCount{#{below}}\\mktsVspace{}" ] if below > 0
            // send [ 'tex', "\n\n" ]
            results.push(send(sub_event));
          }
          return results;
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.COMMAND.$echo = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      var _, meta, parameters;
      //.......................................................................................................
      if (select(event, '!', 'echo')) {
        [_, _, parameters, meta] = event;
        send(stamp(event));
        return send(['.', 'text', rpr(parameters), copy(meta)]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.BLOCK.$nl = (S) => {
    /* TAINT consider to zero-width non-breaking space */
    var nl;
    nl = ['tex', "~\\\\\n"];
    //.........................................................................................................
    return $((event, send) => {
      var _, count, i, meta, name, ref, results, type;
      //.......................................................................................................
      if (select(event, '!', 'nl')) {
        [type, name, [count], meta] = event;
        results = [];
        for (_ = i = 0, ref = count != null ? count : 1; i < ref; _ = i += +1) {
          results.push(send(nl));
        }
        return results;
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$code_span = (S) => {
    var track;
    track = MD_READER.TRACKER.new_tracker('(code-span)');
    //.........................................................................................................
    return $((event, send) => {
      var _, fragment, fragments, i, idx, last_idx, len, meta, results, text, within_code_span;
      within_code_span = track.within('(code-span)');
      track(event);
      //.......................................................................................................
      if (select(event, '(', 'code-span')) {
        send(stamp(event));
        return send(['tex', '{\\mktsStyleCode{}']);
      //.......................................................................................................
      } else if (select(event, ')', 'code-span')) {
        send(['tex', "}"]);
        return send(stamp(event));
      //.......................................................................................................
      } else if (within_code_span && select(event, '.', 'text')) {
        // send event
        [_, _, text, meta] = event;
        //.....................................................................................................
        /* TAINT sort-of code duplication with command url */
        fragments = LINEBREAKER.fragmentize(text);
        last_idx = fragments.length - 1;
//.....................................................................................................
        results = [];
        for (idx = i = 0, len = fragments.length; i < len; idx = ++i) {
          fragment = fragments[idx];
          send(['.', 'text', fragment, copy(meta)]);
          if (idx !== last_idx) {
            results.push(send(['tex', "\\allowbreak{}"]));
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$image = (S) => {
    var alt, alt_cache, event_cache, src, track;
    track = MD_READER.TRACKER.new_tracker('(image)');
    event_cache = [];
    alt_cache = [];
    src = null;
    alt = null;
    //.........................................................................................................
    return $((event, send) => {
      var cached_event, i, len, meta, name, text, type, within_image;
      within_image = track.within('(image)');
      track(event);
      [type, name, text, meta] = event;
      //.......................................................................................................
      if (select(event, '(', 'image')) {
        send(stamp(event));
        return src = njs_path.resolve(S.layout_info['source-home'], meta['src']);
      // src = njs_path.resolve S.layout_info[ 'source-home' ], meta[ 'src' ]
      //.......................................................................................................
      } else if (select(event, ')', 'image')) {
        alt = alt_cache.join('');
        send(['tex', '\\begin{figure}%\n']);
        /* TAINT escape `src`? */
        send(['tex', `\\includegraphics[width=\\textwidth]{${src}}%\n`]);
        // send [ 'tex', "\\includegraphics[width=0.5\\textwidth]{#{src}}%\n", ]
        send(['tex', `\\caption[${alt}]{%\n`]);
        for (i = 0, len = event_cache.length; i < len; i++) {
          cached_event = event_cache[i];
          send(cached_event);
        }
        send(['tex', '}%\n']);
        send(['tex', '\\end{figure}%\n']);
        src = null;
        alt_cache.length = 0;
        return send(stamp(event));
      //.......................................................................................................
      } else if (within_image) {
        event_cache.push(event);
        if (select(event, '.', 'text')) {
          return alt_cache.push(text);
        }
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.MIXED.$raw = (S) => {
    var remark;
    remark = MD_READER._get_remark();
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, text, type;
      //.......................................................................................................
      if (select(event, '.', 'raw')) {
        [type, name, text, meta] = event;
        send(stamp(hide(copy(event))));
        send(remark('convert', "raw to TeX", copy(meta)));
        text = MACRO_ESCAPER.escape.unescape_escape_chrs(S, text);
        // debug '9382', [ 'tex', text, ]
        return send(['tex', text]);
      } else {
        // send stamp event
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.MIXED.$table = (S) => {
    var buffered_field_separator, description, remark, row_count, track;
    track = MD_READER.TRACKER.new_tracker('(table)', '(th)');
    remark = MD_READER._get_remark();
    buffered_field_separator = null;
    description = null;
    row_count = null;
    //.........................................................................................................
    return $((event, send) => {
      var alignment, col_styles, i, len, meta, name, ref, text, type, within_table, within_th;
      [type, name, text, meta] = event;
      within_table = track.within('(table)');
      within_th = track.within('(th)');
      track(event);
      if (!(within_table || select(event, '(', 'table'))) {
        //.......................................................................................................
        return send(event);
      }
      //.......................................................................................................
      if (within_th && select(event, '.', 'text')) {
        send(['(', 'strong', null, copy(meta)]);
        send(stamp(event));
        return send([')', 'strong', null, copy(meta)]);
      //.......................................................................................................
      } else if (select(event, ')', 'tr')) {
        row_count += +1;
        buffered_field_separator = null;
        send(stamp(hide(copy(event))));
        /* thx to http://tex.stackexchange.com/a/159260 */
        if (row_count === description['row_count']) {
          return send(['tex', "\\\\[\\mktsTabularLineheightDeltaLast]\n"]);
        } else {
          return send(['tex', "\\\\[\\mktsTabularLineheightDelta]\n"]);
        }
      } else {
        if (buffered_field_separator) {
          // last_zerohline_idx = send [ 'tex', "\\mktsZerohline\n", ]
          //.......................................................................................................
          send(buffered_field_separator);
        }
        buffered_field_separator = null;
        //.....................................................................................................
        if (select(event, '(', 'table')) {
          send(stamp(hide(copy(event))));
          col_styles = [];
          row_count = 0;
          description = meta['table'];
          ref = description['alignments'];
          for (i = 0, len = ref.length; i < len; i++) {
            alignment = ref[i];
            switch (alignment) {
              case 'left':
                col_styles.push('l');
                break;
              case 'center':
                col_styles.push('c');
                break;
              case 'right':
                col_styles.push('r');
                break;
              default:
                col_styles.push('l');
            }
          }
          col_styles = '| ' + (col_styles.join(' | ')) + ' |';
          send(['tex', "{"]);
          send(['tex', "\\mktsVspace{\\mktsTabularTopDelta}"]);
          return send(['tex', `\\begin{tabular}[pos]{ ${col_styles} }\n`]);
        //.....................................................................................................
        } else if (select(event, ')', 'table')) {
          send(stamp(hide(copy(event))));
          send(['tex', "\\hline\n"]);
          send(['tex', "\\end{tabular}\n"]);
          send(['tex', "\\mktsVspace{\\mktsTabularBottomDelta}"]);
          send(['tex', "}"]);
          send(['tex', "\n\n"]);
          description = null;
          return row_count = null;
        //.....................................................................................................
        } else if (select(event, '(', 'tbody')) {
          return send(stamp(hide(copy(event))));
        //.....................................................................................................
        } else if (select(event, ')', 'tbody')) {
          return send(stamp(hide(copy(event))));
        //.....................................................................................................
        } else if (select(event, '(', 'td')) {
          return send(stamp(hide(copy(event))));
        //.....................................................................................................
        } else if (select(event, ')', 'td')) {
          send(stamp(hide(copy(event))));
          return buffered_field_separator = ['tex', " & "];
        //.....................................................................................................
        } else if (select(event, '(', 'th')) {
          return send(stamp(hide(copy(event))));
        //.....................................................................................................
        } else if (select(event, ')', 'th')) {
          send(stamp(hide(copy(event))));
          return buffered_field_separator = ['tex', " & "];
        //.....................................................................................................
        } else if (select(event, '(', 'thead')) {
          send(['tex', "\\hline\n"]);
          return send(stamp(hide(copy(event))));
        //.....................................................................................................
        } else if (select(event, ')', 'thead')) {
          send(stamp(hide(copy(event))));
          return send(['tex', "\n\\hline\n"]);
        //.....................................................................................................
        } else if (select(event, '(', 'tr')) {
          return send(stamp(hide(copy(event))));
        } else {
          //.....................................................................................................
          return send(event);
        }
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.MIXED.$footnote = (S) => {
    var style;
    if (S.footnotes != null) {
      /* TAINT should move this to initialization */
      throw new Error("`S.footnotes` already defined");
    }
    S.footnotes = {
      // 'style':      'classic'
      'style': 'on-demand',
      'by-idx': []
    };
    //.........................................................................................................
    switch (style = S.footnotes['style']) {
      case 'classic':
        return this.MKTX.MIXED._$footnote_classic(S);
      case 'on-demand':
        return this.MKTX.MIXED._$footnote_on_demand(S);
      default:
        throw new Error(`unknown footnote style ${rpr(style)}`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.MIXED._$footnote_classic = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      //.......................................................................................................
      if (select(event, '(', 'footnote')) {
        send(stamp(event));
        return send(['tex', "\\footnote{"]);
      //.......................................................................................................
      } else if (select(event, ')', 'footnote')) {
        send(stamp(event));
        return send(['tex', "}"]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.MIXED._$footnote_on_demand = (S) => {
    /* TAINT TeX codes used here should be made configurable */
    var cache, current_fn_cache, current_fn_idx, first_fn_idx, insert_footnotes, last_fn_idx, last_was_footnote, remark, track;
    cache = S.footnotes['by-idx'];
    current_fn_idx = -1;
    current_fn_cache = -1;
    first_fn_idx = 0;
    last_fn_idx = -1;
    track = MD_READER.TRACKER.new_tracker('(footnote)');
    remark = MD_READER._get_remark();
    last_was_footnote = false;
    //.........................................................................................................
    insert_footnotes = (send, meta) => {
      var fn_cache, fn_event, fn_idx, fn_nr, i, j, len, ref, ref1;
      if (last_fn_idx >= first_fn_idx) {
        // send [ '!', 'mark', '42', ( copy meta ), ]
        // send [ '.', 'p', null, ( copy meta ), ]
        send(['tex', "\n\n"]);
        send(['tex', "\\begin{mktsEnNotes}"]);
        for (fn_idx = i = ref = first_fn_idx, ref1 = last_fn_idx; (ref <= ref1 ? i <= ref1 : i >= ref1); fn_idx = ref <= ref1 ? ++i : --i) {
          fn_nr = fn_idx + 1;
          fn_cache = cache[fn_idx];
          cache[fn_idx] = null;
          // send [ 'tex', "(#{fn_nr})\\,", ]
          send(stamp(['(', 'footnote', null, {}]));
          send(['tex', `{\\mktsEnStyleMarkNotes\\mktsEnMarkBefore${fn_nr}\\mktsEnMarkAfter{}}`]);
          for (j = 0, len = fn_cache.length; j < len; j++) {
            fn_event = fn_cache[j];
            send(fn_event);
          }
          send(stamp([')', 'footnote', null, {}]));
        }
        send(['tex', "\\end{mktsEnNotes}\n\n"]);
        first_fn_idx = last_fn_idx + 1;
        return last_fn_idx = first_fn_idx - 1;
      }
    };
    //.........................................................................................................
    return $((event, send) => {
      var fn_nr, fn_separator, meta, name, text, type, within_footnote;
      [type, name, text, meta] = event;
      within_footnote = track.within('(footnote)');
      track(event);
      //.......................................................................................................
      if (select(event, '(', 'footnote')) {
        // send stamp event
        current_fn_cache = [];
        current_fn_idx += +1;
        last_fn_idx = current_fn_idx;
        fn_nr = current_fn_idx + 1;
        cache[current_fn_idx] = current_fn_cache;
        fn_separator = last_was_footnote ? ',' : '';
        // send [ 'tex', "\\mktsEnStyleMark{#{fn_separator}#{fn_nr}}" ]
        return send(['tex', `{\\mktsEnStyleMarkMain{}${fn_separator}${fn_nr}}`]);
      //.......................................................................................................
      } else if (select(event, ')', 'footnote')) {
        // send stamp event
        current_fn_cache = null;
        return last_was_footnote = true;
      //.......................................................................................................
      } else if (within_footnote) {
        current_fn_cache.push(event);
        return send(remark('caching', "event within footnote", event));
      //.......................................................................................................
      } else if (select(event, '!', 'footnotes')) {
        send(stamp(event));
        return insert_footnotes(send, meta);
      //.......................................................................................................
      } else if (select(event, ')', 'document')) {
        insert_footnotes(send, meta);
        return send(event);
      } else {
        //.......................................................................................................
        last_was_footnote = false;
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.MIXED.$footnote.$remove_extra_paragraphs = (S) => {
    var last_event;
    last_event = null;
    //.........................................................................................................
    return $((event, send, end) => {
      if (event != null) {
        //.....................................................................................................
        if (select(event, ')', 'footnote')) {
          if ((last_event != null) && !select(last_event, '.', 'p')) {
            send(last_event);
          }
          last_event = event;
        } else {
          if (last_event != null) {
            //.....................................................................................................
            send(last_event);
          }
          last_event = event;
        }
      }
      //.......................................................................................................
      if (end != null) {
        if (last_event != null) {
          send(last_event);
        }
        return end();
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$translate_i_and_b = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, new_name, text, type;
      //.......................................................................................................
      if (select(event, ['(', ')'], ['i', 'b'])) {
        [type, name, text, meta] = event;
        new_name = name === 'i' ? 'em' : 'strong';
        return send([type, new_name, text, meta]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$super_and_subscript = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, tex_style_name, text, type;
      //.......................................................................................................
      if (select(event, '(', ['sup', 'sub'])) {
        [type, name, text, meta] = event;
        send(stamp(event));
        tex_style_name = name === 'sup' ? 'mktsStyleFontSuperscript' : 'mktsStyleFontSubscript';
        return send(['tex', `{\\${tex_style_name}{}`]);
      //.......................................................................................................
      } else if (select(event, ')', ['sup', 'sub'])) {
        [type, name, text, meta] = event;
        send(stamp(event));
        return send(['tex', "}"]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$mark = (S) => {
    var mark_idx;
    mark_idx = 0;
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, text, type;
      //.......................................................................................................
      if (select(event, '!', 'mark')) {
        [type, name, text, meta] = event;
        send(stamp(event));
        if (text == null) {
          mark_idx += +1;
          text = `a-${mark_idx}`;
        }
        // text = @MKTX.TYPOFIX.fix_typography_for_tex text, S.options
        return send(['tex', `\\mktsMark{${text}}`]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$em_strong_and_smallcaps = (S) => {
    var code_count, em_count, sc_lower_count, sc_upper_count, strong_count, tex_events_by_keys;
    em_count = 0;
    strong_count = 0;
    sc_upper_count = 0;
    sc_lower_count = 0;
    code_count = 0;
    //.........................................................................................................
    tex_events_by_keys = {
      // ____: { start: [], stop: [], }
      ___l: {
        start: ["{\\mktsStyleSmallcapslower{}"],
        stop: ["}"]
      },
      __u_: {
        start: ["{\\mktsStyleSmallcapsupper{}"],
        stop: ["}"]
      },
      __ul: {
        start: ["{\\mktsStyleSmallcapsall{}"],
        stop: ["}"]
      },
      _s__: {
        start: ["{\\mktsStyleBold{}"],
        stop: ["}"]
      },
      _s_l: {
        start: ["{\\mktsStyleBold{}"],
        stop: ["}"]
      },
      _su_: {
        start: ["{\\mktsStyleBold{}"],
        stop: ["}"]
      },
      _sul: {
        start: ["{\\mktsStyleBold{}"],
        stop: ["}"]
      },
      e___: {
        start: ["{\\mktsStyleItalic{}"],
        stop: ["\\/", "}"]
      },
      e__l: {
        start: ["{\\mktsStyleItalicsmallcapslower{}"],
        stop: ["\\/", "}"]
      },
      e_u_: {
        start: ["{\\mktsStyleItalicsmallcapsupper{}"],
        stop: ["\\/", "}"]
      },
      e_ul: {
        start: ["{\\mktsStyleItalicsmallcapsall{}"],
        stop: ["\\/", "}"]
      },
      es__: {
        start: ["{\\mktsStyleBolditalic{}"],
        stop: ["\\/", "}"]
      },
      es_l: {
        start: ["{\\mktsStyleBolditalic{}"],
        stop: ["\\/", "}"]
      },
      esu_: {
        start: ["{\\mktsStyleBolditalic{}"],
        stop: ["\\/", "}"]
      },
      esul: {
        start: ["{\\mktsStyleBolditalic{}"],
        stop: ["\\/", "}"]
      }
    };
    // "{\\mktsStyleBold{}"
    //.........................................................................................................
    return $((event, send) => {
      var delta, i, j, key, len, len1, meta, name, results, start, stop, sub_event, text, type;
      [type, name, text, meta] = event;
      delta = type === '(' ? +1 : -1;
      //.......................................................................................................
      if (select(event, ['(', ')'], ['code', 'code-span'])) {
        code_count += delta;
        return send(event);
      //.......................................................................................................
      } else if (select(event, ['(', ')'], 'smallcaps-upper')) {
        sc_upper_count += delta;
        return send(stamp(event));
      //.......................................................................................................
      } else if (select(event, ['(', ')'], 'smallcaps-lower')) {
        sc_lower_count += delta;
        return send(stamp(event));
      //.......................................................................................................
      } else if (select(event, ['(', ')'], 'em')) {
        em_count += delta;
        return send(stamp(event));
      //.......................................................................................................
      } else if (select(event, ['(', ')'], 'strong')) {
        strong_count += delta;
        return send(stamp(event));
      //.......................................................................................................
      } else if (code_count < 1 && select(event, '.', 'text')) {
        if (/^\s*$/.test(event[2])) {
          /* skip markup when text is blank: */
          return send(event);
        }
        key = [em_count > 0 ? 'e' : '_', strong_count > 0 ? 's' : '_', sc_upper_count > 0 ? 'u' : '_', sc_lower_count > 0 ? 'l' : '_'].join('');
        if (key === '____') {
          return send(event);
        }
        ({start, stop} = tex_events_by_keys[key]);
        for (i = 0, len = start.length; i < len; i++) {
          sub_event = start[i];
          send(['tex', sub_event]);
        }
        send(event);
        results = [];
        for (j = 0, len1 = stop.length; j < len1; j++) {
          sub_event = stop[j];
          results.push(send(['tex', sub_event]));
        }
        return results;
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$link = (S) => {
    var cache, last_href, track;
    cache = [];
    last_href = null;
    track = MD_READER.TRACKER.new_tracker('(link)');
    //.........................................................................................................
    return $((event, send) => {
      var cached_event, i, j, len, len1, meta, name, text, type, within_link;
      within_link = track.within('(link)');
      track(event);
      [type, name, text, meta] = event;
      //.......................................................................................................
      if (select(event, '(', 'link')) {
        send(stamp(event));
        last_href = text;
      //.......................................................................................................
      } else if (select(event, ')', 'link')) {
        // debug '©97721', event
        // debug '©97721', cache
        send(['tex', '{\\mktsStyleLinklabel{}']);
        for (i = 0, len = cache.length; i < len; i++) {
          cached_event = cache[i];
          send(cached_event);
        }
        send(['tex', '}']);
        // send [ '(', 'footnote', null,       ( copy meta ), ]
        // send [ '(', 'url',      null,       ( copy meta ), ]
        // send [ '.', 'text',     last_href,  ( copy meta ), ]
        // send [ '.', 'p',        null,       ( copy meta ), ]
        // send [ ')', 'url',      null,       ( copy meta ), ]
        // send [ ')', 'footnote', null,       ( copy meta ), ]
        send(['(', 'footnote', null, copy(meta)]);
        send(['!', 'url', [last_href], copy(meta)]);
        send(['.', 'p', null, copy(meta)]);
        send([')', 'footnote', null, copy(meta)]);
        cache.length = 0;
        last_href = null;
        send(stamp(event));
      //.......................................................................................................
      } else if (cache.length > 0 && select(event, ')', 'document')) {
        send(['.', 'warning', "missing closing region 'link'", copy(meta)]);
        for (j = 0, len1 = cache.length; j < len1; j++) {
          cached_event = cache[j];
          send(cached_event);
        }
        send(event);
      //.......................................................................................................
      } else if (within_link) {
        cache.push(event);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.INLINE.$url = (S) => {
    var buffer, track;
    track = MD_READER.TRACKER.new_tracker('(url)');
    buffer = [];
    //.........................................................................................................
    return $((event, send) => {
      var meta, name, text, type, within_url;
      within_url = track.within('(url)');
      track(event);
      [type, name, text, meta] = event;
      //.......................................................................................................
      if (select(event, '(', 'url')) {
        return send(stamp(hide(copy(event))));
      //.......................................................................................................
      } else if (select(event, ')', 'url')) {
        send(['!', 'url', [buffer.join('')], copy(meta)]);
        buffer.length = 0;
        return send(stamp(hide(copy(event))));
      //.......................................................................................................
      } else if (within_url && select(event, '.', 'text')) {
        return buffer.push(text);
      //.......................................................................................................
      } else if (within_url) {
        return send(['.', 'warning', `ignoring non-text event inside \`(url)\`: ${rpr(event)}`]);
      } else {
        //.......................................................................................................
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.COMMAND.$url = (S) => {
    //.........................................................................................................
    return $((event, send) => {
      var fragment, fragments, i, idx, last_idx, len, meta, name, parameters, segment, slashes, type, url;
      //.......................................................................................................
      if (select(event, '!', 'url')) {
        [type, name, parameters, meta] = event;
        send(stamp(event));
        [url] = parameters;
        if (url == null) {
          return send(['.', 'warning', "missing required argument for `<<!url>>`", copy(meta)]);
        }
        //.....................................................................................................
        /* TAINT sort-of code duplication with inline code */
        fragments = LINEBREAKER.fragmentize(url);
        last_idx = fragments.length - 1;
        //.....................................................................................................
        send(['tex', "{\\mktsStyleUrl{}"]);
//.....................................................................................................
        for (idx = i = 0, len = fragments.length; i < len; idx = ++i) {
          fragment = fragments[idx];
          [segment, slashes] = fragment.split(/(\/+)$/);
          send(['.', 'text', segment, copy(meta)]);
          if (slashes != null) {
            slashes = '\\g' + (Array.from(slashes)).join('\\g');
            send(['tex', slashes]);
          }
          send(['tex', "\\allowbreak{}"]);
        }
        //.....................................................................................................
        send(['tex', "}"]);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @MKTX.COMMAND.$url = ( S ) =>
  //   #.........................................................................................................
  //   return $ ( event, send ) =>
  //     #.......................................................................................................
  //     if select event, '!', 'url'
  //       [ type, name, parameters, meta, ] = event
  //       send stamp event
  //       [ url, ] = parameters
  //       unless url?
  //         return send [ '.', 'warning', "missing required argument for `<<!url>>`", ( copy meta ), ]
  //       #.....................................................................................................
  //       fragments = LINEBREAKER.fragmentize url
  //       last_idx  = fragments.length - 1
  //       for fragment, idx in fragments
  //         unless idx is last_idx
  //           if      fragment.endsWith '//' then fragment = fragment[ .. fragment.length - 3 ] + "\\g/\\g/"
  //           else if fragment.endsWith '/'  then fragment = fragment[ .. fragment.length - 2 ] + "\\g/"
  //         fragments[ idx ] = fragment
  //       url_tex = fragments.join "\\g\\allowbreak{}"
  //       send [ 'tex', "{\\mktsStyleUrl{}", ]
  //       send [ 'tex', url_tex, ]
  //       send [ 'tex', "}", ]
  //     #.......................................................................................................
  //     else
  //       send event

  //===========================================================================================================
  // CLEANUP
  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.CLEANUP.$remove_empty_texts = function(S) {
    var remark;
    remark = MD_READER._get_remark();
    return $((event, send) => {
      var meta, name, text, type;
      if (select(event, '.', 'text')) {
        [type, name, text, meta] = event;
        if (text === '') {
          /* remain silent to make output an easier read */
          null;
          return send(remark('drop', "empty text", copy(meta)));
        } else {
          return send(event);
        }
      } else {
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.CLEANUP.$consolidate_texts = function(S) {
    var collector, first_meta;
    // remark      = MD_READER._get_remark()
    collector = [];
    first_meta = null;
    return $((event, send) => {
      var meta, name, text, type;
      if (select(event, '.', 'text')) {
        [type, name, text, meta] = event;
        if (first_meta == null) {
          first_meta = meta;
        }
        return collector.push(text);
      } else {
        // debug '83726', collector
        if (collector.length > 0) {
          send(['.', 'text', collector.join(''), copy(first_meta)]);
          first_meta = null;
          collector.length = 0;
        }
        return send(event);
      }
    });
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @MKTX.CLEANUP.$drop_empty_p_tags = ( S ) =>
  //   ### TAINT emptyness of  `p` tags ist tested for by counting intermittend `text` events; however, a
  //   paragraph could conceivably also consist of e.g. a single image. ###
  //   text_count  = 0
  //   remark      = MD_READER._get_remark()
  //   #.........................................................................................................
  //   warn "not using `$drop_empty_p_tags` at the moment"
  //   return $ ( event, send ) =>
  //     send event
  // #.........................................................................................................
  // return $ ( event, send ) =>
  //   #.......................................................................................................
  //   ### TAINT bogus selector ###
  //   if select event, [ ')', ]
  //     text_count = 0
  //     send event
  //   #.......................................................................................................
  //   else if select event, '.', 'text'
  //     text_count += +1
  //     send event
  //   #.......................................................................................................
  //   else if select event, '.', 'p'
  //     if text_count > 0
  //       send event
  //     else
  //       [ _, _, _, meta, ] = event
  //       send remark 'drop', "empty `.p`", copy meta
  //     text_count = 0
  //   #.......................................................................................................
  //   else
  //     send event

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.REGION.$correct_p_tags_before_regions = (S) => {
    var last_was_begin_document, last_was_p, remark;
    last_was_p = false;
    last_was_begin_document = false;
    remark = MD_READER._get_remark();
    //.........................................................................................................
    return $((event, send) => {
      var meta;
      // debug '©MwBAv', event
      //.......................................................................................................
      if (select(event, 'tex')) {
        return send(event);
      //.......................................................................................................
      } else if (select(event, '(', 'document')) {
        // debug '©---1', last_was_begin_document
        // debug '©---2', last_was_p
        last_was_p = false;
        last_was_begin_document = true;
        return send(event);
      //.......................................................................................................
      } else if (select(event, '.', 'p')) {
        // debug '©---3', last_was_begin_document
        // debug '©---4', last_was_p
        last_was_p = true;
        last_was_begin_document = false;
        return send(event);
      //.......................................................................................................
      } else if (select(event, ['('])) {
        // debug '©---5', last_was_begin_document
        // debug '©---6', last_was_p
        if ((!last_was_begin_document) && (!last_was_p)) {
          [meta] = slice.call(event, -1);
          // send stamp [ '#', 'insert', my_badge, "inserting `.p` tag", ( copy meta ), ]
          send(remark('insert', "`.p` because region or block opens", copy(meta)));
          send(['.', 'p', null, copy(meta)]);
        }
        send(event);
        last_was_p = false;
        return last_was_begin_document = false;
      } else {
        //.......................................................................................................
        last_was_p = false;
        last_was_begin_document = false;
        return send(event);
      }
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.$show_unhandled_tags = (S) => {
    return $((event, send) => {
      /* TAINT selection could be simpler, less repetitive */
      var event_txt, meta, name, text, type;
      [type, name, text, meta] = event;
      if ((type === 'tex') || select(event, '.', ['text', 'raw'])) {
        return send(event);
      } else if ((!is_stamped(event)) && (type !== '~') && (!select(event, '.', 'warning'))) {
        // debug '©04210', JSON.stringify event
        // if text?
        //   if ( CND.isa_pod text )
        //     if ( Object.keys text ).length is 0
        //       text = ''
        //     else
        //       text = rpr text
        // else
        //   text = ''
        // if type in [ '.', '!', ] or type in MKTS.MD_READER.FENCES.left
        //   first             = type
        //   last              = name
        // else
        //   first             = name
        //   last              = type
        // event_txt         = first + last + ' ' + text
        event_txt = `unhandled event: ${JSON.stringify(event, null, ' ')}`;
        warn(event_txt);
        return send(['.', 'warning', event_txt, copy(meta)]);
      } else {
        // send stamp hide copy event
        return send(event);
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.$format_warnings = (S) => {
    var self;
    self = this;
    return $async((event, done) => {
      var meta, name, text, type;
      /* TAINT this makes clear why we should not use '.' as type here; `warning` is a meta-event, not
      primarily a formatting instruction */
      //.......................................................................................................
      if (select(event, '.', 'warning')) {
        [type, name, text, meta] = event;
        step(function*(resume) {
          var message, message_event, message_tex;
          message = (yield self.MKTX.TYPOFIX.fix_typography_for_tex(S, text, resume));
          message_tex = `\\begin{mktsEnvWarning}${message}\\end{mktsEnvWarning}`;
          message_event = ['.', Σ_formatted_warning, message_tex, copy(meta)];
          return done(message_event);
        });
      } else {
        //.......................................................................................................
        done(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.MKTX.$show_warnings = (S) => {
    var warnings;
    warnings = [];
    return $((event, send) => {
      var _, i, len, message_tex, meta, tex_event;
      //.......................................................................................................
      if (select(event, '.', Σ_formatted_warning)) {
        [_, _, message_tex, meta] = event;
        tex_event = ['tex', message_tex];
        warnings.push(tex_event);
        send(tex_event);
      //.......................................................................................................
      } else if (select(event, ')', 'document')) {
        if (warnings.length > 0) {
          for (i = 0, len = warnings.length; i < len; i++) {
            tex_event = warnings[i];
            send(tex_event);
            send(['tex', "\n\n"]);
          }
          send(event);
        }
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.$filter_tex = function(S) {
    /* TAINT reduce number of event types, shapes to simplify this */
    return $((event, send) => {
      var meta, name, text, type;
      [type, name, text, meta] = event;
      if (type === 'tex') {
        return send(event[1]);
      } else if (select(event, '.', ['text', 'raw'])) {
        return send(event[2]);
      } else if ((meta != null ? meta['tex'] : void 0) === 'pass-through') {
        // debug '82341', event
        return send(event);
      } else if (!((type === '~') || (is_stamped(event)))) {
        warn(`unhandled event: ${JSON.stringify(event)}`);
        return send.error(new Error(`unhandled events not allowed at this point; got ${JSON.stringify(event)}`));
      }
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$show_events = function(S) {
    return D.$observe((event) => {
      return whisper(JSON.stringify(event));
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$add_text_locators = function(S) {
    var column_stack, event, matches, stack;
    stack = [];
    event = null;
    column_stack = [1];
    matches = function(type, name) {
      return MD_READER.select(event, type, name, true);
    };
    return D.$observe((_event) => {
      var column_count, meta, name, parameter, text, type;
      event = _event;
      [type, name, text, meta] = event;
      if (matches(['~', 'tex'])) {
        return;
      }
      //.......................................................................................................
      if (matches(['(', '!'], ['multi-columns', 'columns'])) {
        if ((parameter = event[2][0]) === 'pop') {
          column_stack.pop();
        } else {
          column_stack.push(parameter);
        }
      //.......................................................................................................
      } else if (matches(['(', '!'], ['multi-columns', 'columns'])) {
        column_stack.pop();
      //.......................................................................................................
      } else if (matches('(')) {
        if (name !== 'document' && name !== 'COLUMNS/group') {
          stack.push(name);
        }
      //.......................................................................................................
      } else if (matches(')')) {
        if (name !== 'document') {
          stack.pop();
        }
      //.......................................................................................................
      } else if (matches('.', 'text')) {
        column_count = column_stack[column_stack.length - 1];
        meta.locator = ['c' + (rpr(column_count)), ...stack].join('/');
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$show_text_locators = function(S) {
    return D.$observe((event) => {
      var meta, name, ref, text, type;
      if (select(event, '.', 'text')) {
        [type, name, text, meta] = event;
        help(CND.grey('22311'), (CND.lime((ref = meta.locator) != null ? ref : '????????????')) + ' ' + (CND.white(rpr(text))));
      }
      //.......................................................................................................
      return null;
    });
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.create_tex_write_tee = function(S) {
    var R, pipeline, plugin, plugins_tee, readstream, settings, writestream;
    /* TAINT get state via return value of MKTS.create_mdreadstream */
    /* TAINT make execution of `$produce_mktscript` a matter of settings */
    //.......................................................................................................
    readstream = D.create_throughstream();
    writestream = D.create_throughstream();
    // mktscript_in  = D.create_throughstream()
    // mktscript_out = D.create_throughstream()
    //.......................................................................................................
    /* TAINT need a file to write MKTScript text events to; must still send on incoming events */
    // mktscript_in
    //   .pipe MKTSCRIPT_WRITER.$produce_mktscript             S
    //   .pipe mktscript_out
    // mktscript_tee = D.TEE.from_readwritestreams mktscript_in, mktscript_out
    //.......................................................................................................
    pipeline = (function() {
      var i, len, ref, results;
      ref = MK.TS.plugins;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        plugin = ref[i];
        results.push(plugin.$main(S));
      }
      return results;
    })();
    // plugins_tee = D.TEE.from_pipeline pipeline
    plugins_tee = D.combine(pipeline);
    //.......................................................................................................
    // .pipe D.$observe ( event ) -> info ( CND.grey '--------->' ), ( CND.blue event[ 0 ] + event[ 1 ] )
    // .pipe D.$observe ( event ) -> info '23993', ( CND.grey '--------->' ), jr event
    //.......................................................................................................
    // .pipe @MKTX.BLOCK.$hr                                   S
    // .pipe @MKTX.INLINE.$smallcaps                           S
    // .pipe @MKTX.INLINE.$em_and_strong                       S
    //.......................................................................................................
    // .pipe @$show_events                                     S
    // .pipe D.$observe ( event ) -> urge '44433', ( CND.grey '--------->' ), event
    // .pipe D.$show()
    //.......................................................................................................
    readstream.pipe(this.MKTX.SH.$spawn(S)).pipe(this.MKTX.CALL.$call_await(S)).pipe(this.MKTX.CALL.$call_stream(S)).pipe(this.MKTX.INLINE.$custom_entities(S)).pipe(plugins_tee).pipe(MACRO_ESCAPER.$expand.$remove_backslashes(S)).pipe(MKTSCRIPT_WRITER.$show_mktsmd_events(S)).pipe(MKTSCRIPT_WRITER.$produce_mktscript(S)).pipe(this.$document(S)).pipe(this.MKTX.INLINE.$box(S)).pipe(this.MKTX.BLOCK.$blockquote(S)).pipe(this.MKTX.INLINE.$link(S)).pipe(this.MKTX.MIXED.$footnote(S)).pipe(this.MKTX.MIXED.$footnote.$remove_extra_paragraphs(S)).pipe(this.MKTX.COMMAND.$new_page(S)).pipe(this.MKTX.COMMAND.$comment(S)).pipe(this.MKTX.MIXED.$table(S)).pipe(this.MKTX.COMMAND.$echo(S)).pipe(this.MKTX.BLOCK.$hr2(S)).pipe(this.MKTX.BLOCK.$nl(S)).pipe(this.MKTX.REGION.$code(S)).pipe(this.MKTX.REGION.$keep_lines(S)).pipe(this.MKTX.REGION.$toc(S)).pipe(this.MKTX.BLOCK.$heading(S)).pipe(this.MKTX.MIXED.$collect_headings_for_toc(S)).pipe(this.MKTX.COMMAND.$toc(S)).pipe(this.MKTX.BLOCK.$unordered_list(S)).pipe(this.MKTX.INLINE.$code_span(S)).pipe(this.MKTX.INLINE.$url(S)).pipe(this.MKTX.COMMAND.$url(S)).pipe(this.MKTX.INLINE.$super_and_subscript(S)).pipe(this.MKTX.INLINE.$translate_i_and_b(S)).pipe(this.MKTX.INLINE.$em_strong_and_smallcaps(S)).pipe(this.MKTX.INLINE.$image(S)).pipe(this.MKTX.BLOCK.$yadda(S)).pipe(this.MKTX.BLOCK.$paragraph_1(S)).pipe(this.MKTX.MIXED.$raw(S)).pipe(this.COLUMNS.$main(S)).pipe(this.$add_text_locators(S)).pipe(MACRO_INTERPRETER.$capture_change_events(S)).pipe(this.MKTX.CLEANUP.$remove_empty_texts(S)).pipe(this.MKTX.CLEANUP.$consolidate_texts(S)).pipe(this.$show_text_locators(S)).pipe(this.MKTX.BLOCK.$paragraph_2(S)).pipe(this.MKTX.COMMAND.$crossrefs(S)).pipe(this.MKTX.TYPOFIX.$fix_typography_for_tex(S)).pipe((() => {
      S.event_count = 0;
      return D.$observe((event) => {
        return S.event_count += +1;
      });
    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    // ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?
    })()).pipe(this.MKTX.INLINE.$mark(S)).pipe(this.MKTX.$show_unhandled_tags(S)).pipe(this.MKTX.$format_warnings(S)).pipe(this.MKTX.$show_warnings(S)).pipe(this.$filter_tex(S)).pipe(this.COLUMNS.$XXX_transform_pretex_to_tex(S)).pipe(MD_READER.$show_illegal_chrs(S)).pipe(writestream);
    //.......................................................................................................
    settings = {
      // inputs:
      //   mktscript:        mktscript_in
      // outputs:
      //   mktscript:        mktscript_out
      S: S
    };
    //.......................................................................................................
    R = D.TEE.from_readwritestreams(readstream, writestream, settings);
    if (S['tees'] == null) {
      S['tees'] = {};
    }
    S['tees']['tex-writer'] = R;
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._handle_error = (error) => {
    var ref, stack;
    alert(error['message']);
    stack = (ref = error['stack']) != null ? ref : "(no stacktrace available)";
    whisper('\n' + (stack.split('\n')).slice(0, 11).join('\n'));
    whisper('...');
    return process.exit(1);
  };

  //===========================================================================================================
  // PDF FROM MD
  //-----------------------------------------------------------------------------------------------------------
  this.pdf_from_md = function(source_route, handler) {
    /* TAINT code duplication */
    /* TAIN only works with docs in the filesystem, not with literal texts */
    var f, self;
    self = this;
    //---------------------------------------------------------------------------------------------------------
    f = () => {
      return step(function*(resume) {
        var S, content_locator, file_output, layout_info, md_input, md_output, md_readstream, md_source, source_locator, tex_input, tex_output, tex_writestream;
        // handler                ?= ->
        layout_info = HELPERS.new_layout_info(self.options, source_route);
        yield self.write_mkts_master(layout_info, resume);
        source_locator = layout_info['source-locator'];
        content_locator = layout_info['content-locator'];
        file_output = njs_fs.createWriteStream(content_locator);
        //.......................................................................................................
        file_output.on('close', () => {
          return HELPERS.write_pdf(layout_info, (error) => {
            var chr_count_txt, chrs_per_s_txt, dt_s, dt_s_txt, event_count_txt, events_per_s_txt;
            if (error != null) {
              throw error;
            }
            S.t1 = +new Date();
            dt_s = (S.t1 - S.t0) / 1000;
            dt_s_txt = dt_s.toFixed(3);
            chrs_per_s_txt = (S.chr_count / dt_s).toFixed(3);
            events_per_s_txt = (S.event_count / dt_s).toFixed(3);
            chr_count_txt = ƒ(S.chr_count);
            event_count_txt = ƒ(S.event_count);
            help(`${TEXT.flush_right(chr_count_txt, 10)}       chrs (approx.)`);
            help(`${TEXT.flush_right(event_count_txt, 10)}     events (approx.)`);
            help(`${TEXT.flush_right(dt_s_txt, 14)}          s`);
            help(`${TEXT.flush_right(chrs_per_s_txt, 14)}   chrs / s`);
            help(`${TEXT.flush_right(events_per_s_txt, 14)} events / s`);
            if (handler != null) {
              // debug '49984', S.aux
              return handler(null);
            }
          });
        });
        //.......................................................................................................
        /* TAINT use method to produce new state */
        S = {
          options: self.options,
          layout_info: layout_info,
          paragraph_nr: 0
        };
        //.......................................................................................................
        /* TAINT should read MD source stream */
        md_source = njs_fs.readFileSync(source_locator, {
          encoding: 'utf-8'
        });
        md_readstream = MD_READER.create_md_read_tee(S, md_source);
        tex_writestream = self.create_tex_write_tee(S);
        md_input = md_readstream.tee['input'];
        md_output = md_readstream.tee['output'];
        tex_input = tex_writestream.tee['input'];
        tex_output = tex_writestream.tee['output'];
        //.......................................................................................................
        // S.aux                   = yield AUX.fetch_aux_data S, resume
        S.resend = md_readstream.tee['S'].resend;
        //.......................................................................................................
        md_output.pipe(tex_input);
        // .pipe $ ( event, send ) =>
        //   debug '33376', rpr event
        //   send event
        //   if event?
        //     send event
        //   if end?
        //     end() # setTimeout end, 1000
        tex_output.pipe(file_output);
        //.......................................................................................................
        return md_input.resume();
      });
    };
    //---------------------------------------------------------------------------------------------------------
    return D.run(f, this._handle_error);
  };

  //===========================================================================================================
  // TEX FROM MD
  //-----------------------------------------------------------------------------------------------------------
  this.tex_from_md = function(md_source, settings, handler) {
    /* TAINT code duplication */
    var $collect_and_call, S, arity, layout_info, md_input, md_output, md_readstream, ref, ref1, source_route, tex_input, tex_output, tex_writestream;
    switch (arity = arguments.length) {
      case 2:
        handler = settings;
        settings = {};
        break;
      case 3:
        null;
        break;
      default:
        throw new Error(`expected 2 or 3 arguments, got ${arity}`);
    }
    //.........................................................................................................
    $collect_and_call = (handler) => {
      var Z;
      Z = [];
      return $((event, send, end) => {
        if (event != null) {
          Z.push(event);
        }
        if (end != null) {
          handler(null, Z.join(''));
          return end();
        }
      });
    };
    //.........................................................................................................
    source_route = (ref = settings['source-route']) != null ? ref : '<STRING>';
    layout_info = HELPERS.new_layout_info(this.options, source_route, false);
    //.........................................................................................................
    /* TAINT use method to produce new state */
    S = {
      options: this.options,
      layout_info: layout_info,
      bare: (ref1 = settings['bare']) != null ? ref1 : false,
      paragraph_nr: 0
    };
    //.........................................................................................................
    md_readstream = MD_READER.create_md_read_tee(md_source);
    tex_writestream = this.create_tex_write_tee(S);
    md_input = md_readstream.tee['input'];
    md_output = md_readstream.tee['output'];
    tex_input = tex_writestream.tee['input'];
    tex_output = tex_writestream.tee['output'];
    //.........................................................................................................
    S.aux = this.AUX.read_auxfile(S);
    debug(S.aux);
    xxx;
    S.resend = md_readstream.tee['S'].resend;
    //.........................................................................................................
    md_output.pipe(tex_input);
    tex_output.pipe(D.$show('>>>>>>>>>>>>>>>>>>')).pipe($collect_and_call(handler));
    //.........................................................................................................
    D.run((() => {
      return md_input.resume();
    }), this._handle_error);
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    // @pdf_from_md 'texts/A-Permuted-Index-of-Chinese-Characters/index.md'
    this.pdf_from_md('texts/demo');
  }

  // debug '©nL12s', MKTS.as_tex_text '亻龵helo さしすサシス 臺灣國語Ⓒ, Ⓙ, Ⓣ𠀤𠁥&jzr#e202;'
// debug '©nL12s', MKTS.as_tex_text 'helo さし'
// event = [ '(', 'single-column', ]
// event = [ ')', 'single-column', ]
// event = [ '(', 'new-page', ]
// debug '©Gpn1J', select event, [ '(', ')'], [ 'single-column', 'new-page', ]

}).call(this);

//# sourceMappingURL=tex-writer.js.map
