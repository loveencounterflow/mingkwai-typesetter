// Generated by CoffeeScript 1.10.0

/*

{\latin{}a}{\latin{}g}{\latin{}f}{\latin{}i}{\latin{} }{\cjk{}{\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}}}{\cjk{}{\cn{}里}}{\cjk{}{\cnxb{}{\cnxJzr{}}}}{\latin{} }{\cjk{}{\cn{}里}}{\cjk{}{\cnxa{}䊷}}{\mktsRsgFb{}இ}{\latin{} }{\latin{}a}{\latin{}g}{\latin{}f}{\latin{}i}

agfi {\cjk{}\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}里{\cnxb{}\cnxJzr{}} 里{\cnxa{}䊷}}{\mktsRsgFb{}இ} agfi

agfi {\cjk{}\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}里\cnxb{}\cnxJzr{}\cn 里\cnxa{}䊷}{\mktsRsgFb{}இ} agfi
 */


/*

typofix v1:
{\cjk{}{\cn{}里}{\cn{}里}{\cn\cnxa{}䊷}{\cn\cnxa{}䊷}{\cn{}里}{\cn{}里}{\cn{}里}{\cn{}里}{\cn{}里}}\\

typofix v2:
{\cjk{}{\cn{}里里}{\cnxa{}䊷䊷}{\cn{}里里里里里}}

typofix v2 intermediate:
{\CJK{}{\CN{}里里}{\CNXA{}䊷䊷}{\CN{}里里里里里}}
 */

(function() {
  var $, CND, D, MD_READER, MKNCR, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, rpr, select, stamp, urge, warn, whisper, Σ_glyph_description,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'mkts/tex-writer-typofix';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('../../../pipedreams');

  $ = D.$;

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  MKNCR = require('../../mingkwai-ncr');

  Σ_glyph_description = Symbol('glyph-description');

  this.$format_tex_specials = function(S) {

    /* TAINT should preserve raw text from before replacements */
    return $((function(_this) {
      return function(event, send) {
        var description, meta, name, rsg, type, uchr;
        if (!select(event, '.', Σ_glyph_description)) {
          return send(event);
        }
        type = event[0], name = event[1], description = event[2], meta = event[3];
        uchr = description.uchr, rsg = description.rsg;
        if (rsg !== 'u-latn') {
          return send(event);
        }
        switch (uchr) {
          case '\\':
            return send(['tex', '\\textbackslash{}']);
          case '{':
            return send(['tex', '\\{']);
          case '}':
            return send(['tex', '\\}']);
          case '$':
            return send(['tex', '\\$']);
          case '#':
            return send(['tex', '\\#']);
          case '%':
            return send(['tex', '\\%']);
          case '_':
            return send(['tex', '\\_']);
          case '^':
            return send(['tex', '\\textasciicircum{}']);
          case '~':
            return send(['tex', '\\textasciitilde{}']);
          case '&':
            return send(['tex', '\\&']);
        }
        return send(event);
      };
    })(this));
  };

  this.$format_cjk = function(S) {

    /* TAINT should preserve raw text from before replacements */

    /* TAINT must look for stream end */

    /* TAINT use piped streams for logic */
    var _send, cjk_collector, flush, last_texcmd_block;
    cjk_collector = [];
    _send = null;
    last_texcmd_block = null;

    /* TAINT code duplication */
    flush = (function(_this) {
      return function() {
        var tex;
        if (!(cjk_collector.length > 0)) {
          return;
        }
        if (last_texcmd_block != null) {
          cjk_collector.push("}");
        }
        cjk_collector.push("}");

        /* TAINT that `\\cjk{}` part should come from the MKNCR Unicode InterSkipList */

        /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
        tex = "{\\cjk{}" + cjk_collector.join('');

        /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
        last_texcmd_block = null;
        cjk_collector.length = 0;
        _send(['tex', tex]);
        return null;
      };
    })(this);
    return $('null', (function(_this) {
      return function(event, send) {
        var description, is_cjk, meta, name, rsg, tag, tex, texcmd, texcmd_block, texcmd_cp, type, uchr;
        _send = send;
        if (event != null) {
          if (select(event, '.', Σ_glyph_description)) {
            type = event[0], name = event[1], description = event[2], meta = event[3];
            uchr = description.uchr, rsg = description.rsg, tag = description.tag, texcmd = description.tex;
            texcmd_block = texcmd.block, texcmd_cp = texcmd.codepoint;

            /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

            /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
            is_cjk = indexOf.call(tag, 'cjk') >= 0;
            if (is_cjk) {
              if (last_texcmd_block !== texcmd_block) {

                /* close previous open TeX block command, if any: */
                if (last_texcmd_block != null) {
                  cjk_collector.push('}');
                }
                cjk_collector.push('{');
                cjk_collector.push(texcmd_block);
                last_texcmd_block = texcmd_block;
              }
              tex = texcmd_cp;
              if (tex == null) {
                tex = uchr;
              }
              cjk_collector.push(tex);
            } else {
              flush();
              send(event);
            }
          } else {
            flush();
            send(event);
          }
        } else {
          flush();
        }
        return null;
      };
    })(this));
  };

  this.$split = function(S) {
    return $((function(_this) {
      return function(event, send) {
        var glyph, i, len, meta, name, ref, text, type;
        if (!select(event, '.', 'text')) {
          return send(event);
        }
        type = event[0], name = event[1], text = event[2], meta = event[3];
        ref = MKNCR.chrs_from_text(text);
        for (i = 0, len = ref.length; i < len; i++) {
          glyph = ref[i];
          send(['.', Σ_glyph_description, glyph, meta]);
        }
        return null;
      };
    })(this));
  };

  this.$wrap_as_glyph_description = function(S) {
    return $((function(_this) {
      return function(event, send) {
        var description, glyph, meta, name, type;
        if (!select(event, '.', Σ_glyph_description)) {
          return send(event);
        }
        type = event[0], name = event[1], glyph = event[2], meta = event[3];
        description = MKNCR.describe(glyph);
        send([type, name, description, meta]);
        return null;
      };
    })(this));
  };

  this.$consolidate_tex_events = function(S) {
    var _send, collector, flush;
    collector = [];
    _send = null;
    flush = (function(_this) {
      return function() {
        var tex;
        if (!(collector.length > 0)) {
          return;
        }
        tex = collector.join('');
        collector.length = 0;
        _send(['tex', tex]);
        return null;
      };
    })(this);
    return $('null', (function(_this) {
      return function(event, send) {
        var _, tex;
        _send = send;
        if (event != null) {
          if (select(event, 'tex')) {
            _ = event[0], tex = event[1];
            return collector.push(tex);
          } else {
            flush();
            return send(event);
          }
        } else {
          return flush();
        }
      };
    })(this));
  };

  this.$unwrap_glyph_description = function(S) {
    return $((function(_this) {
      return function(event, send) {
        var description, glyph, meta, name, type;
        if (!select(event, '.', Σ_glyph_description)) {
          return send(event);
        }
        type = event[0], name = event[1], description = event[2], meta = event[3];
        glyph = description['uchr'];

        /* TAINT send `tex` or `text` event? */
        send(['tex', glyph]);
        return null;
      };
    })(this));
  };

  this.$fix_typography_for_tex = function(S) {

    /* TAINT which one should come first? */
    var pipeline;
    pipeline = [
      this.$split(S), this.$wrap_as_glyph_description(S), this.$format_cjk(S), this.$format_tex_specials(S), this.$unwrap_glyph_description(S), this.$consolidate_tex_events(S), $(function(event) {
        if (select(event, 'tex')) {
          return help('65099', rpr(event[1]));
        }
      })
    ];
    return D.new_stream({
      pipeline: pipeline
    });
  };

}).call(this);

//# sourceMappingURL=tex-writer-typofix.js.map
