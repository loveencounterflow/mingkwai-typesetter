// Generated by CoffeeScript 1.10.0

/*

{\latin{}a}{\latin{}g}{\latin{}f}{\latin{}i}{\latin{} }{\cjk{}{\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}}}{\cjk{}{\cn{}里}}{\cjk{}{\cnxb{}{\cnxJzr{}}}}{\latin{} }{\cjk{}{\cn{}里}}{\cjk{}{\cnxa{}䊷}}{\mktsRsgFb{}இ}{\latin{} }{\latin{}a}{\latin{}g}{\latin{}f}{\latin{}i}

agfi {\cjk{}\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}里{\cnxb{}\cnxJzr{}} 里{\cnxa{}䊷}}{\mktsRsgFb{}இ} agfi

agfi {\cjk{}\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}里\cnxb{}\cnxJzr{}\cn 里\cnxa{}䊷}{\mktsRsgFb{}இ} agfi
 */


/*

typofix v1:
{\cjk{}{\cn{}里}{\cn{}里}{\cn\cnxa{}䊷}{\cn\cnxa{}䊷}{\cn{}里}{\cn{}里}{\cn{}里}{\cn{}里}{\cn{}里}}\\

typofix v2:
{\cjk{}{\cn{}里里}{\cnxa{}䊷䊷}{\cn{}里里里里里}}

typofix v2 intermediate:
{\CJK{}{\CN{}里里}{\CNXA{}䊷䊷}{\CN{}里里里里里}}
 */

(function() {
  var $, CND, D, MD_READER, MKNCR, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, rpr, select, stamp, urge, warn, whisper, Σ_glyph_description,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'mkts/tex-writer-typofix';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('../../../pipedreams');

  $ = D.$;

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  MKNCR = require('../../mingkwai-ncr');

  Σ_glyph_description = Symbol('glyph-description');

  this.$format_tex_specials = function(S) {

    /* TAINT should preserve raw text from before replacements */
    return $((function(_this) {
      return function(event, send) {
        var description, meta, name, rsg, type, uchr;
        if (!select(event, '.', Σ_glyph_description)) {
          return send(event);
        }
        type = event[0], name = event[1], description = event[2], meta = event[3];
        uchr = description.uchr, rsg = description.rsg;
        if (rsg !== 'u-latn') {
          return send(event);
        }
        switch (uchr) {
          case '\\':
            return send(['tex', '\\textbackslash{}']);
          case '{':
            return send(['tex', '\\{']);
          case '}':
            return send(['tex', '\\}']);
          case '$':
            return send(['tex', '\\$']);
          case '#':
            return send(['tex', '\\#']);
          case '%':
            return send(['tex', '\\%']);
          case '_':
            return send(['tex', '\\_']);
          case '^':
            return send(['tex', '\\textasciicircum{}']);
          case '~':
            return send(['tex', '\\textasciitilde{}']);
          case '&':
            return send(['tex', '\\&']);
        }
        return send(event);
      };
    })(this));
  };

  this.$format_cjk = function(S) {

    /* NOTE same pattern as in `$consolidate_tex_events` */

    /* TAINT should preserve raw text from before replacements */

    /* TAINT use piped streams for logic? */
    var cjk_collector, event, flush_and_send_event, last_texcmd_block, send;
    cjk_collector = [];
    send = null;
    event = null;
    last_texcmd_block = null;
    flush_and_send_event = (function(_this) {
      return function() {
        var tex;
        if (cjk_collector.length > 0) {
          if (last_texcmd_block != null) {
            cjk_collector.push("}");
          }
          cjk_collector.push("}");
          tex = "{\\cjk{}" + cjk_collector.join('');
          last_texcmd_block = null;
          cjk_collector.length = 0;
          send(['tex', tex]);
        }
        if (event != null) {
          send(event);
        }
        return null;
      };
    })(this);
    return $('null', (function(_this) {
      return function(_event, _send) {
        var description, is_cjk, meta, name, rsg, tag, tex, texcmd, texcmd_block, texcmd_cp, type, uchr;
        send = _send;
        event = _event;
        if (event == null) {
          return flush_and_send_event();
        }
        if (!select(event, '.', Σ_glyph_description)) {
          return flush_and_send_event();
        }
        type = event[0], name = event[1], description = event[2], meta = event[3];
        uchr = description.uchr, rsg = description.rsg, tag = description.tag, texcmd = description.tex;
        texcmd_block = texcmd.block, texcmd_cp = texcmd.codepoint;
        is_cjk = indexOf.call(tag, 'cjk') >= 0;
        if (!is_cjk) {
          return flush_and_send_event();
        }
        if (last_texcmd_block !== texcmd_block) {

          /* close previous open TeX block command, if any: */
          if (last_texcmd_block != null) {
            cjk_collector.push('}');
          }
          cjk_collector.push('{');
          cjk_collector.push(texcmd_block);
          last_texcmd_block = texcmd_block;
        }
        tex = texcmd_cp;
        if (tex == null) {
          tex = uchr;
        }
        cjk_collector.push(tex);
        return null;
      };
    })(this));
  };

  this.$split = function(S) {
    return $((function(_this) {
      return function(event, send) {
        var glyph, i, len, meta, name, ref, text, type;
        if (!select(event, '.', 'text')) {
          return send(event);
        }
        type = event[0], name = event[1], text = event[2], meta = event[3];
        ref = MKNCR.chrs_from_text(text);
        for (i = 0, len = ref.length; i < len; i++) {
          glyph = ref[i];
          send(['.', Σ_glyph_description, glyph, meta]);
        }
        return null;
      };
    })(this));
  };

  this.$wrap_as_glyph_description = function(S) {
    return $((function(_this) {
      return function(event, send) {
        var csg, description, glyph, i, len, meta, name, ref, sub_glyph, type;
        if (!select(event, '.', Σ_glyph_description)) {
          return send(event);
        }
        type = event[0], name = event[1], glyph = event[2], meta = event[3];
        description = MKNCR.describe(glyph);
        csg = description.csg;
        if (csg === 'u' || csg === 'jzr') {
          send([type, name, description, meta]);
        } else {

          /* NOTE In case the CSG is not an 'inner' one (either Unicode or Jizura), the glyph can only
          have been represented as an extended NCR (a string like `&morohashi#x12ab;`). In that case,
          we send all the constituent US-ASCII glyphs separately so the NCR will be rendered literally.
           */
          ref = Array.from(glyph);
          for (i = 0, len = ref.length; i < len; i++) {
            sub_glyph = ref[i];
            send([type, name, MKNCR.describe(sub_glyph), meta]);
          }
        }
        return null;
      };
    })(this));
  };

  this.$consolidate_tex_events = function(S) {

    /* NOTE same pattern as in `$format_cjk` */
    var collector, flush_and_send_event, send;
    collector = [];
    send = null;
    flush_and_send_event = (function(_this) {
      return function() {
        var tex;
        if (collector.length > 0) {
          tex = collector.join('');
          collector.length = 0;
          send(['tex', tex]);
        }
        if (typeof event !== "undefined" && event !== null) {
          send(event);
        }
        return null;
      };
    })(this);
    return $('null', (function(_this) {
      return function(_event, _send) {
        var _, event, tex;
        send = _send;
        event = _event;
        if (event == null) {
          return flush_and_send_event();
        }
        if (!select(event, 'tex')) {
          return flush_and_send_event();
        }
        _ = event[0], tex = event[1];
        collector.push(tex);
        return null;
      };
    })(this));
  };

  this.$unwrap_glyph_description = function(S) {
    return $((function(_this) {
      return function(event, send) {
        var description, glyph, meta, name, type;
        if (!select(event, '.', Σ_glyph_description)) {
          return send(event);
        }
        type = event[0], name = event[1], description = event[2], meta = event[3];
        glyph = description['uchr'];

        /* TAINT send `tex` or `text` event? */
        send(['tex', glyph]);
        return null;
      };
    })(this));
  };

  this.$fix_typography_for_tex = function(S) {
    var pipeline;
    pipeline = [this.$split(S), this.$wrap_as_glyph_description(S), this.$format_cjk(S), this.$format_tex_specials(S), this.$unwrap_glyph_description(S), this.$consolidate_tex_events(S)];
    return D.new_stream({
      pipeline: pipeline
    });
  };

  this.fix_typography_for_tex = function(S, text, handler) {
    var collector, input;
    collector = [];
    input = D.new_stream();
    input.pipe(this.$fix_typography_for_tex(S)).pipe($((function(_this) {
      return function(event) {
        var _, tex;
        if (!select(event, 'tex')) {
          return;
        }
        _ = event[0], tex = event[1];
        return collector.push(tex);
      };
    })(this))).pipe($('finish', (function(_this) {
      return function() {
        return handler(null, collector.join(''));
      };
    })(this)));
    D.send(input, ['.', 'text', text, {}]);
    D.end(input);
    return null;
  };

}).call(this);

//# sourceMappingURL=tex-writer-typofix.js.map
