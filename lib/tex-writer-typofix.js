// Generated by CoffeeScript 1.10.0
(function() {
  var $, CND, D, MD_READER, MKNCR, _X_, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, rpr, select, stamp, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'mkts/tex-writer-typofix';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.remit.bind(D);

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  MKNCR = require('../../mingkwai-ncr');

  this._tex_escape_replacements = [[/\x01/g, '\x01\x02'], [/\x5c/g, '\x01\x01'], [/\{/g, '\\{'], [/\}/g, '\\}'], [/\$/g, '\\$'], [/\#/g, '\\#'], [/%/g, '\\%'], [/_/g, '\\_'], [/\^/g, '\\textasciicircum{}'], [/~/g, '\\textasciitilde{}'], [/&/g, '\\&'], [/\x01\x01/g, '\\textbackslash{}'], [/\x01\x02/g, '\x01']];

  this.escape_for_tex = function(text) {
    var R, i, idx, len, pattern, ref, ref1, replacement;
    R = text;
    ref = this._tex_escape_replacements;
    for (idx = i = 0, len = ref.length; i < len; idx = ++i) {
      ref1 = ref[idx], pattern = ref1[0], replacement = ref1[1];
      R = R.replace(pattern, replacement);
    }
    return R;
  };

  this.$fix_typography_for_tex = function(S) {
    return $((function(_this) {
      return function(event, send) {
        var meta, name, ref, style, text, type;
        if (select(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          meta['raw'] = text;
          style = (ref = meta['typofix']) != null ? ref : 'basic';
          text = _this.fix_typography_for_tex(text, S.options, null, style);
          return send([type, name, text, meta]);
        } else {
          return send(event);
        }
      };
    })(this));
  };

  this._analyze_chr = function(S, chr, style, is_last) {
    var R, input;
    input = style === 'escape-ncrs' ? 'plain' : 'xncr';
    R = MKNCR.describe(chr, {
      input: input
    });
    debug('33002', style, input, R.rsg, rpr(chr), rpr(R.uchr));
    switch (R.rsg) {
      case 'jzr':
      case 'jzr-fig':
        R.chr = R.uchr;
        break;
      case 'u-pua':
        R.rsg = 'jzr-fig';
        break;
      case 'u-latn':
        R.chr = this.escape_for_tex(chr);
        break;
      default:
        R.chr = this.escape_for_tex(chr);
        if (R.tex == null) {
          R.tex = {};
        }
        R.tex.block = '\\latin';
    }

    /* OBS `chr` has still the value this method was called with, so styling should work even for `u-latn`
    characters
     */
    R.is_whitespace = indexOf.call(R.tag, 'ascii-whitespace') >= 0;
    if (R.is_whitespace) {
      R.is_cjk = null;
    } else {
      R.is_cjk = indexOf.call(R.tag, 'cjk') >= 0;
    }
    return R;
  };

  this._style_chr = function(S, chr_info, chr, is_last) {

    /* TAINT parts of this code will be replaced by `mingkwai-ncr.glyph_style_as_tex` */
    var R, csg, fncr, is_cjk, message, ref, rsg, rsg_command, style;
    csg = chr_info.csg, rsg = chr_info.rsg, fncr = chr_info.fncr, is_cjk = chr_info.is_cjk;
    if (csg !== 'u' && csg !== 'jzr') {

      /* TAINT won't capture styling for `&`, `#` and so on */
      return this.escape_for_tex(chr_info.chr);
    }
    if (typeof rsg_command === "undefined" || rsg_command === null) {
      rsg_command = (ref = S.tex_command_by_rsgs['fallback']) != null ? ref : null;
      message = "unknown RSG " + (rpr(rsg)) + ": " + fncr + " " + chr + " (using fallback " + (rpr(rsg_command)) + ")";
      if (S.send != null) {
        S.send(remark('warn', message, {}));
      } else {
        warn(message);
      }
    }
    if (rsg_command === 'latin') {
      rsg_command = null;
    }
    style = S.glyph_styles[chr];
    if (style != null) {
      null;
    } else if (rsg_command != null) {

      /* TAINT does not collect glyphs with same RSG */
      if (is_cjk && rsg_command !== 'cn') {
        R = "{\\cn\\" + rsg_command + "{}" + chr_info['uchr'] + "}";
      } else {
        R = "{\\" + rsg_command + "{}" + chr_info['uchr'] + "}";
      }
    } else {
      R = null;
    }
    S.last_rsg_command = rsg_command;
    return R;
  };

  this._move_whitespace = function(S) {
    var ref;
    (ref = S.collector).splice.apply(ref, [S.collector.length, 0].concat(slice.call(S.ws_collector)));
    S.ws_collector.length = 0;
    return null;
  };

  this._push = function(S, chr, postpone_ws) {
    if (postpone_ws == null) {
      postpone_ws = false;
    }
    if (!postpone_ws) {
      this._move_whitespace(S);
    }
    if (chr != null) {
      S.collector.push(chr);
    }
    if (postpone_ws) {
      this._move_whitespace(S);
    }
    S.has_cjk_glue = false;
    return null;
  };

  this._push_whitespace = function(S, chr) {
    S.ws_collector.push(chr);
    return null;
  };

  this._split_dangling_ws = function(text) {
    var _, head, ref, tail;
    ref = text.match(this._split_dangling_ws.pattern), _ = ref[0], head = ref[1], tail = ref[2];
    return [head, tail];
  };

  this._split_dangling_ws.pattern = /^([\s\S]*?)([\x20\t\n]*)$/;

  this.fix_typography_for_tex = function(text, options, send, style) {
    var S, chr, chr_idx, chrs, cid, csg, dangling_ws, description, glyph, i, is_cjk, last_idx, len, open_bracket_count, ref, ref1, ref2, ref3, ref4, ref5, ref6, tex, tex_block, tex_codepoint;
    if (send == null) {
      send = null;
    }
    S = {
      ws_collector: [],
      collector: [],
      whitespace: '\x20\n\r\t',
      this_is_cjk: false,
      last_was_cjk: false,
      last_rsg_command: null,
      R: null
    };
    ref = this._split_dangling_ws(text), text = ref[0], dangling_ws = ref[1];
    chrs = MKNCR.chrs_from_text(text);
    last_idx = chrs.length - 1;
    open_bracket_count = 0;
    for (chr_idx = i = 0, len = chrs.length; i < len; chr_idx = ++i) {
      chr = chrs[chr_idx];
      description = this._analyze_chr(S, chr, style, chr_idx === last_idx);
      glyph = description.chr, is_cjk = description.is_cjk, csg = description.csg, cid = description.cid, tex = description.tex;
      tex_block = (ref1 = tex != null ? tex['block'] : void 0) != null ? ref1 : null;
      tex_codepoint = (ref2 = tex != null ? tex['codepoint'] : void 0) != null ? ref2 : null;
      debug('79011', (ref3 = (ref4 = description['tex']) != null ? ref4['block'] : void 0) != null ? ref3 : '', (ref5 = (ref6 = description['tex']) != null ? ref6['codepoint'] : void 0) != null ? ref5 : '', glyph);
      if (is_cjk) {
        open_bracket_count += +1;
        this._push(S, "{");
        this._push(S, "\\cjk");
        this._push(S, "{}");
      }
      if (tex_block != null) {
        open_bracket_count += +1;
        this._push(S, "{");
        this._push(S, tex_block);
        this._push(S, "{}");
      }
      if (tex_codepoint != null) {
        this._push(S, tex_codepoint);
      } else {
        this._push(S, glyph);
      }
      while (open_bracket_count > 0) {
        open_bracket_count += -1;
        this._push(S, "}");
      }
    }
    return S.collector.join('');
  };

  _X_ = function() {

    /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

    /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

    /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

    /* Whitespace is ambiguous; it is treated as CJK when coming between two unambiguous CJK characters and
    as non-CJK otherwise; to decide between these cases, we have to wait for the next non-whitespace
    character:
     */
    if (description.is_whitespace) {
      this._push_whitespace(S, chr);
    }
    S.last_was_cjk = S.this_is_cjk;
    S.this_is_cjk = description.is_cjk;

    /* In case we're entering a region of CJK characters, we have to start a group and issue a `\cjk`
    command; before we do that, any cached whitespace will be moved into the result. If we're leaving a
    CJK region, the group must be closed first and followed by any cached whitespace:
     */
    if ((!S.last_was_cjk) && S.this_is_cjk) {
      this._push(S, "{\\cjk{}");
    } else if (S.last_was_cjk && (!S.this_is_cjk)) {
      this._push(S, "}", true);
    }
    if (description.styled_chr != null) {
      this._push(S, description.styled_chr);
    } else {
      this._push(S, description.chr);
    }

    /* TAINT here we should keep state across text chunks to decide on cases like
    `國 **b** 國` vs `國 **國** 國`
     */
    this._push(S);
    if (S.this_is_cjk) {
      this._push(S, '}');
    }
    this._push(S, dangling_ws);
    return S.collector.join('');
  };

}).call(this);

//# sourceMappingURL=tex-writer-typofix.js.map
