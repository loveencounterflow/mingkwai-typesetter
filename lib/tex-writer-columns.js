// Generated by CoffeeScript 2.3.2
(function() {
  //###########################################################################################################
  var $, $async, CND, D, MD_READER, MKTS, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, njs_fs, njs_path, rpr, select, stamp, step, suspend, unstamp, urge, warn, whisper,
    slice = [].slice;

  njs_path = require('path');

  njs_fs = require('fs');

  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/TEX-WRITER/COLUMNS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  suspend = require('coffeenode-suspend');

  step = suspend.step;

  //...........................................................................................................
  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  //...........................................................................................................
  MKTS = require('./main');

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  unstamp = MD_READER.unstamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  // hide                      = MK.TS.MD_READER.hide.bind        MK.TS.MD_READER
  // copy                      = MK.TS.MD_READER.copy.bind        MK.TS.MD_READER
  // stamp                     = MK.TS.MD_READER.stamp.bind       MK.TS.MD_READER
  // unstamp                   = MK.TS.MD_READER.unstamp.bind     MK.TS.MD_READER
  // select                    = MK.TS.MD_READER.select.bind      MK.TS.MD_READER
  // is_hidden                 = MK.TS.MD_READER.is_hidden.bind   MK.TS.MD_READER
  // is_stamped                = MK.TS.MD_READER.is_stamped.bind  MK.TS.MD_READER

  //-----------------------------------------------------------------------------------------------------------
  this.$main = function(S) {
    //.........................................................................................................
    // D.$observe ( event ) -> help '99871', ( CND.blue rpr event[ 0 ] + event[ 1 ] )
    return D.TEE.from_pipeline([this.$initialize_state(S), this.$end_columns_with_document(S), this.$region_slash(S), this.$command_slash(S), this.$columns(S), this.$transform_to_pretex(S)]);
  };

  //===========================================================================================================
  // STREAM TRANSFORMS
  //-----------------------------------------------------------------------------------------------------------
  // @$transform_pretex_to_tex   S
  this.$initialize_state = function(S) {
    var is_first, sandbox;
    sandbox = {};
    is_first = true;
    return $((event, send) => {
      var _, changeset, meta, sandbox_backup;
      //.......................................................................................................
      if (select(event, '~', 'change')) {
        [_, _, changeset, _] = event;
        sandbox = MK.TS.DIFFPATCH.patch(changeset, sandbox);
        send(event);
      //.......................................................................................................
      } else if (is_first && select(event, '~', 'flush')) {
        is_first = false;
        [meta] = slice.call(event, -1);
        sandbox_backup = MK.TS.DIFFPATCH.snapshot(sandbox);
        if (sandbox.COLUMNS != null) {
          throw new Error("namespace collision: `S.sandbox.COLUMNS` already defined");
        }
        this._set_sandbox_COLUMNS(sandbox);
        changeset = MKTS.DIFFPATCH.diff(sandbox_backup, sandbox);
        if (changeset.length > 0) {
          send(['~', 'change', changeset, copy(meta)]);
        }
        send(event);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_sandbox_COLUMNS = function(sandbox) {
    sandbox.COLUMNS = {
      count: 2, // default number of columns in document **when using multiple columns**
      stack: [this._new_setting()]
    };
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$end_columns_with_document = function(S) {
    var finished;
    finished = false;
    //.........................................................................................................
    return $((event, send) => {
      var meta;
      //.......................................................................................................
      if ((select(event, ')', 'document')) || (select(event, '~', 'stop'))) {
        if (!finished) {
          [meta] = slice.call(event, -1);
          send([
            '!',
            'columns',
            [1],
            copy(meta,
            {
              'multi-columns': 'omit-open'
            })
          ]);
        }
        send(event);
        finished = true;
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$region_slash = function(S) {
    var event_buffer, track;
    track = MD_READER.TRACKER.new_tracker('(slash)');
    event_buffer = null;
    //.........................................................................................................
    return $((event, send) => {
      var meta, within_slash;
      within_slash = track.within('(slash)');
      track(event);
      //.......................................................................................................
      if (select(event, '(', 'slash')) {
        send(stamp(event));
        event_buffer = [];
      //.......................................................................................................
      } else if (select(event, ')', 'slash')) {
        [meta] = slice.call(event, -1);
        send(stamp(copy(event)));
        send(['!', 'slash', event_buffer, copy(meta)]);
        event_buffer = null;
      //.......................................................................................................
      } else if (within_slash) {
        event_buffer.push(event);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$command_slash = function(S) {
    //.........................................................................................................
    return $((event, send) => {
      var above, below, i, j, len, len1, meta, mid, name, parameters, sub_event, type, x;
      if (select(event, '!', 'slash')) {
        [type, name, parameters, meta] = event;
        send(stamp(hide(copy(event))));
        //.....................................................................................................
        // send [ '!', 'columns', [ 'push', ], ( copy meta ), ]
        send(['!', 'columns', [1], copy(meta)]);
        //.....................................................................................................
        if (CND.isa_list(parameters)) {
          for (i = 0, len = parameters.length; i < len; i++) {
            x = parameters[i];
            /* TAINT should formally check for `event`ness of value */
            if (CND.isa_list(x)) {
              send(x);
            } else {
              send(['.', 'warning', `ignoring argument to <<!slash>>: ${rpr(x)}`, copy(meta)]);
            }
          }
        } else if (CND.isa_pod(parameters)) {
          ({above, mid, below} = parameters);
          // send [ 'tex', "%TEX-WRITER/COLUMNS/$command_slash\n", ]
          // send [ 'tex', "\\gdef\\mktsNextVspaceCount{#{above}}%TEX-WRITER/COLUMNS/$command_slash\n", ]
          // send [ 'tex', "\\mktsVspace{1}%TEX-WRITER/COLUMNS/$command_slash\n", ]
          if (mid != null) {
            for (j = 0, len1 = mid.length; j < len1; j++) {
              sub_event = mid[j];
              send(sub_event);
            }
          }
        // send [ 'tex', "\\gdef\\mktsNextVspaceCount{#{below}}%TEX-WRITER/COLUMNS/$command_slash\n", ]
        // send [ 'tex', "\\mktsVspace{1}%TEX-WRITER/COLUMNS/$command_slash\n", ]
        } else if (parameters != null) {
          send(['.', 'warning', `ignoring argument to <<!slash>>: ${rpr(parameters)}`, copy(meta)]);
        }
        //.....................................................................................................
        send(['!', 'columns', ['pop'], copy(meta)]);
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$columns = function(S) {
    var sandbox;
    // remark  = MK.TS.MD_READER._get_remark()
    sandbox = {};
    //.........................................................................................................
    return $((event, send) => {
      var _, changeset, message, meta, name, parameter, parameters, type;
      //.......................................................................................................
      if (select(event, '~', 'change')) {
        [_, _, changeset, _] = event;
        sandbox = MK.TS.DIFFPATCH.patch(changeset, sandbox);
        send(event);
        return null;
      }
      //.......................................................................................................
      if (select(event, '(', 'columns')) {
        [type, name, parameters, meta] = event;
        event = ['!', name, parameters, meta];
      } else if (select(event, ')', 'columns')) {
        [type, name, _, meta] = event;
        event = ['!', name, ['pop'], meta];
      }
      //.......................................................................................................
      if (select(event, '!', 'columns')) {
        [type, name, parameters, meta] = event;
        if (parameters.length === 0) {
          parameters.push(sandbox.COLUMNS.count);
        }
        [parameter] = parameters;
        switch (type = CND.type_of(parameter)) {
          //...................................................................................................
          case 'text':
            switch (parameter) {
              case 'pop':
                send(stamp(hide(copy(event))));
                this._restore_column_count(sandbox, event, send);
                break;
              default:
                send(stamp(hide(copy(event))));
                message = `unknown text argument ${rpr(parameter)}`;
                send(['.', 'warning', message, copy(meta)]);
            }
            break;
          //...................................................................................................
          case 'number':
            if (!((parameter > 0) && ((Math.floor(parameter)) === parameter))) {
              send(stamp(hide(copy(event))));
              message = `expected non-zero positive integer, got ${rpr(parameter)}`;
              return send(['.', 'warning', message, copy(meta)]);
            }
            send(stamp(hide(copy(event))));
            this._change_column_count(sandbox, event, send, parameter);
            break;
          default:
            //...................................................................................................
            send(stamp(hide(copy(event))));
            message = `expected a text or a number, got a ${parameter_type}`;
            send(['.', 'warning', message, copy(meta)]);
        }
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //===========================================================================================================
  // HELPERS
  //-----------------------------------------------------------------------------------------------------------
  this._new_setting = function(...P) {
    var R;
    R = {
      count: 1 // number of columns at current point
    };
    return Object.assign(R, ...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._push = function(sandbox, setting) {
    return sandbox.COLUMNS.stack.push(setting);
  };

  this._pop = function(sandbox) {
    return sandbox.COLUMNS.stack.pop();
  };

  this._get_column_count = function(sandbox) {
    return sandbox.COLUMNS.stack[this._get_stack_idx(sandbox)]['count'];
  };

  this._get_stack_idx = function(sandbox) {
    return sandbox.COLUMNS.stack.length - 1;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._change_column_count = function(sandbox, event, send, column_count) {
    if (sandbox.COLUMNS == null) {
      /* TAINT hotfix */
      this._set_sandbox_COLUMNS(sandbox);
    }
    this._stop_column_region(sandbox, event, send);
    return this._start_column_region(sandbox, event, send, column_count);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._restore_column_count = function(sandbox, event, send) {
    var column_count;
    if (sandbox.COLUMNS == null) {
      /* TAINT hotfix */
      this._set_sandbox_COLUMNS(sandbox);
    }
    this._stop_column_region(sandbox, event, send);
    this._pop(sandbox);
    column_count = this._get_column_count(sandbox);
    return this._start_column_region(sandbox, event, send, column_count);
  };

  //-----------------------------------------------------------------------------------------------------------
  this._start_column_region = function(sandbox, event, send, column_count) {
    var meta;
    // send stamp hide copy event
    this._push(sandbox, this._new_setting({
      count: column_count
    }));
    // debug '©66343', event, column_count
    // debug '©66343', S.sandbox.COLUMNS.stack
    // if column_count isnt 1
    [meta] = slice.call(event, -1);
    /* TAINT this event should be namespaced and handled only right before output */
    if (meta['multi-columns'] !== 'omit-open') {
      send(['(', 'multi-columns', [column_count], copy(meta)]);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._stop_column_region = function(sandbox, event, send) {
    var column_count, meta;
    /* No-op in case we're in base ('ambient', 'document') state */
    // urge '77262', sandbox.sandbox.COLUMNS.stack
    // send stamp hide copy event
    if ((this._get_stack_idx(sandbox)) === 0) {
      return;
    }
    column_count = this._get_column_count(sandbox);
    // last_state      = @_pop sandbox
    /* No-op in case we're already in single-column state */
    // return if column_count is 1
    [meta] = slice.call(event, -1);
    /* TAINT this event should be namespaced and handled only right before output */
    // debug '928772', [ ')', 'multi-columns', [ column_count, ], ( copy meta ), ]
    return send([')', 'multi-columns', [column_count], copy(meta)]);
  };

  //===========================================================================================================
  // TRANSFORM TO TEX
  //-----------------------------------------------------------------------------------------------------------
  this.$transform_to_pretex = function(S) {
    //.........................................................................................................
    return $((event, send) => {
      var column_count, meta, name, parameters, type;
      [type, name, parameters, meta] = event;
      //.......................................................................................................
      if (select(event, '(', 'multi-columns')) {
        send(hide(stamp(event)));
        [column_count] = parameters;
        if (column_count > 1) {
          send(stamp([
            '(',
            'COLUMNS/group',
            null,
            copy(meta,
            {
              tex: 'pass-through'
            })
          ]));
          // send stamp [ '.', 'COLUMNS/tex', "\\mktsVspace{1}%TEX-WRITER/COLUMNS/$transform-to-tex\n", ( copy meta, tex: 'pass-through', ), ]
          /* TAINT Here the layout design decision to separate multicols from surrounding paragraphs by
          one blank line gets hardwired into the produced TeX code: */
          // send stamp [ '.', 'COLUMNS/tex', "\\mktsVspace{1}\\begin{multicols}{#{column_count}}\\raggedcolumns{}", ( copy meta, tex: 'pass-through', ), ]
          /* TAINT ... and some time later we decide to throw it out again: */
          send(stamp([
            '.',
            'COLUMNS/tex',
            `\\begin{multicols}{${column_count}}\\raggedcolumns{}`,
            copy(meta,
            {
              tex: 'pass-through'
            })
          ]));
        }
      //.......................................................................................................
      } else if (select(event, ')', 'multi-columns')) {
        // send stamp event
        [column_count] = parameters;
        if (column_count > 1) {
          send(stamp([
            '.',
            'COLUMNS/tex',
            "\\end{multicols}\n\n",
            copy(meta,
            {
              tex: 'pass-through'
            })
          ]));
          send(stamp([
            ')',
            'COLUMNS/group',
            null,
            copy(meta,
            {
              tex: 'pass-through'
            })
          ]));
        }
      } else {
        //.......................................................................................................
        send(event);
      }
      //.......................................................................................................
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$XXX_transform_pretex_to_tex = function(S) {
    var all_whitespace, buffer, within_group, ws_pattern;
    buffer = [];
    within_group = false;
    all_whitespace = true;
    ws_pattern = /^[\x20\t\n]*$/;
    // remark          = MK.TS.MD_READER._get_remark()
    //.........................................................................................................
    return $((event, send) => {
      var i, len, meta, name, sub_text, text, type;
      // urge '99876', event
      if (CND.isa_text(event)) {
        type = null;
        name = null;
        text = event;
        meta = null;
      } else {
        [type, name, text, meta] = event;
      }
      //.......................................................................................................
      if (select(event, '(', 'COLUMNS/group')) {
        // help '975', ( JSON.stringify event )[ .. 50 ]
        within_group = true;
      //.......................................................................................................
      } else if (select(event, ')', 'COLUMNS/group')) {
        // warn '975', ( JSON.stringify event )[ .. 50 ]
        if (all_whitespace) {
          whisper("ignoring multicols b/c group only contains whitespace");
        } else {
          for (i = 0, len = buffer.length; i < len; i++) {
            sub_text = buffer[i];
            /* remark not possible at this stage */
            // send remark 'drop', "multicols b/c group only contains whitespace", ( copy meta )
            send(sub_text);
          }
        }
        /* TAINT code duplication with the above */
        buffer.length = 0;
        within_group = false;
        all_whitespace = true;
      //.......................................................................................................
      } else if (select(event, '.', 'COLUMNS/tex')) {
        // urge '975', ( JSON.stringify event )[ .. 50 ]
        buffer.push(text);
      } else {
        // send text
        //.......................................................................................................
        if (within_group) {
          all_whitespace = all_whitespace && ws_pattern.test(text);
          buffer.push(text);
        } else {
          // info '975', ( JSON.stringify event )[ .. 50 ]
          // debug '975', event if text is undefined
          // whisper '975', all_whitespace, rpr text
          send(event);
        }
      }
      //.......................................................................................................
      return null;
    });
  };

}).call(this);

//# sourceMappingURL=tex-writer-columns.js.map
