{
  "version": 3,
  "file": "exceljs-spreadsheet-address-codec.js",
  "sourceRoot": "..",
  "sources": [
    "src/exceljs-spreadsheet-address-codec.coffee"
  ],
  "names": [],
  "mappings": ";AACA;EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA",
  "sourcesContent": [
    "\n```\n\n/**\n * Copyright (c) 2014-2017 Guyon Roche\n * LICENCE: MIT - please refer to LICENCE file included with this module\n * or https://github.com/guyonroche/exceljs/blob/master/LICENSE\n */\n\n'use strict';\n\n// =========================================================================\n// Column Letter to Number conversion\nvar colCache = module.exports = {\n  _dictionary: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'],\n  _l2n: {},\n  _n2l: [],\n  _level: function(n) {\n    if (n <= 26) { return 1; }\n    if (n <= 26 * 26) { return 2; }\n    return 3;\n  },\n  _fill: function(level) {\n    var c, v, l1, l2, l3;\n    var n = 1;\n    if (level >= 1) {\n      while (n <= 26) {\n        c = this._dictionary[n - 1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n    }\n    if (level >= 2) {\n      while (n <= 26 + (26 * 26)) {\n        v = n - (26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26);\n        c = this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n    }\n    if (level >= 3) {\n      while (n <= 16384) {\n        v = n - ((26 * 26) + 26 + 1);\n        l1 = v % 26;\n        l2 = Math.floor(v / 26) % 26;\n        l3 = Math.floor(v / (26 * 26));\n        c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];\n        this._n2l[n] = c;\n        this._l2n[c] = n;\n        n++;\n      }\n    }\n  },\n  l2n: function(l) {\n    if (!this._l2n[l]) {\n      this._fill(l.length);\n    }\n    if (!this._l2n[l]) {\n      throw new Error('Out of bounds. Invalid column letter: ' + l);\n    }\n    return this._l2n[l];\n  },\n  n2l: function(n) {\n    if ((n < 1) || (n > 16384)) {\n      throw new Error('' + n + ' is out of bounds. Excel supports columns from 1 to 16384');\n    }\n    if (!this._n2l[n]) {\n      this._fill(this._level(n));\n    }\n    return this._n2l[n];\n  },\n\n  // =========================================================================\n  // Address processing\n  _hash: {},\n\n  // check if value looks like an address\n  validateAddress: function(value) {\n    if (!value.match(/^[A-Z]+\\d+$/)) {\n      throw new Error('Invalid Address: ' + value);\n    }\n    return true;\n  },\n\n  // convert address string into structure\n  decodeAddress: function(value) {\n    var addr = this._hash[value];\n    if (addr) {\n      return addr;\n    }\n    var matchCol = value.match(/[A-Z]+/);\n    var col;\n    var colNumber;\n    if (matchCol) {\n      col = matchCol[0];\n      colNumber = this.l2n(col);\n    }\n    var matchRow = value.match(/\\d+/);\n    var row;\n    var rowNumber;\n    if (matchRow) {\n      row = matchRow[0];\n      rowNumber = parseInt(row, 10);\n    }\n\n    // in case $row$col\n    value = (col || '') + (row || '');\n\n    var address = {\n      address: value,\n      col: colNumber,\n      row: rowNumber,\n      $col$row: '$' + (col || '') + '$' + (row || '')\n    };\n\n    // mem fix - cache only the tl 100x100 square\n    if ((colNumber <= 100) && (rowNumber <= 100)) {\n      this._hash[value] = address;\n      this._hash[address.$col$row] = address;\n    }\n\n    return address;\n  },\n\n  // convert r,c into structure (if only 1 arg, assume r is address string)\n  getAddress: function(r, c) {\n    if (c) {\n      var address = this.n2l(c) + r;\n      return this.decodeAddress(address);\n    }\n    return this.decodeAddress(r);\n  },\n\n  // convert [address], [tl:br] into address structures\n  decode: function(value) {\n    var parts = value.split(':');\n    if (parts.length === 2) {\n      var tl = this.decodeAddress(parts[0]);\n      var br = this.decodeAddress(parts[1]);\n      var result = {\n        top: Math.min(tl.row, br.row),\n        left: Math.min(tl.col, br.col),\n        bottom: Math.max(tl.row, br.row),\n        right: Math.max(tl.col, br.col)\n      };\n      // reconstruct tl, br and dimensions\n      result.tl = this.n2l(result.left) + result.top;\n      result.br = this.n2l(result.right) + result.bottom;\n      result.dimensions = result.tl + ':' + result.br;\n      return result;\n    }\n    return this.decodeAddress(value);\n  },\n\n  // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures\n  decodeEx: function(value) {\n    var groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);\n\n    var sheetName = groups[1] || groups[2]; // Qouted and unqouted groups\n    var reference = groups[3]; // Remaining address\n\n    var parts = reference.split(':');\n    if (parts.length > 1) {\n      var tl = this.decodeAddress(parts[0]);\n      var br = this.decodeAddress(parts[1]);\n      var top = Math.min(tl.row, br.row);\n      var left = Math.min(tl.col, br.col);\n      var bottom = Math.max(tl.row, br.row);\n      var right = Math.max(tl.col, br.col);\n\n      tl = this.n2l(left) + top;\n      br = this.n2l(right) + bottom;\n\n      return {\n        top: top,\n        left: left,\n        bottom: bottom,\n        right: right,\n        sheetName: sheetName,\n        tl: { address: tl, col: left, row: top, $col$row: '$' + this.n2l(left) + '$' + top, sheetName: sheetName },\n        br: { address: br, col: right, row: bottom, $col$row: '$' + this.n2l(right) + '$' + bottom, sheetName: sheetName },\n        dimensions: tl + ':' + br\n      };\n    } else if (reference.startsWith('#')) {\n      return sheetName ? {sheetName: sheetName, error: reference} : {error: reference};\n    }\n\n    var address = this.decodeAddress(reference);\n    return sheetName ? Object.assign({sheetName: sheetName}, address) : address;\n  },\n\n  // convert row,col into address string\n  encodeAddress: function(row, col) {\n    return colCache.n2l(col) + row;\n  },\n\n  // convert row,col into string address or t,l,b,r into range\n  encode: function() {\n    switch (arguments.length) {\n      case 2:\n        return colCache.encodeAddress(arguments[0], arguments[1]);\n      case 4:\n        return colCache.encodeAddress(arguments[0], arguments[1]) + ':' + colCache.encodeAddress(arguments[2], arguments[3]);\n      default:\n        throw new Error('Can only encode with 2 or 4 arguments');\n    }\n  }\n};\n\n```"
  ]
}