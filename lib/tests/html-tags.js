// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, XREGEXP, alert, badge, debug, echo, eq, get_patterns, help, include, info, join, jr, log, rpr, test, urge, warn, whisper,
    indexOf = [].indexOf;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'HTML-TAGS/TESTS';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  test = require('guy-test');

  eq = CND.equals;

  jr = JSON.stringify;

  //...........................................................................................................
  join = function(x, joiner = '') {
    return x.join(joiner);
  };

  XREGEXP = require('xregexp');

  //-----------------------------------------------------------------------------------------------------------
  this._prune = function() {
    var name, ref, value;
    ref = this;
    for (name in ref) {
      value = ref[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._main = function() {
    return test(this, {
      'timeout': 30000
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  get_patterns = function(tag_name) {
    return {
      start: RegExp(`<${tag_name}>|<${tag_name}\\s+(?<attributes>[^>]*)(?<!\\/)>`, "g"),
      stop: RegExp(`<\\/${tag_name}>`, "g")
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this["basic"] = function(T, done) {
    var attributes, attributes_matcher, i, is_hit, is_hit_matcher, len, probe, probes_and_matchers, ref, ref1, result, start_tag_pattern, tag_name;
    probes_and_matchers = [["div", "what<div>helo", true, null], ["div", "what<div a=10>helo", true, "a=10"], ["div", "what<div path=foo/bar>helo", true, "path=foo/bar"], ["div", "what<div path=foo/bar/>helo", false, null], ["div", "what<div path='foo/bar/'>helo", true, "path='foo/bar/'"], ["frob", "what<frob/>helo", false, null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [tag_name, probe, is_hit_matcher, attributes_matcher] = probes_and_matchers[i];
      start_tag_pattern = RegExp(`<${tag_name}>|<${tag_name}\\s+(?<attributes>[^>]*)(?<!\\/)>`);
      result = probe.match(start_tag_pattern);
      is_hit = result != null;
      attributes = (ref = result != null ? (ref1 = result.groups) != null ? ref1.attributes : void 0 : void 0) != null ? ref : null;
      urge('36633', jr([tag_name, probe, is_hit, attributes]));
      T.eq(is_hit, is_hit_matcher);
      T.eq(attributes, attributes_matcher);
    }
    //.........................................................................................................
    return done();
  };

  //-----------------------------------------------------------------------------------------------------------
  this["start pattern"] = function(T, done) {
    var i, len, matcher, patterns, probe, probes_and_matchers, result, tag_name;
    probes_and_matchers = [["div", "what<div>helo", ["<div>"]], ["div", "what<div a=10>helo", ["<div a=10>"]], ["div", "what<div path=foo/bar>helo<div>x</div></div>", ["<div path=foo/bar>", "<div>"]], ["div", "what<div path=foo/bar/ frob=42 ding>helo", ["<div path=foo/bar/ frob=42 ding>"]], ["div", "what<div path='foo/bar/'>helo", ["<div path='foo/bar/'>"]], ["div", "what<div path=foo/bar/>helo", null], ["frob", "what<frob/>helo", null]];
//.........................................................................................................
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [tag_name, probe, matcher] = probes_and_matchers[i];
      patterns = get_patterns(tag_name);
      result = probe.match(patterns.start);
      urge('36633', jr([tag_name, probe, result]));
      T.eq(result, matcher);
    }
    //.........................................................................................................
    return done();
  };

  //-----------------------------------------------------------------------------------------------------------
  this["recursive"] = function(T, done) {
    var error, i, len, matcher, name, probe, probes_and_matchers, result, settings, start, stop, tag_name, value;
    probes_and_matchers = [
      [
        "div",
        "what<div>helo\n</div>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<div>"
          },
          {
            "name": "match",
            "value": "helo\n"
          },
          {
            "name": "right",
            "value": "</div>"
          }
        ]
      ],
      [
        "div",
        "what<div a=10>helo</div>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<div a=10>"
          },
          {
            "name": "match",
            "value": "helo"
          },
          {
            "name": "right",
            "value": "</div>"
          }
        ]
      ],
      [
        "raw",
        "what<raw path=foo/bar>helo</raw>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<raw path=foo/bar>"
          },
          {
            "name": "match",
            "value": "helo"
          },
          {
            "name": "right",
            "value": "</raw>"
          }
        ]
      ],
      [
        "raw",
        "what<raw path=foo/bar/>helo",
        [
          {
            "name": "between",
            "value": "what<raw path=foo/bar/>helo"
          }
        ]
      ],
      [
        "raw",
        "what<raw path='foo/bar/'>helo</raw>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<raw path='foo/bar/'>"
          },
          {
            "name": "match",
            "value": "helo"
          },
          {
            "name": "right",
            "value": "</raw>"
          }
        ]
      ],
      [
        "frob",
        "what<frob/>helo",
        [
          {
            "name": "between",
            "value": "what<frob/>helo"
          }
        ]
      ]
    ];
    //.........................................................................................................
    settings = {
      valueNames: ['between', 'left', 'match', 'right']
    };
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [tag_name, probe, matcher] = probes_and_matchers[i];
      ({start, stop} = get_patterns(tag_name));
      try {
        result = XREGEXP.matchRecursive(probe, start.source, stop.source, 'g', settings);
      } catch (error1) {
        error = error1;
        if (matcher === null) {
          T.ok(true);
          help('36633', jr([probe, null]));
        } else {
          T.fail(error.message);
          warn('36633', jr([probe, null]));
        }
        continue;
      }
      result = (function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = result.length; j < len1; j++) {
          ({name, value} = result[j]);
          results.push({name, value});
        }
        return results;
      })();
      urge('36633', jr([tag_name, probe, result]));
      T.eq(result, matcher);
    }
    //.........................................................................................................
    return done();
  };

  //-----------------------------------------------------------------------------------------------------------
  this["parse attributes"] = function(T, done) {
    var error, i, len, matcher, name, probe, probes_and_matchers, result, settings, start, stop, tag_name, value;
    probes_and_matchers = [
      [
        "div",
        "what<div>helo\n</div>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<div>"
          },
          {
            "name": "match",
            "value": "helo\n"
          },
          {
            "name": "right",
            "value": "</div>"
          }
        ]
      ],
      [
        "div",
        "what<div a=10>helo</div>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<div a=10>"
          },
          {
            "name": "match",
            "value": "helo"
          },
          {
            "name": "right",
            "value": "</div>"
          }
        ]
      ],
      [
        "raw",
        "what<raw path=foo/bar>helo</raw>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<raw path=foo/bar>"
          },
          {
            "name": "match",
            "value": "helo"
          },
          {
            "name": "right",
            "value": "</raw>"
          }
        ]
      ],
      [
        "raw",
        "what<raw path=foo/bar/>helo",
        [
          {
            "name": "between",
            "value": "what<raw path=foo/bar/>helo"
          }
        ]
      ],
      [
        "raw",
        "what<raw path='foo/bar/'>helo</raw>",
        [
          {
            "name": "between",
            "value": "what"
          },
          {
            "name": "left",
            "value": "<raw path='foo/bar/'>"
          },
          {
            "name": "match",
            "value": "helo"
          },
          {
            "name": "right",
            "value": "</raw>"
          }
        ]
      ],
      [
        "frob",
        "what<frob/>helo",
        [
          {
            "name": "between",
            "value": "what<frob/>helo"
          }
        ]
      ]
    ];
    //.........................................................................................................
    settings = {
      valueNames: ['between', 'left', 'match', 'right']
    };
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [tag_name, probe, matcher] = probes_and_matchers[i];
      ({start, stop} = get_patterns(tag_name));
      try {
        result = XREGEXP.matchRecursive(probe, start.source, stop.source, 'g', settings);
      } catch (error1) {
        error = error1;
        if (matcher === null) {
          T.ok(true);
          help('36633', jr([probe, null]));
        } else {
          T.fail(error.message);
          warn('36633', jr([probe, null]));
        }
        continue;
      }
      result = (function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = result.length; j < len1; j++) {
          ({name, value} = result[j]);
          results.push({name, value});
        }
        return results;
      })();
      urge('36633', jr([tag_name, probe, result]));
    }
    // T.eq result, matcher
    //.........................................................................................................
    return done();
  };

  //-----------------------------------------------------------------------------------------------------------
  this["htmlish-tag-parser"] = function(T, done) {
    var PARSE5, attributes, i, j, len, len1, matcher, name, node, probe, probes_and_matchers, ref, tree;
    // ["<embedded-file>",]
    // ["<embedded-file name=foobar>",]
    // ["<embedded-file name='foobar'>",]
    // ["<embedded-file name=\"foobar\">",]
    // ["<xy:embedded-file>",]
    // ["<xy:embedded-file name=foobar>",]
    // ["<xy:embedded-file name='foobar'>",]
    // ["<xy:embedded-file name=\"foobar\">",]
    // ["<xy:embedded-file>",]
    // ["<xy:embedded-file name=foobar/>",]
    // ["<xy:embedded-file name='foobar'/>",]
    // ["<xy:embedded-file name=\"foobar\"/>",]
    probes_and_matchers = [["<tag/> x"], ["<tag> x"], ["<br/> x"], ["<br> x"]];
    //.........................................................................................................
    // ["some text with a <tag/> in it"]
    // ["some text with a <br/> in it"]
    PARSE5 = require('parse5');
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      [probe, matcher] = probes_and_matchers[i];
      ref = (PARSE5.parseFragment(probe)).childNodes;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        node = ref[j];
        delete node.namespaceURI;
        delete node.parentNode;
        debug('98932', node);
        name = node.tagName;
        attributes = node.attrs;
        tree = node.childNodes;
        urge('36633', jr({name, attributes}));
      }
    }
    // T.eq result, matcher
    //.........................................................................................................
    return done();
  };

  // for [ probe, matcher, ] in probes_and_matchers
  //   result = probe.match start_tag_pattern
  //   try
  //   catch error
  //     # throw error

  //###########################################################################################################
  if (module.parent == null) {
    include = ["basic", "start pattern", "recursive", "parse attributes"];
    // "htmlish-tag-parser"
    this._prune();
    this._main();
  }

}).call(this);

//# sourceMappingURL=html-tags.js.map
