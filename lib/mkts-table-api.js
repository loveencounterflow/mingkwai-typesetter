// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, IG, MKTS, MKTS_TABLE, _fail, _record, _record_fail, _stackerr, alert, badge, debug, echo, help, info, jr, log, rpr, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS/TABLE/API';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  MKTS = require('./main');

  MKTS_TABLE = require('./mkts-table');

  //...........................................................................................................
  jr = JSON.stringify;

  IG = require('intergrid');

  // UNITS                     = require './mkts-table-units'

  //===========================================================================================================
  // PUBLIC API
  //-----------------------------------------------------------------------------------------------------------
  this.create_layout = function(S, meta, id) {
    var R;
    R = MKTS_TABLE._new_description(S);
    R.meta = meta;
    R.name = id;
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_grid = function(me, size) {
    if (me.grid != null) {
      return _record_fail(me, 'µ5689', "unable to re-define grid");
    }
    switch (size.type) {
      case 'cellkey':
        me.grid = IG.GRID.new_grid_from_cellkey(size.value);
        break;
      default:
        throw _stackerr(me, 'µ4613', `unknown type for grid size ${rpr(size)}`);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_debug = function(me, toggle) {
    switch (toggle) {
      case true:
        me.debug = true;
        break;
      case false:
        me.debug = false;
        break;
      default:
        throw new Error(`(MKTS/TABLE µ1343) expected \`true\` or \`false\` for mkts-table/debug, got ${rpr(toggle)}`);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.create_field = function(me, id, selector) {
    var base, base1, fieldcell, fieldnr, first, name, rangekey, rangeref, ref1, second;
    switch (selector.type) {
      case 'cellkey':
        rangekey = `${selector.value}..${selector.value}`;
        break;
      case 'rangekey':
        first = selector.first;
        second = selector.second;
        if (first.type !== 'cellkey') {
          throw new Error(`(MKTS/TABLE µ1344) expected a cellkey, got a ${rpr(first.type)}`);
        }
        if (second.type !== 'cellkey') {
          throw new Error(`(MKTS/TABLE µ1345) expected a cellkey, got a ${rpr(second.type)}`);
        }
        rangekey = `${first.value}..${second.value}`;
    }
    //.........................................................................................................
    /* TAINT should support using variables etc. */
    /* aliases     = @_parse_aliases me, aliases */
    rangeref = IG.GRID.parse_rangekey(me.grid, rangekey);
    fieldnr = (me._tmp.prv_fieldnr += +1);
    if (me.fieldcells[fieldnr] != null) {
      throw new /* should never happen */Error(`(MKTS/TABLE µ5375) unable to redefine field ${fieldnr}: ${rpr(source)}`);
    }
    //.........................................................................................................
    me.fieldcells[fieldnr] = rangeref;
    ref1 = IG.GRID.walk_cells_from_rangeref(me.grid, rangeref);
    for (fieldcell of ref1) {
      ((base = me.cellfields)[name = fieldcell.cellkey] != null ? base[name] : base[name] = []).push(fieldnr);
    }
    //.........................................................................................................
    /* TAINT should support using variables etc.
      for alias in aliases
    ( me.fieldnrs_by_aliases[ alias ]?= [] ).push fieldnr */
    if (id != null) {
      ((base1 = me.fieldnrs_by_aliases)[id] != null ? base1[id] : base1[id] = []).push(fieldnr);
    }
    //.........................................................................................................
    this._set_default_gaps(me, fieldnr);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_default_gaps = function(me, fieldnr) {
    var base, edge, gap, i, j, len, len1, ref1, ref2;
    ref1 = ['fill', 'margins', 'paddings'];
    for (i = 0, len = ref1.length; i < len; i++) {
      gap = ref1[i];
      ref2 = ['left', 'right', 'top', 'bottom'];
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        edge = ref2[j];
        ((base = me.gaps[gap])[fieldnr] != null ? base[fieldnr] : base[fieldnr] = {})[edge] = me.default.gaps[gap];
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_borders = function(me, selectors, edges, style) {
    var base, edge, fieldnr, i, len, ref1;
    debug('44433', selectors, edges, style);
    ref1 = this.walk_fieldnrs_from_selectors(me, selectors);
    for (fieldnr of ref1) {
      debug('44433', 'fieldnr', fieldnr);
/* TAINT must resolve symbolic edges like `all` */
      for (i = 0, len = edges.length; i < len; i++) {
        edge = edges[i];
        if (edge !== 'left' && edge !== 'right' && edge !== 'top' && edge !== 'bottom') {
          throw new Error(`µ29282 must resolve symbolic edges like \`all\`, got ${rpr(edge)}`);
        }
        ((base = me.fieldborders)[fieldnr] != null ? base[fieldnr] : base[fieldnr] = {})[edge] = style;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.walk_fieldnrs_from_selectors = function*(me, selectors) {
    var cellref, fieldnr, i, j, len, len1, ref1, ref2, ref3, seen_fieldnrs, selector;
    seen_fieldnrs = new Set();
    for (i = 0, len = selectors.length; i < len; i++) {
      selector = selectors[i];
      ref1 = this.walk_cellrefs_from_selectors(me, selectors);
      for (cellref of ref1) {
        ref3 = (ref2 = me.cellfields[cellref.cellkey]) != null ? ref2 : [];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          fieldnr = ref3[j];
          if (seen_fieldnrs.has(fieldnr)) {
            continue;
          }
          seen_fieldnrs.add(fieldnr);
          yield fieldnr;
        }
      }
    }
  };

  // unless ( fieldnrs = me.fieldnrs_by_aliases[ term ] )?
  //   throw new Error "(MKTS/TABLE µ5446) unknown alias #{rpr term}"
  // R.add fieldnr for fieldnr in fieldnrs

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this.walk_cellrefs_from_selectors = function*(me, selectors) {
    var cellref, i, len, ref1, seen_cellkeys, selector;
    seen_cellkeys = new Set();
    for (i = 0, len = selectors.length; i < len; i++) {
      selector = selectors[i];
      // debug '38393', rpr selector
      switch (selector.type) {
        case 'cellkey':
          ref1 = IG.GRID.walk_cells_from_key(me.grid, selector.value);
          for (cellref of ref1) {
            if (seen_cellkeys.has(cellref.cellkey)) {
              continue;
            }
            seen_cellkeys.add(cellref.cellkey);
            yield cellref;
          }
          break;
        default:
          warn('90901', `ignoring selector type ${selector.type}`);
      }
    }
  };

  /* ***************************************************** */
  /* ***************************************************** */
  /* ***************************************************** */
  /* ***************************************************** */
  /* ***************************************************** */
  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._set_unitsize = function(me, direction, text) {
    var p;
    if (direction !== 'width' && direction !== 'height') {
      throw _stackerr(me, 'µ4613', `expected 'width' or 'height', got ${rpr(direction)}`);
    }
    p = `unit${direction}`;
    //.........................................................................................................
    /* Do nothing if dimension already defined: */
    if (me[p] != null) {
      return _record_fail(me, 'µ5661', `unable to re-define ${p}`);
    }
    //.........................................................................................................
    me[p] = UNITS.parse_nonnegative_quantity(text);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_lanesizes = function(me, direction, text) {
    var base, base1, fail, i, j, lane_count, lanenr, length, match, nr, p, ps, ref1, ref2, ref3, selector, x;
    if (direction !== 'width' && direction !== 'height') {
      throw _stackerr(me, 'µ2352', `expected 'width' or 'height', got ${rpr(direction)}`);
    }
    //.........................................................................................................
    p = direction === 'width' ? 'colwidth' : 'rowheight';
    ps = direction === 'width' ? 'colwidths' : 'rowheights';
    //.........................................................................................................
    this._ensure_grid(me);
    lane_count = me.grid[direction];
    //.........................................................................................................
    if ((match = text.match(/^(?:(?<selector>[^:]+):)?(?<length>[+\d.]+)$/)) == null) {
      _record_fail(me, 'µ6377', `need a text like '2.7', 'A*,C3:20' or similar for mkts-table/${p}, got ${rpr(text)}`);
      return null;
    }
    //.........................................................................................................
    ({selector, length} = match.groups);
    length = parseFloat(length);
    //.........................................................................................................
    if (selector != null) {
      if ((base = me[ps])[0] == null) {
        base[0] = me.default[p];
      }
      for (nr = i = 1, ref1 = lane_count; (1 <= ref1 ? i <= ref1 : i >= ref1); nr = 1 <= ref1 ? ++i : --i) {
        if ((base1 = me[ps])[nr] == null) {
          base1[nr] = me.default[p];
        }
      }
      ref2 = this._walk_fails_and_lanenrs_from_direction_and_selector(me, direction, selector);
      /* set defaults where missing */
      for (x of ref2) {
        [fail, lanenr] = x;
        if (fail != null) {
          _record(me, fail);
        } else {
          me[ps][lanenr] = length;
        }
      }
    } else {
      me[ps][0] = length/* set default */
      for (nr = j = 1, ref3 = lane_count; (1 <= ref3 ? j <= ref3 : j >= ref3); nr = 1 <= ref3 ? ++j : --j) {
        me[ps][nr] = length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitwidth = function(me, text) {
    return this._set_unitsize(me, 'width', text);
  };

  this.unitheight = function(me, text) {
    return this._set_unitsize(me, 'height', text);
  };

  this.columnwidth = function(me, text) {
    return this._set_lanesizes(me, 'width', text);
  };

  this.rowheight = function(me, text) {
    return this._set_lanesizes(me, 'height', text);
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @_resolve_aliases = ( me, selector ) ->
  //   ### Given a comma-separated string or a list of cellkeys, cellrange literals, and / or aliases, return a
  //   list of cellkeys and / or cellrange literals. ###
  //   return @_resolve_aliases me, selector.split /\s*,\s*/ if CND.isa_text selector
  //   R = new Set()
  //   for term in selector
  //     if ( CND.isa_text term ) and ( term.startsWith '@' )
  //       unless ( fieldnrs = me.fieldnrs_by_aliases[ term ] )?
  //         ### TAINT error or failure? ###
  //         throw new Error "(MKTS/TABLE µ5446) unknown alias #{rpr term}"
  //       R.add fieldnr for fieldnr in fieldnrs
  //     else
  //       R.add term
  //   return [ R... ]

  //-----------------------------------------------------------------------------------------------------------
  this.fieldalignvertical = function(me, text) {
    var _, fail, field_designation, match, ref1, selector, value, x;
    if ((match = text.match(/^(.+?):([^:]+)$/)) == null) {
      throw new Error(`(MKTS/TABLE µ5229) expected something like 'C3:top' for mkts-table/fieldalignvertical, got ${rpr(text)}`);
    }
    [_, selector, value] = match;
    //.........................................................................................................
    if (value !== 'top' && value !== 'bottom' && value !== 'center' && value !== 'spread') {
      throw new Error(`(MKTS/TABLE µ1876) expected one of 'top', 'bottom', 'center', 'spread' for mkts-table/fieldalignvertical, got ${rpr(value)}`);
    }
    ref1 = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (x of ref1) {
      [fail, field_designation] = x;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({field_designation})})`);
      } else {
        me.valigns[field_designation] = value;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldalignhorizontal = function(me, text) {
    var _, fail, field_designation, match, ref1, selector, value, x;
    if ((match = text.match(/^(.+?):([^:]+)$/)) == null) {
      throw new Error(`(MKTS/TABLE µ5229) expected something like 'C3:left' for mkts-table/fieldalignhorizontal, got ${rpr(text)}`);
    }
    [_, selector, value] = match;
    //.........................................................................................................
    if (value !== 'left' && value !== 'right' && value !== 'center' && value !== 'justified') {
      throw new Error(`(MKTS/TABLE µ1876) expected one of 'left', 'right', 'center', 'justified' for mkts-table/fieldalignhorizontal, got ${rpr(value)}`);
    }
    ref1 = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (x of ref1) {
      [fail, field_designation] = x;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({field_designation})})`);
      } else {
        me.haligns[field_designation] = value;
      }
    }
    //.........................................................................................................
    return null;
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @name = ( me, text ) ->
  //   if me.name?
  //     throw new Error "(MKTS/TABLE µ1344) refused to rename table layout #{rpr me.name} to #{rpr text}"
  //   #.........................................................................................................
  //   ### TAINT should check syntax (no whitespace etc) ###
  //   me.name = text
  //   return null

  //-----------------------------------------------------------------------------------------------------------
  this.margin = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, i, j, len, len1, ref1, ref2;
    d = this._parse_fieldgap(me, 'margin', text);
    ref1 = d.fieldnames;
    for (i = 0, len = ref1.length; i < len; i++) {
      fieldname = ref1[i];
      ref2 = d.edges;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        edge = ref2[j];
        ((base = me.gaps.margins)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.padding = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, i, j, len, len1, ref1, ref2;
    d = this._parse_fieldgap(me, 'padding', text);
    ref1 = d.fieldnames;
    for (i = 0, len = ref1.length; i < len; i++) {
      fieldname = ref1[i];
      ref2 = d.edges;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        edge = ref2[j];
        ((base = me.gaps.paddings)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fill_gap = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, i, j, len, len1, ref1, ref2;
    d = this._parse_fieldgap(me, 'fill', text);
    ref1 = d.fieldnames;
    for (i = 0, len = ref1.length; i < len; i++) {
      fieldname = ref1[i];
      ref2 = d.edges;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        edge = ref2[j];
        ((base = me.gaps.fill)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //===========================================================================================================
  // HELPERS
  //-----------------------------------------------------------------------------------------------------------
  _stackerr = function(me, ref, message, error = null) {
    /*
    Prepends local error message to the original one so we get more informative traces. Usage:

    ```
    try
      ...
    catch error
      throw _stackerr error, "(MKTS/TABLE µ4781) ... new message ..."
    ```
    */
    var filename, line_nr, ref1, ref2;
    filename = (ref1 = me.meta.filename) != null ? ref1 : '<NOFILENAME>';
    line_nr = (ref2 = me.meta.line_nr) != null ? ref2 : '(NOLINENR)';
    message = `[${badge}#${ref}: ${filename}#${line_nr}]: ${message}`;
    if (error != null) {
      error.message = `${message}\n${error.message}`;
    } else {
      error = new Error(message);
    }
    return error;
  };

  //-----------------------------------------------------------------------------------------------------------
  _fail = function(me, ref, message) {
    /* TAINT using strings as error values is generally being frowned upon */
    var filename, line_nr, ref1, ref2;
    filename = (ref1 = me.meta.filename) != null ? ref1 : '<NOFILENAME>';
    line_nr = (ref2 = me.meta.line_nr) != null ? ref2 : '(NOLINENR)';
    return `[${badge}#${ref}: ${filename}#${line_nr}]: ${message}`;
  };

  //-----------------------------------------------------------------------------------------------------------
  _record = function(me, message) {
    me.fails.push(message);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  _record_fail = function(me, ref, message) {
    return _record(me, _fail(me, ref, message));
  };

}).call(this);

//# sourceMappingURL=mkts-table-api.js.map
