// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, IG, MKTS, MKTS_TABLE, UNITS, alert, badge, debug, echo, help, info, jr, log, rpr, urge, warn, whisper;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MKTS/TABLE/API';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  MKTS = require('./main');

  MKTS_TABLE = require('./mkts-table');

  //...........................................................................................................
  jr = JSON.stringify;

  IG = require('intergrid');

  UNITS = require('./mkts-table-units');

  //===========================================================================================================
  // PUBLIC API
  //-----------------------------------------------------------------------------------------------------------
  this.create_layout = function(S, meta, id) {
    var R;
    R = MKTS_TABLE._new_description(S);
    R.meta = meta;
    R.name = id;
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_grid = function(me, size) {
    if (me.grid != null) {
      throw new Error("µ1234 unable to re-define grid");
    }
    switch (size.type) {
      case 'cellkey':
        me.grid = IG.GRID.new_grid_from_cellkey(size.value);
        break;
      default:
        throw new Error(`µ1235 unknown type for grid size ${rpr(size)}`);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_debug = function(me, toggle) {
    switch (toggle) {
      case true:
        me.debug = true;
        break;
      case false:
        me.debug = false;
        break;
      default:
        throw new Error(`µ1236 expected \`true\` or \`false\` for mkts-table/debug, got ${rpr(toggle)}`);
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.create_field = function(me, id, selector) {
    var base, base1, fieldcell, fieldnr, first, name, rangekey, rangeref, ref, second;
    switch (selector.type) {
      case 'cellkey':
        rangekey = `${selector.value}..${selector.value}`;
        break;
      case 'rangekey':
        first = selector.first;
        second = selector.second;
        if (first.type !== 'cellkey') {
          throw new Error(`(MKTS/TABLE µ1237) expected a cellkey, got a ${rpr(first.type)}`);
        }
        if (second.type !== 'cellkey') {
          throw new Error(`(MKTS/TABLE µ1238) expected a cellkey, got a ${rpr(second.type)}`);
        }
        rangekey = `${first.value}..${second.value}`;
    }
    //.........................................................................................................
    /* TAINT should support using variables etc. */
    /* aliases     = @_parse_aliases me, aliases */
    rangeref = IG.GRID.parse_rangekey(me.grid, rangekey);
    fieldnr = (me._tmp.prv_fieldnr += +1);
    if (me.fieldcells[fieldnr] != null) {
      throw new /* should never happen */Error(`(MKTS/TABLE µ1239) unable to redefine field ${fieldnr}: ${rpr(source)}`);
    }
    //.........................................................................................................
    me.fieldcells[fieldnr] = rangeref;
    ref = IG.GRID.walk_cells_from_rangeref(me.grid, rangeref);
    for (fieldcell of ref) {
      ((base = me.cellfields)[name = fieldcell.cellkey] != null ? base[name] : base[name] = []).push(fieldnr);
    }
    //.........................................................................................................
    /* TAINT should support using variables etc.
      for alias in aliases
    ( me.fieldnrs_by_aliases[ alias ]?= [] ).push fieldnr */
    if (id != null) {
      ((base1 = me.fieldnrs_by_aliases)[id] != null ? base1[id] : base1[id] = []).push(fieldnr);
    }
    //.........................................................................................................
    this._set_default_gaps(me, fieldnr);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_default_gaps = function(me, fieldnr) {
    var base, edge, gap, i, j, len, len1, ref, ref1;
    ref = ['fill', 'margins', 'paddings'];
    for (i = 0, len = ref.length; i < len; i++) {
      gap = ref[i];
      ref1 = ['left', 'right', 'top', 'bottom'];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        edge = ref1[j];
        ((base = me.gaps[gap])[fieldnr] != null ? base[fieldnr] : base[fieldnr] = {})[edge] = me.default.gaps[gap];
      }
    }
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_borders = function(me, selectors, edges, style) {
    var base, edge, fieldnr, i, len, ref;
    ref = this.walk_fieldnrs_from_selectors(me, selectors);
    for (fieldnr of ref) {
/* TAINT must resolve symbolic edges like `all` */
      for (i = 0, len = edges.length; i < len; i++) {
        edge = edges[i];
        if (edge !== 'left' && edge !== 'right' && edge !== 'top' && edge !== 'bottom') {
          throw new Error(`µ1240 must resolve symbolic edges like \`all\`, got ${rpr(edge)}`);
        }
        ((base = me.fieldborders)[fieldnr] != null ? base[fieldnr] : base[fieldnr] = {})[edge] = style;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_unit_lengths = function(me, value, unit) {
    this._set_unit_length(me, 'width', value, unit);
    this._set_unit_length(me, 'height', value, unit);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._set_unit_length = function(me, direction, value, unit) {
    var p;
    if (direction !== 'width' && direction !== 'height') {
      throw new Error(`µ1247 expected 'width' or 'height', got ${rpr(direction)}`);
    }
    p = `unit${direction}`;
    //.........................................................................................................
    /* Do nothing if dimension already defined: */
    if (me[p] != null) {
      throw new Error(`µ1247 unable to re-define unit for ${rpr(direction)}`);
    }
    //.........................................................................................................
    me[p] = UNITS.new_quantity(value, unit);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.set_alignment = function(me, selectors, direction, alignment) {
    var fieldnr, ref, target;
    switch (direction) {
      //.......................................................................................................
      case 'horizontal':
        if (alignment !== 'left' && alignment !== 'right' && alignment !== 'center' && alignment !== 'justified') {
          throw new Error(`(MKTS/TABLE µ1241) unknown horizontal alignment ${rpr(alignment)}`);
        }
        target = me.haligns;
        break;
      //.......................................................................................................
      case 'vertical':
        if (alignment !== 'top' && alignment !== 'bottom' && alignment !== 'center' && alignment !== 'spread') {
          throw new Error(`(MKTS/TABLE µ1242) unknown vertical alignment ${rpr(alignment)}`);
        }
        target = me.valigns;
        break;
      default:
        throw new Error(`µ1243 unknown direction ${rpr(direction)}`);
    }
    ref = this.walk_fieldnrs_from_selectors(me, selectors);
    //.........................................................................................................
    for (fieldnr of ref) {
      target[fieldnr] = alignment;
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.walk_fieldnrs_from_selectors = function*(me, selectors) {
    var cellref, fieldnr, i, j, k, len, len1, len2, ref, ref1, ref2, ref3, ref4, seen_fieldnrs, selector;
    seen_fieldnrs = new Set();
//.........................................................................................................
    for (i = 0, len = selectors.length; i < len; i++) {
      selector = selectors[i];
      switch (selector.type) {
        case 'cellkey':
          ref = IG.GRID.walk_cells_from_key(me.grid, selector.value);
          for (cellref of ref) {
            ref2 = (ref1 = me.cellfields[cellref.cellkey]) != null ? ref1 : [];
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              fieldnr = ref2[j];
              if (seen_fieldnrs.has(fieldnr)) {
                continue;
              }
              seen_fieldnrs.add(fieldnr);
              yield fieldnr;
            }
          }
          break;
        case 'id':
          ref4 = (ref3 = me.fieldnrs_by_aliases[selector.id]) != null ? ref3 : [];
          for (k = 0, len2 = ref4.length; k < len2; k++) {
            fieldnr = ref4[k];
            if (seen_fieldnrs.has(fieldnr)) {
              continue;
            }
            seen_fieldnrs.add(fieldnr);
            yield fieldnr;
          }
          break;
        default:
          warn('µ1245', `ignoring selector type ${selector.type}`);
      }
    }
    //.........................................................................................................
    if (seen_fieldnrs.size === 0) {
      throw new Error(`µ1244 selectors ${rpr(selectors)} do not match any field`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this.walk_cellrefs_from_selectors = function*(me, selectors) {
    var cellref, count, fieldnr, i, j, len, len1, ref, ref1, ref2, ref3, seen_cellkeys, selector;
    count = 0;
    seen_cellkeys = new Set();
//.........................................................................................................
    for (i = 0, len = selectors.length; i < len; i++) {
      selector = selectors[i];
      switch (selector.type) {
        case 'cellkey':
          ref = IG.GRID.walk_cells_from_key(me.grid, selector.value);
          for (cellref of ref) {
            if (seen_cellkeys.has(cellref.cellkey)) {
              continue;
            }
            seen_cellkeys.add(cellref.cellkey);
            count += +1;
            yield cellref;
          }
          break;
        case 'id':
          ref2 = (ref1 = me.fieldnrs_by_aliases[selector.id]) != null ? ref1 : [];
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            fieldnr = ref2[j];
            ref3 = this.walk_cellrefs_from_fieldnr(me, fieldnr);
            for (cellref of ref3) {
              if (seen_cellkeys.has(cellref.cellkey)) {
                continue;
              }
              seen_cellkeys.add(cellref.cellkey);
              count += +1;
              yield cellref;
            }
          }
          break;
        default:
          warn('µ1245', `ignoring selector type ${selector.type}`);
      }
    }
    //.........................................................................................................
    if (count === 0) {
      throw new Error(`µ1246 selectors ${rpr(selectors)} do not match any cell`);
    }
  };

  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this.walk_cellrefs_from_fieldnr = function*(me, fieldnr) {
    var cellref, rangeref, ref;
    if ((rangeref = me.fieldcells[fieldnr]) == null) {
      throw new Error(`µ1246 unknown fieldnr ${rpr(fieldnr)}`);
    }
    ref = IG.GRID.walk_cells_from_rangeref(me.grid, rangeref);
    for (cellref of ref) {
      yield cellref;
    }
  };

  /* ***************************************************** */
  /* ***************************************************** */
  /* ***************************************************** */
  /* ***************************************************** */
  /* ***************************************************** */
  //-----------------------------------------------------------------------------------------------------------
  //.........................................................................................................
  this._set_lanesizes = function(me, direction, text) {
    var base, base1, fail, i, j, lane_count, lanenr, length, match, nr, p, ps, ref, ref1, ref2, selector, x;
    if (direction !== 'width' && direction !== 'height') {
      throw _stackerr(me, 'µ1249', `expected 'width' or 'height', got ${rpr(direction)}`);
    }
    //.........................................................................................................
    p = direction === 'width' ? 'colwidth' : 'rowheight';
    ps = direction === 'width' ? 'colwidths' : 'rowheights';
    //.........................................................................................................
    this._ensure_grid(me);
    lane_count = me.grid[direction];
    //.........................................................................................................
    if ((match = text.match(/^(?:(?<selector>[^:]+):)?(?<length>[+\d.]+)$/)) == null) {
      _record_fail(me, 'µ1250', `need a text like '2.7', 'A*,C3:20' or similar for mkts-table/${p}, got ${rpr(text)}`);
      return null;
    }
    //.........................................................................................................
    ({selector, length} = match.groups);
    length = parseFloat(length);
    //.........................................................................................................
    if (selector != null) {
      if ((base = me[ps])[0] == null) {
        base[0] = me.default[p];
      }
      for (nr = i = 1, ref = lane_count; (1 <= ref ? i <= ref : i >= ref); nr = 1 <= ref ? ++i : --i) {
        if ((base1 = me[ps])[nr] == null) {
          base1[nr] = me.default[p];
        }
      }
      ref1 = this._walk_fails_and_lanenrs_from_direction_and_selector(me, direction, selector);
      /* set defaults where missing */
      for (x of ref1) {
        [fail, lanenr] = x;
        if (fail != null) {
          _record(me, fail);
        } else {
          me[ps][lanenr] = length;
        }
      }
    } else {
      me[ps][0] = length/* set default */
      for (nr = j = 1, ref2 = lane_count; (1 <= ref2 ? j <= ref2 : j >= ref2); nr = 1 <= ref2 ? ++j : --j) {
        me[ps][nr] = length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.unitwidth = function(me, text) {
    return this._set_unitsize(me, 'width', text);
  };

  this.unitheight = function(me, text) {
    return this._set_unitsize(me, 'height', text);
  };

  this.columnwidth = function(me, text) {
    return this._set_lanesizes(me, 'width', text);
  };

  this.rowheight = function(me, text) {
    return this._set_lanesizes(me, 'height', text);
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @_resolve_aliases = ( me, selector ) ->
  //   ### Given a comma-separated string or a list of cellkeys, cellrange literals, and / or aliases, return a
  //   list of cellkeys and / or cellrange literals. ###
  //   return @_resolve_aliases me, selector.split /\s*,\s*/ if CND.isa_text selector
  //   R = new Set()
  //   for term in selector
  //     if ( CND.isa_text term ) and ( term.startsWith '@' )
  //       unless ( fieldnrs = me.fieldnrs_by_aliases[ term ] )?
  //         ### TAINT error or failure? ###
  //         throw new Error "(MKTS/TABLE µ1251) unknown alias #{rpr term}"
  //       R.add fieldnr for fieldnr in fieldnrs
  //     else
  //       R.add term
  //   return [ R... ]

  //-----------------------------------------------------------------------------------------------------------
  this.fieldalignvertical = function(me, text) {
    var _, fail, field_designation, match, ref, selector, value, x;
    if ((match = text.match(/^(.+?):([^:]+)$/)) == null) {
      throw new Error(`(MKTS/TABLE µ1252) expected something like 'C3:top' for mkts-table/fieldalignvertical, got ${rpr(text)}`);
    }
    [_, selector, value] = match;
    //.........................................................................................................
    if (value !== 'top' && value !== 'bottom' && value !== 'center' && value !== 'spread') {
      throw new Error(`(MKTS/TABLE µ1253) expected one of 'top', 'bottom', 'center', 'spread' for mkts-table/fieldalignvertical, got ${rpr(value)}`);
    }
    ref = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (x of ref) {
      [fail, field_designation] = x;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({field_designation})})`);
      } else {
        me.valigns[field_designation] = value;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fieldalignhorizontal = function(me, text) {
    var _, fail, field_designation, match, ref, selector, value, x;
    if ((match = text.match(/^(.+?):([^:]+)$/)) == null) {
      throw new Error(`(MKTS/TABLE µ1254) expected something like 'C3:left' for mkts-table/fieldalignhorizontal, got ${rpr(text)}`);
    }
    [_, selector, value] = match;
    //.........................................................................................................
    if (value !== 'left' && value !== 'right' && value !== 'center' && value !== 'justified') {
      throw new Error(`(MKTS/TABLE µ1255) expected one of 'left', 'right', 'center', 'justified' for mkts-table/fieldalignhorizontal, got ${rpr(value)}`);
    }
    ref = this._walk_fails_and_fieldnrs_from_selector(me, selector);
    //.........................................................................................................
    for (x of ref) {
      [fail, field_designation] = x;
      /* TAINT ad-hoc fail message production, use method */
      if (fail != null) {
        _record(me, `${fail} (${jr({field_designation})})`);
      } else {
        me.haligns[field_designation] = value;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.margin = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, i, j, len, len1, ref, ref1;
    d = this._parse_fieldgap(me, 'margin', text);
    ref = d.fieldnames;
    for (i = 0, len = ref.length; i < len; i++) {
      fieldname = ref[i];
      ref1 = d.edges;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        edge = ref1[j];
        ((base = me.gaps.margins)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.padding = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, i, j, len, len1, ref, ref1;
    d = this._parse_fieldgap(me, 'padding', text);
    ref = d.fieldnames;
    for (i = 0, len = ref.length; i < len; i++) {
      fieldname = ref[i];
      ref1 = d.edges;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        edge = ref1[j];
        ((base = me.gaps.paddings)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.fill_gap = function(me, text) {
    /* TAINT code duplication */
    var base, d, edge, fieldname, i, j, len, len1, ref, ref1;
    d = this._parse_fieldgap(me, 'fill', text);
    ref = d.fieldnames;
    for (i = 0, len = ref.length; i < len; i++) {
      fieldname = ref[i];
      ref1 = d.edges;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        edge = ref1[j];
        ((base = me.gaps.fill)[fieldname] != null ? base[fieldname] : base[fieldname] = {})[edge] = d.length;
      }
    }
    //.........................................................................................................
    return null;
  };

}).call(this);

//# sourceMappingURL=mkts-table-api.js.map
