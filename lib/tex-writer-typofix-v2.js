// Generated by CoffeeScript 1.10.0

/*

{\latin{}a}{\latin{}g}{\latin{}f}{\latin{}i}{\latin{} }{\cjk{}{\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}}}{\cjk{}{\cn{}里}}{\cjk{}{\cnxb{}{\cnxJzr{}}}}{\latin{} }{\cjk{}{\cn{}里}}{\cjk{}{\cnxa{}䊷}}{\mktsRsgFb{}இ}{\latin{} }{\latin{}a}{\latin{}g}{\latin{}f}{\latin{}i}

agfi {\cjk{}\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}里{\cnxb{}\cnxJzr{}} 里{\cnxa{}䊷}}{\mktsRsgFb{}இ} agfi

agfi {\cjk{}\cn{}{\tfRaise{-0.2}\cnxBabel{}癶}里\cnxb{}\cnxJzr{}\cn 里\cnxa{}䊷}{\mktsRsgFb{}இ} agfi
 */

(function() {
  var $, CND, D, MD_READER, MKNCR, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, rpr, select, stamp, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'mkts/tex-writer-typofix';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('../../../pipedreams');

  $ = D.$;

  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  MKNCR = require('../../mingkwai-ncr');

  this.$escape_for_tex = function(S) {

    /* TAINT should preserve raw text from before replacements */
    return $((function(_this) {
      return function(event, send) {
        var i, len, meta, name, pattern, raw_text, ref, ref1, replacement, text, type;
        if (!select(event, '.', 'text')) {
          return send(event);
        }
        type = event[0], name = event[1], raw_text = event[2], meta = event[3];
        text = raw_text;
        ref = _this.$escape_for_tex._replacements;
        for (i = 0, len = ref.length; i < len; i++) {
          ref1 = ref[i], pattern = ref1[0], replacement = ref1[1];
          text = text.replace(pattern, replacement);
        }
        return send([type, name, text, meta]);
      };
    })(this));
  };

  this.$escape_for_tex._replacements = [[/\x01/g, '\x01\x02'], [/\x5c/g, '\x01\x01'], [/\{/g, '\\{'], [/\}/g, '\\}'], [/\$/g, '\\$'], [/\#/g, '\\#'], [/%/g, '\\%'], [/_/g, '\\_'], [/\^/g, '\\textasciicircum{}'], [/~/g, '\\textasciitilde{}'], [/&/g, '\\&'], [/\x01\x01/g, '\\textbackslash{}'], [/\x01\x02/g, '\x01']];

  this.$format_cjk = function(S) {

    /* TAINT should preserve raw text from before replacements */

    /* TAINT must look for stream end */

    /* TAINT use piped streams for logic */
    return $((function(_this) {
      return function(event, send) {
        var description, glyph, glyphs, i, len, meta, name, raw_text, tag, text, type;
        if (!select(event, '.', 'text')) {
          return send(event);
        }
        type = event[0], name = event[1], raw_text = event[2], meta = event[3];
        text = raw_text;
        glyphs = MKNCR.chrs_from_text(text);
        for (i = 0, len = glyphs.length; i < len; i++) {
          glyph = glyphs[i];
          description = MKNCR.describe(glyph);
          tag = description.tag;

          /* TAINT not the real thing */
          if ((tag != null) && indexOf.call(tag, 'cjk') >= 0) {
            send(['tex', "{\\cjk\\cn{}" + glyph + "}"]);
          } else {
            send(['.', 'text', glyph, meta]);
          }
        }
        return null;
      };
    })(this));
  };

  this.$fix_typography_for_tex = function(S) {

    /* TAINT which one should come first? */
    var pipeline;
    pipeline = [this.$format_cjk(S), this.$escape_for_tex(S)];
    return D.new_stream({
      pipeline: pipeline
    });
  };

}).call(this);
