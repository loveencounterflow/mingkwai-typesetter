// Generated by CoffeeScript 2.3.1
(function() {
  'use strict';
  var $, $async, CND, MD_READER, PATH, PIPEDREAMS, PS, alert, badge, copy, debug, echo, help, hide, info, is_hidden, is_stamped, log, rpr, select, stamp, urge, warn, whisper,
    splice = [].splice;

  //###########################################################################################################
  PATH = require('path');

  // njs_fs                    = require 'fs'
  //...........................................................................................................
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'mkts/tex-writer-call';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  PIPEDREAMS = require('../../../pipedreams');

  PS = require('pipestreams');

  ({$, $async} = PS);

  //...........................................................................................................
  MD_READER = require('./md-reader');

  hide = MD_READER.hide.bind(MD_READER);

  copy = MD_READER.copy.bind(MD_READER);

  stamp = MD_READER.stamp.bind(MD_READER);

  select = MD_READER.select.bind(MD_READER);

  is_hidden = MD_READER.is_hidden.bind(MD_READER);

  is_stamped = MD_READER.is_stamped.bind(MD_READER);

  //-----------------------------------------------------------------------------------------------------------
  this._resolve_arguments = (S, event) => {
    var P, crumb, crumbs, error, i, len, locator, meta, method_name, method_path, module, module_path, name, parameters, ref, reference_path, type;
    reference_path = S.layout_info['source-home'];
    [type, name, parameters, meta] = event;
    [module_path, method_path, ...P] = parameters;
    locator = PATH.join(reference_path, module_path);
    ref = method_path.split('.'), [...crumbs] = ref, [method_name] = splice.call(crumbs, -1);
    try {
      //.....................................................................................................
      module = require(locator);
      for (i = 0, len = crumbs.length; i < len; i++) {
        crumb = crumbs[i];
        module = module[crumb];
      }
    } catch (error1) {
      error = error1;
      alert('98987', `when trying to resolve ${crumbs.join('.')}`);
      alert('98987', `starting with module ${rpr(locator)}`);
      alert('98987', `an error occurred at path component ${rpr(crumb)}`);
      throw error;
    }
    //.....................................................................................................
    return {type, name, parameters, meta, module_path, method_path, P, method_name, locator, module, crumbs};
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$call_await = (S) => {
    /* TAINT implicitly assumes return value will be lines of text */
    /* parses MKTS commands of the form `<<!call_await module_path, method_name, parameters... >>` */
    // self = @
    return PIPEDREAMS.$async(async(event, send, end) => {
      var P, crumbs, error, i, len, line, lines, locator, meta, method_name, module;
      //.......................................................................................................
      if ((event != null) && select(event, '!', 'call_await')) {
        ({module, method_name, P, meta, locator, crumbs} = this._resolve_arguments(S, event));
        try {
          //.....................................................................................................
          lines = (await module[method_name](...P));
        } catch (error1) {
          //.....................................................................................................
          error = error1;
          alert('98987', `when trying to call method ${rpr(method_name)}`);
          alert('98987', `from module ${rpr(locator)}#${crumbs.join('.')}`);
          alert('98987', `with arguments ${rpr(P)}`);
          alert('98987', "an error occurred:");
          alert('98987', error.message);
          if (throw_all_errors) {
            throw error;
          }
          send(['.', 'warning', error.message, copy(meta)]);
          return send.done();
        }
//.....................................................................................................
        for (i = 0, len = lines.length; i < len; i++) {
          line = lines[i];
          if (CND.isa_text(line)) {
            if (!line.endsWith('\n')) {
              line = line + '\n';
            }
            send(['.', 'text', line, copy(meta)]);
          } else {
            send(line);
          }
        }
        send.done();
      } else {
        //.......................................................................................................
        send(event);
        send.done();
      }
      if (end != null) {
        //.......................................................................................................
        end();
      }
      return null;
    });
  };

  //-----------------------------------------------------------------------------------------------------------
  this.$call_stream = (S) => {
    /* TAINT implicitly assumes return value will be lines of text */
    // self = @
    return PIPEDREAMS.$async(async(event, send, end) => {
      var P, crumbs, error, locator, meta, method_name, module, on_stop, pipeline;
      //.......................................................................................................
      if ((event != null) && select(event, '!', 'call_stream')) {
        ({module, method_name, P, meta, locator, crumbs} = this._resolve_arguments(S, event));
        try {
          //.....................................................................................................
          on_stop = PS.new_event_collector('stop', function() {
            send.done();
            return help(`(finished $call_stream ${method_name})`);
          });
          pipeline = [];
          pipeline.push((await module[method_name](...P)));
          pipeline.push(PS.$watch(function(line) {
            if (CND.isa_text(line)) {
              if (!line.endsWith('\n')) {
                line = line + '\n';
              }
              send(['.', 'text', line, copy(meta)]);
            } else {
              send(line);
            }
            return null;
          }));
          pipeline.push(on_stop.add(PS.$drain()));
          PS.pull(...pipeline);
        } catch (error1) {
          //.....................................................................................................
          error = error1;
          alert('98987', `when trying to call method ${rpr(method_name)}`);
          alert('98987', `from module ${rpr(locator)}#${crumbs.join('.')}`);
          alert('98987', `with arguments ${rpr(P)}`);
          alert('98987', "an error occurred:");
          alert('98987', error.message);
          throw error;
        }
      } else {
        //.......................................................................................................
        send(event);
        send.done();
      }
      if (end != null) {
        //.......................................................................................................
        end();
      }
      return null;
    });
  };

}).call(this);

//# sourceMappingURL=tex-writer-call.js.map
