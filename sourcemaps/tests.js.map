{"version":3,"sources":["tests.coffee"],"names":[],"mappings":"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","file":"tests.js","sourceRoot":"/source/","sourcesContent":["\n\n\n\n\n\n############################################################################################################\nnjs_path                  = require 'path'\n# njs_fs                    = require 'fs'\njoin                      = njs_path.join\n#...........................................................................................................\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'JIZURA/tests'\nlog                       = CND.get_logger 'plain',     badge\ninfo                      = CND.get_logger 'info',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\nalert                     = CND.get_logger 'alert',     badge\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\nhelp                      = CND.get_logger 'help',      badge\nurge                      = CND.get_logger 'urge',      badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nsuspend                   = require 'coffeenode-suspend'\nstep                      = suspend.step\nafter                     = suspend.after\n# eventually                = suspend.eventually\n### TAINT experimentally using `later` in place of `setImmediate` ###\nlater                     = suspend.immediately\n#...........................................................................................................\ntest                      = require 'guy-test'\n#...........................................................................................................\nD                         = require 'pipedreams'\n$                         = D.remit.bind D\n$async                    = D.remit_async.bind D\n#...........................................................................................................\nMKTS                      = require './main'\n\n\n#===========================================================================================================\n# HELPERS\n#-----------------------------------------------------------------------------------------------------------\nshow_events = ( probe, events ) ->\n  whisper probe\n  echo \"[\"\n  for event in events\n    echo \"    #{JSON.stringify event}\"\n  echo \"    ]\"\n\n#-----------------------------------------------------------------------------------------------------------\ncopy_regex_non_global = ( re ) ->\n  flags = ( if re.ignoreCase then 'i' else '' ) + \\\n          ( if re.multiline  then 'm' else '' ) +\n          ( if re.sticky     then 'y' else '' )\n  return new RegExp re.source, flags\n\n#-----------------------------------------------------------------------------------------------------------\nlist_from_match = ( match ) ->\n  return null unless match?\n  R = Array.from match\n  R.splice 0, 1\n  return R\n\n#-----------------------------------------------------------------------------------------------------------\nmatch_first = ( patterns, probe ) ->\n  for pattern in patterns\n    return R if ( R = probe.match pattern )?\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\nnice_text_rpr = ( text ) ->\n  ### Ad-hoc method to print out text in a readable, CoffeeScript-compatible, triple-quoted way. Line breaks\n  (`\\\\n`) will be shown as line breaks, so texts should not be as spaghettified as they appear with\n  JSON.stringify (the last line break of a string is, however, always shown in its symbolic form so it\n  won't get swallowed by the CoffeeScript parser). Code points below U+0020 (space) are shown as\n  `\\\\x00`-style escapes, taken up less space than `\\u0000` escapes while keeping things explicit. All\n  double quotes will be prepended with a backslash. ###\n  R = text\n  R = R.replace /[\\x00-\\x09\\x0b-\\x19]/g, ( $0 ) ->\n    cid_hex = ( $0.codePointAt 0 ).toString 16\n    cid_hex = '0' + cid_hex if cid_hex.length is 1\n    return \"\\\\x#{cid_hex}\"\n  R = R.replace /\"/g, '\\\\\"'\n  R = R.replace /\\n$/g, '\\\\n'\n  R = '\\n\"\"\"' + R + '\"\"\"'\n  return R\n\n# #===========================================================================================================\n# # TESTS\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.action_patterns match action macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"<<(.>><<)>>\",[\"\",\".\",\"\",\"\",\"\"]]\n#     [\"<<(.>>xxx<<)>>\",[\"\",\".\",\"\",\"xxx\",\"\"]]\n#     [\"<<(.>>some code<<)>>\",[\"\",\".\",\"\",\"some code\",\"\"]]\n#     [\"abc<<(.>>4 + 3<<)>>def\",[\"c\",\".\",\"\",\"4 + 3\",\"\"]]\n#     [\"<<(:>><<)>>\",[\"\",\":\",\"\",\"\",\"\"]]\n#     [\"<<(:>>xxx<<)>>\",[\"\",\":\",\"\",\"xxx\",\"\"]]\n#     [\"<<(:>>some code<<)>>\",[\"\",\":\",\"\",\"some code\",\"\"]]\n#     [\"abc<<(:>>4 + 3<<)>>def\",[\"c\",\":\",\"\",\"4 + 3\",\"\"]]\n#     [\"abc<<(:>>bitfield \\\\>> 1 <<)>>def\",[\"c\",\":\",\"\",\"bitfield \\\\>> 1 \",\"\"]]\n#     [\"abc<<(:>>bitfield >\\\\> 1 <<)>>def\",[\"c\",\":\",\"\",\"bitfield >\\\\> 1 \",\"\"]]\n#     [\"abc<<(:js>>4 + 3<<)>>def\",[\"c\",\":\",\"js\",\"4 + 3\",\"\"]]\n#     [\"abc<<(.js>>4 + 3<<)>>def\",[\"c\",\".\",\"js\",\"4 + 3\",\"\"]]\n#     [\"abc<<(:js>>4 + 3<<:js)>>def\",[\"c\",\":\",\"js\",\"4 + 3\",\":js\"]]\n#     [\"abc<<(.js>>4 + 3<<.js)>>def\",[\"c\",\".\",\"js\",\"4 + 3\",\".js\"]]\n#     [\"abc<<(:js>>4 + 3<<:)>>def\",null]\n#     [\"abc<<(.js>>4 + 3<<.)>>def\",null]\n#     ]\n#   patterns = ( copy_regex_non_global pattern for pattern in MKTS.MACRO_ESCAPER.action_patterns )\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = list_from_match match_first patterns, probe\n#     help JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.region_patterns match region macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"<<(>><<)>>\",[\"\",\"(\",\"\",\"\"]]\n#     [\"<<(bold>><<)>>\",[\"\",\"(\",\"bold\",\"\"]]\n#     [\"<<(bold>><<bold)>>\",[\"\",\"(\",\"bold\",\"\"]]\n#     [\"<<(foo>><<bar)>>\",[\"\",\"(\",\"foo\",\"\"]]\n#     [\"yadda <<(foo>>grom<<bar)>> blah <<)>>\",[\" \",\"(\",\"foo\",\"\"]]\n#     [\"yadda <<bar)>> blah <<)>>\",[\" \",\"\",\"bar\",\")\"]]\n#     ]\n#   patterns = ( copy_regex_non_global pattern for pattern in MKTS.MACRO_ESCAPER.region_patterns )\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = list_from_match match_first patterns, probe\n#     help JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.bracketed_raw_patterns matches raw macro\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"<<<...raw material...>>>\",[\"\",\"<\",\"...raw material...\"]]\n#     [\"<<(.>>some code<<)>>\",null]\n#     [\"<<<>>>\",[\"\",\"<\",\"\"]]\n#     [\"abcdef<<<\\\\XeLaTeX{}>>>ghijklm\",[\"f\",\"<\",\"\\\\XeLaTeX{}\"]]\n#     [\"abcdef<<<123\\\\>>>0>>>ghijklm\",[\"f\",\"<\",\"123\\\\>>>0\"]]\n#     [\"abcdef\\\\<<<123>>>ghijklm\",null]\n#     [\"abcdef<\\\\<<123>>>ghijklm\",null]\n#     [\"abcdef<<\\\\<123>>>ghijklm\",null]\n#     [\"abcdef<<<123>>\\\\>ghijklm\",null]\n#     ]\n#   patterns = ( copy_regex_non_global pattern for pattern in MKTS.MACRO_ESCAPER.bracketed_raw_patterns )\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = list_from_match match_first patterns, probe\n#     help JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.command_and_value_patterns matches command macro\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"<<!>>\",[\"\",\"!\",\"\"]]\n#     [\"<<!name>>\",[\"\",\"!\",\"name\"]]\n#     [\"abc<<!name>>def\",[\"c\",\"!\",\"name\"]]\n#     [\"abc<<!n>me>>def\",[\"c\",\"!\",\"n>me\"]]\n#     [\"abc<<!n>\\\\>me>>def\",[\"c\",\"!\",\"n>\\\\>me\"]]\n#     [\"abc<<!n\\\\>me>>def\",[\"c\",\"!\",\"n\\\\>me\"]]\n#     [\"abc\\\\<<!nme>>def\",null]\n#     [\"<<$>>\",[\"\",\"$\",\"\"]]\n#     [\"<<$name>>\",[\"\",\"$\",\"name\"]]\n#     [\"abc<<$name>>def\",[\"c\",\"$\",\"name\"]]\n#     [\"abc<<$n>me>>def\",[\"c\",\"$\",\"n>me\"]]\n#     [\"abc<<$n>\\\\>me>>def\",[\"c\",\"$\",\"n>\\\\>me\"]]\n#     [\"abc<<$n\\\\>me>>def\",[\"c\",\"$\",\"n\\\\>me\"]]\n#     [\"abc\\\\<<$nme>>def\",null]\n#     ]\n#   patterns = ( copy_regex_non_global pattern for pattern in MKTS.MACRO_ESCAPER.command_and_value_patterns )\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = list_from_match match_first patterns, probe\n#     help JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.illegal_patterns matches consecutive unescaped LPBs\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"helo world\",null]\n#     [\"helo \\\\<< world\",null]\n#     [\"helo <\\\\< world\",null]\n#     [\"helo << world\",[\" \",\"<<\"]]\n#     ]\n#   patterns = ( copy_regex_non_global pattern for pattern in MKTS.MACRO_ESCAPER.illegal_patterns )\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = list_from_match match_first patterns, probe\n#     help JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.end_command_patterns matches end command macro\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"some text here <<!end>> and some there\",[\"some text here \"]]\n#     [\"some text here <<!end>>\",[\"some text here \"]]\n#     [\"<<!end>>\",[\"\"]]\n#     [\"\",null]\n#     [\"<<!end>> and some there\",[\"\"]]\n#     [\"\\\\<<!end>> and some there\",null]\n#     [\"some text here \\\\<<!end>> and some there\",null]\n#     [\"some text here <<!end>\\\\> and some there\",null]\n#     ]\n#   patterns = MKTS.MACRO_ESCAPER.end_command_patterns\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = list_from_match match_first patterns, probe\n#     help JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.escape.truncate_text_at_end_command_macro\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"some text here <<!end>> and some there\",[\"some text here \",23]]\n#     [\"some text here <<!end>>\",[\"some text here \",8]]\n#     [\"<<!end>>\",[\"\",8]]\n#     [\"\",[\"\",0]]\n#     [\"<<!end>> and some there\",[\"\",23]]\n#     [\"\\\\<<!end>> and some there\",[\"\\\\<<!end>> and some there\",0]]\n#     [\"some text here \\\\<<!end>> and some there\",[\"some text here \\\\<<!end>> and some there\",0]]\n#     [\"some text here <<!end>\\\\> and some there\",[\"some text here <<!end>\\\\> and some there\",0]]\n#     [\"\\n\\nfoo bar\\n\\n\\n\\n<<!end>>\\ndiscarded\",[\"\\n\\nfoo bar\\n\\n\\n\\n\",18]]\n#     [\"\\n\\nfoo bar\\n\\n\\n\\n<<!end>>\\ndiscarded<<!end>>\\ndiscarded as well\",[\"\\n\\nfoo bar\\n\\n\\n\\n\",44]]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     result = MKTS.MACRO_ESCAPER.escape.truncate_text_at_end_command_macro null, probe\n#     help JSON.stringify [ probe, result, ]\n#     T.eq result, matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.escape.html_comments\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"some text here and some there\",\"some text here and some there\",[]]\n#     [\"some text here<!-- omit this --> and some there\",\"some text here\\u0015comment0\\u0013 and some there\",[{\"key\":\"comment0\",\"markup\":null,\"raw\":\" omit this \",\"parsed\":\"omit this\"}]]\n#     [\"some text here\\\\<!-- omit this --> and some there\",\"some text here\\\\<!-- omit this --> and some there\",[]]\n#     [\"abcd<<<some raw content>>>efg\",\"abcd<<<some raw content>>>efg\",[]]\n#     ]\n#   for [ probe, text_matcher, registry_matcher, ] in probes_and_matchers\n#     S = MKTS.MACRO_ESCAPER.initialize_state {}\n#     text_result = MKTS.MACRO_ESCAPER.escape.html_comments S, probe\n#     help JSON.stringify [ probe, text_result, S.MACRO_ESCAPER[ 'registry' ], ]\n#     T.eq text_result, text_matcher\n#     T.eq S.MACRO_ESCAPER[ 'registry' ], registry_matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.escape.bracketed_raw_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"some text here<<!foo>>and some there\",\"some text here<<!foo>>and some there\",[]]\n#     [\"abcd<<<some raw content>>>efg\",\"abcd\\u0015raw0\\u0013efg\",[{\"key\":\"raw0\",\"markup\":\"<\",\"raw\":\"some raw content\",\"parsed\":null}]]\n#     [\"abcd\\\\<<<some raw content>>>efg\",\"abcd\\\\<<<some raw content>>>efg\",[]]\n#     ]\n#   for [ probe, text_matcher, registry_matcher, ] in probes_and_matchers\n#     S = MKTS.MACRO_ESCAPER.initialize_state {}\n#     text_result = MKTS.MACRO_ESCAPER.escape.bracketed_raw_macros S, probe\n#     help JSON.stringify [ probe, text_result, S.MACRO_ESCAPER[ 'registry' ], ]\n#     T.eq text_result, text_matcher\n#     T.eq S.MACRO_ESCAPER[ 'registry' ], registry_matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.escape.region_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"some text here <<(>><<)>>\",\"some text here \\u0015region0\\u0013\\u0015region1\\u0013\",[{\"key\":\"region0\",\"markup\":\"(\",\"raw\":\"\",\"parsed\":null},{\"key\":\"region1\",\"markup\":\")\",\"raw\":\"\",\"parsed\":null}]]\n#     [\"some text here <<(em>><<)>>\",\"some text here \\u0015region0\\u0013\\u0015region1\\u0013\",[{\"key\":\"region0\",\"markup\":\"(\",\"raw\":\"em\",\"parsed\":null},{\"key\":\"region1\",\"markup\":\")\",\"raw\":\"\",\"parsed\":null}]]\n#     [\"some text here <<(em>>and some there<<)>><<(more>>markup<<)>>\",\"some text here \\u0015region0\\u0013and some there\\u0015region2\\u0013\\u0015region1\\u0013markup\\u0015region3\\u0013\",[{\"key\":\"region0\",\"markup\":\"(\",\"raw\":\"em\",\"parsed\":null},{\"key\":\"region1\",\"markup\":\"(\",\"raw\":\"more\",\"parsed\":null},{\"key\":\"region2\",\"markup\":\")\",\"raw\":\"\",\"parsed\":null},{\"key\":\"region3\",\"markup\":\")\",\"raw\":\"\",\"parsed\":null}]]\n#     [\"some text here <<(em>>and some there<<foo)>>\",\"some text here \\u0015region0\\u0013and some there\\u0015region1\\u0013\",[{\"key\":\"region0\",\"markup\":\"(\",\"raw\":\"em\",\"parsed\":null},{\"key\":\"region1\",\"markup\":\")\",\"raw\":\"foo\",\"parsed\":null}]]\n#     ]\n#   for [ probe, text_matcher, registry_matcher, ] in probes_and_matchers\n#     S = MKTS.MACRO_ESCAPER.initialize_state {}\n#     text_result = MKTS.MACRO_ESCAPER.escape.region_macros S, probe\n#     # log CND.white rpr probe\n#     # urge rpr text_result\n#     help JSON.stringify [ probe, text_result, S.MACRO_ESCAPER[ 'registry' ], ]\n#     T.eq text_result, text_matcher\n#     T.eq S.MACRO_ESCAPER[ 'registry' ], registry_matcher\n#   # T.fail 'not ready'\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.escape.action_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"<<(.>><<)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"coffee\"],\"raw\":\"\",\"parsed\":null}]]\n#     [\"<<(.>><<.)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"coffee\"],\"raw\":\"\",\"parsed\":null}]]\n#     [\"<<(.>>xxx<<)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"coffee\"],\"raw\":\"xxx\",\"parsed\":null}]]\n#     [\"<<(.>>xxx<<.)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"coffee\"],\"raw\":\"xxx\",\"parsed\":null}]]\n#     [\"<<(.>>some code<<)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"coffee\"],\"raw\":\"some code\",\"parsed\":null}]]\n#     [\"<<(.>>some code<<.)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"coffee\"],\"raw\":\"some code\",\"parsed\":null}]]\n#     [\"abc<<(.>>4 + 3<<)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"coffee\"],\"raw\":\"4 + 3\",\"parsed\":null}]]\n#     [\"<<(:>><<)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"\",\"parsed\":null}]]\n#     [\"<<(:>>xxx<<)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"xxx\",\"parsed\":null}]]\n#     [\"<<(:>>some code<<)>>\",\"\\u0015action0\\u0013\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"some code\",\"parsed\":null}]]\n#     [\"abc<<(:>>4 + 3<<)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"4 + 3\",\"parsed\":null}]]\n#     [\"abc<<(:>>bitfield \\\\>> 1 <<)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"bitfield \\\\>> 1 \",\"parsed\":null}]]\n#     [\"abc<<(:>>bitfield >\\\\> 1 <<)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"bitfield >\\\\> 1 \",\"parsed\":null}]]\n#     [\"abc<<(:js>>4 + 3<<)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"js\"],\"raw\":\"4 + 3\",\"parsed\":null}]]\n#     [\"abc<<(.js>>4 + 3<<)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"js\"],\"raw\":\"4 + 3\",\"parsed\":null}]]\n#     [\"abc<<(:js>>4 + 3<<:js)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"vocal\",\"js\"],\"raw\":\"4 + 3\",\"parsed\":null}]]\n#     [\"abc<<(.js>>4 + 3<<.js)>>def\",\"abc\\u0015action0\\u0013def\",[{\"key\":\"action0\",\"markup\":[\"silent\",\"js\"],\"raw\":\"4 + 3\",\"parsed\":null}]]\n#     [\"abc<<(:js>>4 + 3<<:)>>def\",\"abc<<(:js>>4 + 3<<:)>>def\",[]]\n#     [\"abc<<(.js>>4 + 3<<.)>>def\",\"abc<<(.js>>4 + 3<<.)>>def\",[]]\n#     ]\n#   for [ probe, text_matcher, registry_matcher, ] in probes_and_matchers\n#     S = MKTS.MACRO_ESCAPER.initialize_state {}\n#     text_result = MKTS.MACRO_ESCAPER.escape.action_macros S, probe\n#     # log CND.white rpr probe\n#     # urge rpr text_result\n#     help JSON.stringify [ probe, text_result, S.MACRO_ESCAPER[ 'registry' ], ]\n#     T.eq text_result, text_matcher\n#     T.eq S.MACRO_ESCAPER[ 'registry' ], registry_matcher\n#   # debug '©ΤΓΘΤΝ', MKTS.MACRO_ESCAPER.action_and_region_patterns[ 0 ]\n#   # debug '©ΤΓΘΤΝ', MKTS.MACRO_ESCAPER.action_and_region_patterns[ 1 ]\n#   # T.fail 'not ready'\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.escape.command_and_value_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"some text here <<!foo>> and some there\",\"some text here \\u0015command0\\u0013 and some there\",[{\"key\":\"command0\",\"markup\":\"!\",\"raw\":\"foo\",\"parsed\":null}]]\n#     [\"some text here <<$foo>> and some there\",\"some text here \\u0015value0\\u0013 and some there\",[{\"key\":\"value0\",\"markup\":\"$\",\"raw\":\"foo\",\"parsed\":null}]]\n#     [\"some text here \\\\<<!foo>> and some there\",\"some text here \\\\<<!foo>> and some there\",[]]\n#     [\"some text here \\\\<<$foo>> and some there\",\"some text here \\\\<<$foo>> and some there\",[]]\n#     [\"some text here<!-- omit this --> and some there\",\"some text here<!-- omit this --> and some there\",[]]\n#     [\"abcd<<<some raw content>>>efg\",\"abcd<<<some raw content>>>efg\",[]]\n#     ]\n#   for [ probe, text_matcher, registry_matcher, ] in probes_and_matchers\n#     S = MKTS.MACRO_ESCAPER.initialize_state {}\n#     text_result = MKTS.MACRO_ESCAPER.escape.command_and_value_macros S, probe\n#     help JSON.stringify [ probe, text_result, S.MACRO_ESCAPER[ 'registry' ], ]\n#     T.eq text_result, text_matcher\n#     T.eq S.MACRO_ESCAPER[ 'registry' ], registry_matcher\n#   done()\n\n# # # # #-----------------------------------------------------------------------------------------------------------\n# # # # @[ \"MKTS.MACRO_ESCAPER.escape 1\" ] = ( T, done ) ->\n# # # #   probes_and_matchers = [\n# # # #     [\"<<(multi-column 3>>\\nsome text here<!-- omit this --> and some there\\n<<)>>\\n<<(multi-column 2>>\\nThis text will appear in two-column<!-- omit this --> layout.\\n<!--some code-->\\n<<(:>>some code<<)>>\\n<<)>>\\n<<!end>>\\n<<!command>><<(:action>><<)>>\",\"\\u0015region4\\u0013\\nsome text here\\u0015comment0\\u0013 and some there\\n\\u0015region5\\u0013\\n\\u0015region6\\u0013\\nThis text will appear in two-column\\u0015comment1\\u0013 layout.\\n\\u0015comment2\\u0013\\n\\u0015action3\\u0013\\n\\u0015region7\\u0013\\n\",[{\"key\":\"comment0\",\"markup\":null,\"raw\":\" omit this \",\"parsed\":\"omit this\"},{\"key\":\"comment1\",\"markup\":null,\"raw\":\" omit this \",\"parsed\":\"omit this\"},{\"key\":\"comment2\",\"markup\":null,\"raw\":\"some code\",\"parsed\":\"some code\"},{\"key\":\"action3\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"some code\",\"parsed\":null},{\"key\":\"region4\",\"markup\":\"multi-column 3\",\"raw\":\"<<(multi-column 3>>\",\"parsed\":null},{\"key\":\"region5\",\"markup\":\"multi-column 3\",\"raw\":\"<<)>>\",\"parsed\":null},{\"key\":\"region6\",\"markup\":\"multi-column 2\",\"raw\":\"<<(multi-column 2>>\",\"parsed\":null},{\"key\":\"region7\",\"markup\":\"multi-column 2\",\"raw\":\"<<)>>\",\"parsed\":null}]]\n# # # #     ]\n# # # #   for [ probe, text_matcher, registry_matcher, ] in probes_and_matchers\n# # # #     S = MKTS.MACRO_ESCAPER.initialize_state {}\n# # # #     text_result = MKTS.MACRO_ESCAPER.escape S, probe\n# # # #     help JSON.stringify [ probe, text_result, S.MACRO_ESCAPER[ 'registry' ], ]\n# # # #     T.eq text_result, text_matcher\n# # # #     T.eq S.MACRO_ESCAPER[ 'registry' ], registry_matcher\n# # # #   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.escape 2\" ] = ( T, done ) ->\n#   probes_and_matchers = [[\n#     \"\"\"<<(multi-column 3>>\n#       some text here<!-- HTML comment 1 --> and some there\n#       <<)>>\n#       <<(multi-column 2>>\n#       This text will appear in two-column<!-- HTML comment 2 --> layout.\n#       <<(:>>some code<<)>>\n#       <<)>>\n#       <<!end>>\n#       <<!command>><<(:action>><<)>>\n#       \"\"\"\n#     ,\n#       \"\"\"\\x15region3\\x13\n#       some text here\\x15comment0\\x13 and some there\n#       \\x15region5\\x13\n#       \\x15region4\\x13\n#       This text will appear in two-column\\x15comment1\\x13 layout.\n#       \\x15action2\\x13\n#       \\x15region6\\x13\\n\"\"\"\n#     ,\n#       [\n#         {\"key\":\"comment0\",\"markup\":null,\"raw\":\" HTML comment 1 \",\"parsed\":\"HTML comment 1\"}\n#         {\"key\":\"comment1\",\"markup\":null,\"raw\":\" HTML comment 2 \",\"parsed\":\"HTML comment 2\"}\n#         {\"key\":\"action2\",\"markup\":[\"vocal\",\"coffee\"],\"raw\":\"some code\",\"parsed\":null}\n#         {\"key\":\"region3\",\"markup\":\"(\",\"raw\":\"multi-column 3\",\"parsed\":null}\n#         {\"key\":\"region4\",\"markup\":\"(\",\"raw\":\"multi-column 2\",\"parsed\":null}\n#         {\"key\":\"region5\",\"markup\":\")\",\"raw\":\"\",\"parsed\":null}\n#         {\"key\":\"region6\",\"markup\":\")\",\"raw\":\"\",\"parsed\":null}\n#         ]\n#       ]]\n#   for [ probe, text_matcher, registry_matcher, ] in probes_and_matchers\n#     S = MKTS.MACRO_ESCAPER.initialize_state {}\n#     text_result = MKTS.MACRO_ESCAPER.escape S, probe\n#     urge nice_text_rpr probe\n#     info nice_text_rpr text_result\n#     help JSON.stringify entry for entry in S.MACRO_ESCAPER[ 'registry' ]\n#     T.eq text_result,             text_matcher\n#     T.eq S.MACRO_ESCAPER[ 'registry' ],  registry_matcher\n#   # T.fail \"not ready\"\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.$expand_html_comments\" ] = ( T, done ) ->\n#   probes_and_matchers = [[\n#     \"\"\"<<(multi-column 3>>\n#       some text here<!-- HTML comment 1 --> and some there\n#       <<)>>\n#       <<(multi-column 2>>\n#       This text will appear in two-column<!-- HTML comment 2 --> layout.\n#       <<(:>>some code<<)>>\n#       <<)>>\n#       <<!end>>\n#       <<!command>><<(:action>><<)>>\n#       \"\"\"\n#     ,\n#       [\n#         [\".\",\"text\",\"\\u0015region3\\u0013\\nsome text here\",{}]\n#         [\".\",\"comment\",\" HTML comment 1 \",{}]\n#         [\".\",\"text\",\" and some there\\n\\u0015region5\\u0013\\n\\u0015region4\\u0013\\nThis text will appear in two-column\",{}]\n#         [\".\",\"comment\",\" HTML comment 2 \",{}]\n#         [\".\",\"text\",\" layout.\\n\\u0015action2\\u0013\\n\\u0015region6\\u0013\\n\",{}]\n#       ]\n#       ]]\n#   for [ pre_probe, matcher, ] in probes_and_matchers\n#     S       = MKTS.MACRO_ESCAPER.initialize_state {}\n#     probe   = MKTS.MACRO_ESCAPER.escape S, pre_probe\n#     input   = D.stream_from_text probe\n#     stream  = input\n#       .pipe $ ( text, send ) =>\n#         send [ '.', 'text', text, {}, ]\n#     D.call_transform stream, ( => MKTS.MACRO_ESCAPER.$expand_html_comments S ), ( error, result ) =>\n#       log CND.white JSON.stringify event for event in result\n#       T.eq result, matcher\n#       done()\n#     input.resume()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.$expand_action_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [[\n#     \"\"\"some text with <<(:>>vocal action<<)>>.\n#       <<(.js>>and( \"a silent action\" )<<.js)>>\n#       \"\"\"\n#   ,\n#     [\n#       [\".\",\"text\",\"some text with \",{}]\n#       [\".\",\"action\",\"vocal action\",{\"mode\":\"vocal\",\"language\":\"coffee\"}]\n#       [\".\",\"text\",\".\\n\",{}]\n#       [\".\",\"action\",\"and( \\\"a silent action\\\" )\",{\"mode\":\"silent\",\"language\":\"js\"}]\n#       ]\n#     ]]\n#   for [ pre_probe, matcher, ] in probes_and_matchers\n#     S       = MKTS.MACRO_ESCAPER.initialize_state {}\n#     probe   = MKTS.MACRO_ESCAPER.escape S, pre_probe\n#     input   = D.stream_from_text probe\n#     stream  = input\n#       .pipe $ ( text, send ) =>\n#         send [ '.', 'text', text, {}, ]\n#     D.call_transform stream, ( => MKTS.MACRO_ESCAPER.$expand_action_macros S ), ( error, result ) =>\n#       log CND.white JSON.stringify event for event in result\n#       T.eq result, matcher\n#       # T.fail \"not ready\"\n#       done()\n#     input.resume()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.$expand_raw_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [[\n#     \"\"\"<<(multi-column 3>>\n#       some text here<<<\\\\LaTeX{}>>> and some there\n#       <<)>>\n#       \"\"\"\n#   ,\n#     [\n#       [\".\",\"text\",\"\\u0015region1\\u0013\\nsome text here\",{}]\n#       [\".\",\"raw\",\"\\\\LaTeX{}\",{}]\n#       [\".\",\"text\",\" and some there\\n\\u0015region2\\u0013\",{}]\n#       ]\n#     ]]\n#   for [ pre_probe, matcher, ] in probes_and_matchers\n#     S       = MKTS.MACRO_ESCAPER.initialize_state {}\n#     probe   = MKTS.MACRO_ESCAPER.escape S, pre_probe\n#     input   = D.stream_from_text probe\n#     stream  = input\n#       .pipe $ ( text, send ) =>\n#         send [ '.', 'text', text, {}, ]\n#     D.call_transform stream, ( => MKTS.MACRO_ESCAPER.$expand_raw_macros S ), ( error, result ) =>\n#       log CND.white JSON.stringify event for event in result\n#       T.eq result, matcher\n#       # T.fail \"not ready\"\n#       done()\n#     input.resume()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.$expand_command_and_value_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [[\n#     \"\"\"<<(multi-column 3>>\n#       a command <<!LATEX>> and a value <<$pagenr>>.\n#       <<)>>\n#       \"\"\"\n#   ,\n#     [\n#       [\".\",\"text\",\"\\u0015region0\\u0013\\na command \",{}]\n#       [\".\",\"command\",\"LATEX\",{}]\n#       [\".\",\"text\",\" and a value \",{}]\n#       [\".\",\"value\",\"pagenr\",{}]\n#       [\".\",\"text\",\".\\n\\u0015region1\\u0013\",{}]\n#       ]\n#     ]]\n#   for [ pre_probe, matcher, ] in probes_and_matchers\n#     S       = MKTS.MACRO_ESCAPER.initialize_state {}\n#     probe   = MKTS.MACRO_ESCAPER.escape S, pre_probe\n#     # debug '©ΖΡΤΣΓ', S\n#     input   = D.stream_from_text probe\n#     stream  = input\n#       .pipe $ ( text, send ) =>\n#         send [ '.', 'text', text, {}, ]\n#     D.call_transform stream, ( => MKTS.MACRO_ESCAPER.$expand_command_and_value_macros S ), ( error, result ) =>\n#       log CND.white JSON.stringify event for event in result\n#       T.eq result, matcher\n#       # T.fail \"not ready\"\n#       done()\n#     input.resume()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MACRO_ESCAPER.$expand_region_macros\" ] = ( T, done ) ->\n#   probes_and_matchers = [[\n#     \"\"\"<<(multi-column 3>>\n#       some text here<!-- omit this --> and some there\n#       <<)>>\n#       <<(multi-column 2>>\n#       This text will appear in two-column<!-- omit this --> layout.\n#       <!--some code-->\n#       <<(:>>some code<<)>>\n#       <<)>>\n#       <<!end>>\n#       <<!command>><<(:action>><<)>>\n#       \"\"\"\n#   ,\n#     [\n#       [\"(\",\"multi-column 3\",null,{}]\n#       [\".\",\"text\",\"\\nsome text here\\u0015comment0\\u0013 and some there\\n\",{}]\n#       [\")\",\"\",null,{}]\n#       [\".\",\"text\",\"\\n\",{}]\n#       [\"(\",\"multi-column 2\",null,{}]\n#       [\".\",\"text\",\"\\nThis text will appear in two-column\\u0015comment1\\u0013 layout.\\n\\u0015comment2\\u0013\\n\\u0015action3\\u0013\\n\",{}]\n#       [\")\",\"\",null,{}]\n#       [\".\",\"text\",\"\\n\",{}]\n#       ]\n#     ]]\n#   for [ pre_probe, matcher, ] in probes_and_matchers\n#     S       = MKTS.MACRO_ESCAPER.initialize_state {}\n#     probe   = MKTS.MACRO_ESCAPER.escape S, pre_probe\n#     input   = D.stream_from_text probe\n#     stream  = input\n#       .pipe $ ( text, send ) =>\n#         send [ '.', 'text', text, {}, ]\n#     D.call_transform stream, ( => MKTS.MACRO_ESCAPER.$expand_region_macros S ), ( error, result ) =>\n#       log CND.white JSON.stringify event for event in result\n#       T.eq result, matcher\n#       # T.fail \"not ready\"\n#       done()\n#     input.resume()\n\n# ### # # # ###\n# ### # # # ###\n# ### # # # ###\n# ### # # # ###\n# ### # # # ###\n# ### # # # ###\n# ### # # # ###\n# ### # # # ###\n# ### # # # ###\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.FENCES.parse accepts dot patterns\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [ '.',     [ '.', null,   null, ], ]\n#     [ '.p',    [ '.', 'p',    null, ], ]\n#     [ '.text', [ '.', 'text', null, ], ]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     # help ( rpr probe ), MKTS.MD_READER.FENCES.parse probe\n#     T.eq ( MKTS.MD_READER.FENCES.parse probe ), matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.FENCES.parse accepts empty fenced patterns\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     # [ '<>', [ '<', null, '>', ], ]\n#     # [ '{}', [ '{', null, '}', ], ]\n#     # [ '[]', [ '[', null, ']', ], ]\n#     [ '()', [ '(', null, ')', ], ]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     # help ( rpr probe ), MKTS.MD_READER.FENCES.parse probe\n#     T.eq ( MKTS.MD_READER.FENCES.parse probe ), matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.FENCES.parse accepts unfenced named patterns\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [ 'document',       [ null, 'document',     null, ], ]\n#     [ 'singlecolumn',   [ null, 'singlecolumn', null, ], ]\n#     [ 'code',           [ null, 'code',         null, ], ]\n#     [ 'blockquote',     [ null, 'blockquote',   null, ], ]\n#     [ 'em',             [ null, 'em',           null, ], ]\n#     [ 'xxx',            [ null, 'xxx',          null, ], ]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     # help ( rpr probe ), MKTS.MD_READER.FENCES.parse probe\n#     T.eq ( MKTS.MD_READER.FENCES.parse probe ), matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.FENCES.parse accepts fenced named patterns\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     # [ '<document>',     [ '<', 'document',     '>', ], ]\n#     # [ '{singlecolumn}', [ '{', 'singlecolumn', '}', ], ]\n#     # [ '{code}',         [ '{', 'code',         '}', ], ]\n#     # [ '[blockquote]',   [ '[', 'blockquote',   ']', ], ]\n#     [ '(em)',           [ '(', 'em',           ')', ], ]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     # help ( rpr probe ), MKTS.MD_READER.FENCES.parse probe\n#     T.eq ( MKTS.MD_READER.FENCES.parse probe ), matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.FENCES.parse rejects empty string\" ] = ( T, done ) ->\n#   T.throws \"pattern must be non-empty, got ''\", ( -> MKTS.MD_READER.FENCES.parse '' )\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.FENCES.parse rejects non-matching fences etc\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [\"(xxx}\",\"unmatched fence in '(xxx}'\"]\n#     [\".)\",\"fence '.' can not have right fence, got '.)'\"]\n#     [\".p)\",\"fence '.' can not have right fence, got '.p)'\"]\n#     [\"(xxx\",\"unmatched fence in '(xxx'\"]\n#     [\"(\",\"unmatched fence in '('\"]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     try\n#       debug '©ΒΩΦΥΨ', JSON.stringify [ probe, MKTS.MD_READER.FENCES.parse probe ]\n#     catch error\n#       warn '©ΒΩΦΥΨ', JSON.stringify [ probe, error[ 'message' ], ]\n#     T.throws matcher, ( -> MKTS.MD_READER.FENCES.parse probe )\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.FENCES.parse accepts non-matching fences when so configured\" ] = ( T, done ) ->\n#   probes_and_matchers = [\n#     [ '(em)',           [ '(', 'em',           ')', ], ]\n#     [ 'em)',            [ null, 'em',           ')', ], ]\n#     [ '(em',            [ '(', 'em',           null, ], ]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     # help ( rpr probe ), MKTS.MD_READER.FENCES.parse probe\n#     T.eq ( MKTS.MD_READER.FENCES.parse probe, symmetric: no ), matcher\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.TRACKER.new_tracker().track rejects unregistered pattern\" ] = ( T, done ) ->\n#   track = MKTS.MD_READER.TRACKER.new_tracker '(code)', '(em)'\n#   T.throws \"untracked pattern '(code-span)'\", ( => track.within '(code-span)' )\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MD_READER.TRACKER.new_tracker (short comprehensive test)\" ] = ( T, done ) ->\n#   track = MKTS.MD_READER.TRACKER.new_tracker '(code-span)', '(em)'\n#   probes_and_matchers = [\n#     [[\"(\",\"code-span\"],[true,false]]\n#     [[\"(\",\"em\"],[true,true]]\n#     [[\".\",\"text\"],[true,true]]\n#     [[\")\",\"em\"],[true,false]]\n#     [[\".\",\"text\"],[true,false]]\n#     [[\")\",\"code-span\"],[false,false]]\n#     [[\".\",\"text\"],[false,false]]\n#     ]\n#   for [ probe, matcher, ] in probes_and_matchers\n#     track probe\n#     within_code_span  = track.within '(code-span)'\n#     within_em         = track.within '(em)'\n#     help JSON.stringify [ probe, [ within_code_span, within_em, ], ]\n#     T.eq ( track.within '(code-span)' ), matcher[ 0 ]\n#     T.eq ( track.within '(em)'        ), matcher[ 1 ]\n#   done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (1)\" ] = ( T, done ) ->\n#   # settings  = bare: yes\n#   probe     = \"\"\"123 `abc<<(:>>vocal action<<)>>def` 456\"\"\"\n#   warn \"should merge texts\"\n#   matcher   = [\n#     [\"(\",\"document\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"text\",\"123 \",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\"(\",\"code-span\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"`\"}]\n#     [\".\",\"text\",\"abc\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"action\",\"vocal action\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\",\"mode\":\"vocal\",\"language\":\"coffee\",\"hidden\":true,\"stamped\":true}]\n#     [\".\",\"warning\",\"line 1: vocal is not defined\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\",\"mode\":\"vocal\",\"language\":\"coffee\",\"hidden\":false,\"stamped\":false}]\n#     [\".\",\"text\",\"def\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\")\",\"code-span\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"`\"}]\n#     [\".\",\"text\",\" 456\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\")\",\"document\",null,{}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (2)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   # probe     = \"\"\"abc<<(:js>>f( 42 );<<:js)>>def\"\"\"\n#   probe     = \"\"\"abc<<(:js>>42;<<:js)>>def\"\"\"\n#   warn \"should merge texts\"\n#   matcher   = [\n#     [\".\",\"text\",\"abc\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"action\",\"42;\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\",\"mode\":\"vocal\",\"language\":\"js\",\"hidden\":true,\"stamped\":true}]\n#     [\".\",\"text\",\"42\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\",\"mode\":\"vocal\",\"language\":\"js\",\"hidden\":true,\"stamped\":true}]\n#     [\".\",\"text\",\"def\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n#-----------------------------------------------------------------------------------------------------------\n@[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (3)\" ] = ( T, done ) ->\n  settings  = bare: yes\n  probe     = \"\"\"abc\\\\<<(:js\\\\>>f( 42 );\\\\<<:js)\\\\>>def\"\"\"\n  warn \"should merge texts\"\n  matcher   = [\n    [\".\",\"text\",\"abc<<(:js>>f( 42 );<<:js)>>def\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n    [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n    ]\n  step ( resume ) =>\n    result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n    show_events probe, result\n    T.eq matcher, result\n    done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (4)\" ] = ( T, done ) ->\n#   settings  = bare: no\n#   probe     = \"\"\"<<!end>>\"\"\"\n#   warn \"match remark?\"\n#   matcher   = [\n#     [\"(\",\"document\",null,{}]\n#     [\".\",\"command\",\"empty-document\",{}]\n#     [\")\",\"document\",null,{}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (5)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"<<!multi-column>>\"\"\"\n#   warn \"should not contain `.p`\"\n#   matcher   = [\n#     [\".\",\"command\",\"multi-column\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (6)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"\n#     aaa\n#     <<(multi-column>>\n#     bbb\n#     <<multi-column)>>\n#     ccc\n#     \"\"\"\n#   warn \"missing `.p` inside `(multi-column)`\"\n#   matcher   = [\n#     [\".\",\"text\",\"aaa\\n\",{\"line_nr\":1,\"col_nr\":6,\"markup\":\"\"}]\n#     [\"(\",\"multi-column\",null,{\"line_nr\":1,\"col_nr\":6,\"markup\":\"\"}]\n#     [\".\",\"text\",\"\\nbbb\\n\",{\"line_nr\":1,\"col_nr\":6,\"markup\":\"\"}]\n#     [\")\",\"multi-column\",null,{\"line_nr\":1,\"col_nr\":6,\"markup\":\"\"}]\n#     [\".\",\"text\",\"\\nccc\",{\"line_nr\":1,\"col_nr\":6,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":6,\"markup\":\"\"}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (7)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"\n#     她說：「你好。」\n#     \"\"\"\n#   # warn \"missing `.p` inside `(multi-column)`\"\n#   matcher   = [\n#     [\".\",\"text\",\"她說：「你好。」\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md (8)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"\n#     A paragraph with *emphasis*.\n\n#     A paragraph with **bold text**.\n#     \"\"\"\n#   # warn \"missing `.p` inside `(multi-column)`\"\n#   matcher   = [\n#     [\".\",\"text\",\"A paragraph with \",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\"(\",\"em\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"*\"}]\n#     [\".\",\"text\",\"emphasis\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\")\",\"em\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"*\"}]\n#     [\".\",\"text\",\".\",{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":2,\"markup\":\"\"}]\n#     [\".\",\"text\",\"A paragraph with \",{\"line_nr\":3,\"col_nr\":4,\"markup\":\"\"}]\n#     [\"(\",\"strong\",null,{\"line_nr\":3,\"col_nr\":4,\"markup\":\"**\"}]\n#     [\".\",\"text\",\"bold text\",{\"line_nr\":3,\"col_nr\":4,\"markup\":\"\"}]\n#     [\")\",\"strong\",null,{\"line_nr\":3,\"col_nr\":4,\"markup\":\"**\"}]\n#     [\".\",\"text\",\".\",{\"line_nr\":3,\"col_nr\":4,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":3,\"col_nr\":4,\"markup\":\"\"}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mkts_events_from_md: footnotes\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"\n#     Here is an inline footnote^[whose text appears at the point of insertion],\n#     followed by a referenced footnote[^1].\n\n#     [^1]: Referenced footnotes must use matching references.\n#     \"\"\"\n#   # warn \"missing `.p` inside `(multi-column)`\"\n#   matcher   = [\n#     [\".\",\"text\",\"Here is an inline footnote\",{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\"(\",\"footnote\",0,{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\".\",\"text\",\"whose text appears at the point of insertion\",{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\")\",\"footnote\",0,{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\".\",\"text\",\",\\nfollowed by a referenced footnote\",{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\"(\",\"footnote\",1,{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\".\",\"text\",\"Referenced footnotes must use matching references.\",{\"line_nr\":4,\"col_nr\":5,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":4,\"col_nr\":5,\"markup\":\"\"}]\n#     [\")\",\"footnote\",1,{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\".\",\"text\",\".\",{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     [\".\",\"p\",null,{\"line_nr\":1,\"col_nr\":3,\"markup\":\"\"}]\n#     ]\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mkts_events_from_md probe, settings, resume\n#     show_events probe, result\n#     T.eq matcher, result\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.TEX_WRITER.tex_from_md (1)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"\n#     A paragraph with *emphasis*.\n\n#     A paragraph with **bold text**.\n#     \"\"\"\n#   # warn \"missing `.p` inside `(multi-column)`\"\n#   matcher   = \"\"\"\n#     % begin of MD document\n#     A paragraph with {\\\\mktsStyleItalic{}emphasis\\\\/}.\\\\mktsShowpar\\\\par\n#     A paragraph with {\\\\mktsStyleBold{}bold text}.\\\\mktsShowpar\\\\par\n\n#     % end of MD document\n\n#     \"\"\"\n#   step ( resume ) =>\n#     result = yield MKTS.TEX_WRITER.tex_from_md probe, settings, resume\n#     echo result\n#     T.eq matcher.trim(), result.trim()\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mktscript_from_md (1)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"\n#     A paragraph with *emphasis*.\n\n#     A paragraph with **bold text**.\n\n#     Using <foo>HTML tags **inhibits** MD syntax</foo>.\n#     \"\"\"\n#   # warn \"missing `.p` inside `(multi-column)`\"\n#   matcher   = \"\"\"\n#     1 █ (document\n#     1 █ .text 'A paragraph with '\n#     1 █ (em\n#     1 █ .text 'emphasis'\n#     1 █ )em\n#     1 █ .text '.'\n#     1 █ .p\n#     3 █ .text 'A paragraph with '\n#     3 █ (strong\n#     3 █ .text 'bold text'\n#     3 █ )strong\n#     3 █ .text '.'\n#     3 █ .p\n#     5 █ .text 'Using '\n#     5 █ (foo\n#     5 █ .text 'HTML tags '\n#     5 █ (strong\n#     5 █ .text 'inhibits'\n#     5 █ )strong\n#     5 █ .text ' MD syntax'\n#     5 █ )foo\n#     5 █ .text '.'\n#     5 █ .p\n#     )document\n#     # EOF\n#     \"\"\"\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mktscript_from_md probe, settings, resume\n#     echo result\n#     T.eq matcher.trim(), result.trim()\n#     done()\n\n# #-----------------------------------------------------------------------------------------------------------\n# @[ \"MKTS.MKTSCRIPT_WRITER.mktscript_from_md (2)\" ] = ( T, done ) ->\n#   settings  = bare: yes\n#   probe     = \"\"\"\n#     <<(multi-column>>\n\n#     <div>B</div>\n\n#     \"\"\"\n#   # warn \"missing `.p` inside `(multi-column)`\"\n#   matcher   = \"\"\"\n#     1 █ (document\n#     1 █ (multi-column\n#     1 █ .p\n#     1 █ (div\n#     1 █ .text 'B'\n#     1 █ )div\n#     1 █ .p\n#     #resend '`multi-column)`'\n#     1 █ )multi-column\n#     )document\n#     # EOF\n#     \"\"\"\n#   step ( resume ) =>\n#     result = yield MKTS.MKTSCRIPT_WRITER.mktscript_from_md probe, settings, resume\n#     echo result\n#     T.eq matcher.trim(), result.trim()\n#     # T.fail \"not yet ready\"\n#     done()\n\n\n#===========================================================================================================\n# MAIN\n#-----------------------------------------------------------------------------------------------------------\n@_main = ( handler ) ->\n  test @, 'timeout': 2500\n\n\n############################################################################################################\nunless module.parent?\n  @_main()\n\n"]}