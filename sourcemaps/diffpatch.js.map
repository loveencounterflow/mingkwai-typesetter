{"version":3,"sources":["diffpatch.coffee"],"names":[],"mappings":";AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA,MAAA;;EAwPA,IAAA,GAA4B,OAAA,CAAQ,WAAR;;EAC5B,MAAA,GAA4B,OAAA,CAAQ,QAAR;;EAG5B,IAAC,CAAA,QAAD,GAAY,SAAE,QAAF;WAAqB,MAAM,CAAC,SAAP,CAAiB,QAAjB;EAArB;;EACZ,IAAC,CAAA,IAAD,GAAY,SAAE,CAAF,EAAK,CAAL;WAAqB,IAAA,CAAK,CAAL,EAAQ,CAAR;EAArB;;EACZ,IAAC,CAAA,KAAD,GAAY,SAAE,SAAF,EAAa,CAAb;WAAqB,IAAI,CAAC,KAAL,CAAW,SAAX,EAAsB,CAAtB;EAArB;AA9PZ","file":"diffpatch.js","sourceRoot":"/source/","sourcesContent":["\n\n###\n\n\n## Motivation\n\nThis module is a slight shim for [`changeset`](https://github.com/eugeneware/changeset), an amazing\n(and small!) piece of software that does diffing (i.e. changeset generation) and patching (i.e.\nchangeset application) for nested JavaScript datastructures.\n\nChnagesets are implemented as lists of PODs, each detailing one atomic change step and formatted\nso they can be directly fit into a (suitably structured) LvelDB instance (using `level`/`levelup`).\nIt even claims to respect cyclic references, which is great.\n\nWe're here less concerned with feeding changesets into a DB; rather, the problem we want\nto solve is how to keep track of local state within a processing pipeline.\n\nAs an example, let's consider this MD document:\n\n```md\n<<(.>>@S.COLUMNS.count = 3<<)>>\n<<!columns>>\n<<!yadda>>\n\n<<(.>>@S.COLUMNS.count = 4<<)>>\n<<!columns>>\n<<!yadda>>\n```\n\nWe want this source to result in a PDF that has two paragraphs of Lore Ipsum mumbo (``<<!yadda>>`),\nthe first one typeset into three (`<<(.>>@S.COLUMNS.count = 3<<)>>`), and the second one into\nfour (`<<(.>>@S.COLUMNS.count = 4<<)>>`) columns (`<<!columns>>`).\n\nIf we were to use global state—which is communicated via the `S` variable—then that *might* work\nout as long as the chain of piped transforms were to act in a strictly lockstep fashion; in other\nwords, if each event that originates somewhere near the top of the chain were guaranteed to be fully\nprocessed and its consequences all written out to the bottom of the chain before the next event\ngets to be processed. However, that is not the case, since some processing steps like footnotes\nand TOC compilation need to buffer the entire sequence of events before giving control to the\nensuing step (otherwise you can't have a table of contents in the opening matter of a book).\n\nIn the presence of such buffering, a phenomenon reminiscent of a 'failed closure' surfaces: some\nstep early on knows that the default column count is 2, and may set global state accordingly; at\nsome later point, a change to 3 is encountered, and S gets changed; still later, a change to 4\nis encountered, and S will be modified again. But in the presence of an intermediate buffering\nstep, that step will only send on events once the document has been finished, and all that remains\nin global state is a setting of 4, not 2 or 3 columns per page.\n\nThe solution to this problem is to treat changes to local state like any other instructions\nfrom the document source, have them travel down the chain of transforms as events, and require\nall interested parties to listen to those change events and rebuild their local copies of local\nstate themselves. This adds a certain overhead to processing, but the upside is that we can\nalways be sure that local state will be up to date within each stream transform as long as\nevents don't get re-ordered.\n\n\n## Usage\n\nThe DIFFPATCH (DP) API is fairly minimal; you get three methods:\n\n```coffee\n@snapshot = ( original )      -> LODASH.cloneDeep original\n@diff     = ( x, y )          -> diff x, y\n@patch    = ( changeset, x )  -> diff.apply changeset, x\n```\n\n`DP.diff x, y` results in a changeset (a list of changes) that tells you which steps are needed\nto modify `x` so that it will test deep-equal to `y`. Changesets are what we'll send doen the\npipeline; there'll be a single initial changeset after the document construction stream has started\nthat allows any interested parties to 'jumpstart', as it were, their local state copy:\nyou take an empty POD `local = {}`, apply the changeset, and you're good:\n`local = DP.patch changeset, local`.\n\nIn case a stream transform has to modify local state, it needs a reference point on which to base\nits own change events unto, which is what `DO.snapshot` is for:\n\n```coffee\nbackup            = DIFFPATCH.snapshot local               # create reference point\nlocal             = DIFFPATCH.patch changeset_event, local # update local state\n[...]\nlocal.n           = 12345678                               # modify local state\n[...]\nchangeset_out     = DIFFPATCH.diff backup, local           # create changeset for\n                                                           # ensuing transforms to listen to\n```\n\n```\n\n#-----------------------------------------------------------------------------------------------------------\ntest_functions_in_changeset = ->\n  rpr = ( x ) -> ( ( require 'util' ).inspect x, colors: yes, depth: 2 ).replace /\\n * /g, ' '\n  my_function = -> 108\n  #.........................................................................................................\n  changeset_event = null\n  do =>\n    sandbox =\n      n:        42\n      f:        my_function\n      foo:      Array.from 'shrdlu'\n      bar:      { x: 33, y: 54, f: my_function, }\n    changeset_event = DIFFPATCH.diff {}, sandbox\n  #.........................................................................................................\n  do =>\n    local             = DIFFPATCH.patch changeset_event, {}\n    backup            = DIFFPATCH.snapshot local\n    log CND.truth  local[ 'f' ] is my_function\n    log CND.truth backup[ 'f' ] is my_function\n    whisper 'A', backup\n    local.n           = 12345678\n    local.bar[ 'x' ]  = 2357\n    local.foo.push 'ZZ'\n    changeset_out     = DIFFPATCH.diff backup, local\n    log CND.truth  local[ 'f' ] is my_function\n    log CND.truth backup[ 'f' ] is my_function\n    # log rpr local\n    #.........................................................................................................\n    for change in changeset_out\n      log 'C', rpr change\n  #.........................................................................................................\n# test_functions_in_changeset()\n\n#-----------------------------------------------------------------------------------------------------------\ntest_changeset = ->\n  LODASH                    = require 'lodash'\n  D                         = require 'pipedreams'\n  $                         = D.remit.bind D\n  $async                    = D.remit_async.bind D\n  $observe                  = D.$observe.bind D\n  MD_READER                 = ( require '../mingkwai-typesetter' ).MD_READER\n  hide                      = MD_READER.hide.bind        MD_READER\n  copy                      = MD_READER.copy.bind        MD_READER\n  stamp                     = MD_READER.stamp.bind       MD_READER\n  unstamp                   = MD_READER.unstamp.bind     MD_READER\n  select                    = MD_READER.select.bind      MD_READER\n  is_hidden                 = MD_READER.is_hidden.bind   MD_READER\n  is_stamped                = MD_READER.is_stamped.bind  MD_READER\n  input                     = D.create_throughstream()\n  rpr                      = ( x ) -> ( ( require 'util' ).inspect x, colors: yes, depth: 2 ).replace /\\n * /g, ' '\n  #.........................................................................................................\n  sandbox =\n    f:        -> 108\n    n:        42\n    foo:      Array.from 'shrdlu'\n    bar:      { x: 33, y: 54, }\n  #.........................................................................................................\n  input\n    #.......................................................................................................\n    .pipe do =>\n      local   = {}\n      backup  = null\n      #.....................................................................................................\n      return $ ( event, send ) =>\n        #...................................................................................................\n        if select event, '~', 'change'\n          [ _, _, parameters, _, ]  = event\n          [ name, changeset, ]      = parameters\n          #.................................................................................................\n          if name is 'sandbox'\n            local   = DIFFPATCH.patch changeset, local\n          #.................................................................................................\n          send event\n        #...................................................................................................\n        else if select event, '~', 'add-ten'\n          send event\n          #.................................................................................................\n          backup    = DIFFPATCH.snapshot local\n          local.n   = ( local.n ? 0 ) + 10\n          changeset = DIFFPATCH.diff backup, local\n          #.................................................................................................\n          log 'A', rpr local\n          send [ '~', 'change', [ 'sandbox', changeset, ], null, ]\n        #...................................................................................................\n        else if select event, '~', 'frob'\n          send event\n          #.................................................................................................\n          backup    = DIFFPATCH.snapshot local\n          local.foo.push [ 'X', 'Y', 'Z', ]\n          changeset = DIFFPATCH.diff backup, local\n          #.................................................................................................\n          log 'A', rpr local\n          send [ '~', 'change', [ 'sandbox', changeset, ], null, ]\n        #...................................................................................................\n        else if select event, '~', 'drab'\n          send event\n          #.................................................................................................\n          backup    = DIFFPATCH.snapshot local\n          local.bar[ 'z' ] = local.foo\n          changeset = DIFFPATCH.diff backup, local\n          #.................................................................................................\n          log 'A', rpr local\n          send [ '~', 'change', [ 'sandbox', changeset, ], null, ]\n        #...................................................................................................\n        else\n          send event\n    #.......................................................................................................\n    # .pipe $observe ( event ) => log rpr event\n    #.......................................................................................................\n    .pipe $observe ( event ) =>\n      #.....................................................................................................\n      if select event, '~', 'change'\n        [ _, _, parameters, _, ]  = event\n        [ name, changeset, ]      = parameters\n        #.................................................................................................\n        if name is 'sandbox'\n          for change in changeset\n            whisper change\n    #.......................................................................................................\n    .pipe do =>\n      local   = {}\n      #.....................................................................................................\n      return $observe ( event ) =>\n        #...................................................................................................\n        if select event, '~', 'change'\n          [ _, _, parameters, _, ]  = event\n          [ name, changeset, ]      = parameters\n          #.................................................................................................\n          if name is 'sandbox'\n            local = DIFFPATCH.patch changeset, local\n            log 'B', rpr local\n  #.........................................................................................................\n  changeset = DIFFPATCH.diff {}, sandbox\n  input.write [ '~', 'change', [ 'sandbox', changeset, ], null, ]\n  input.write [ '~', 'add-ten', null, null, ]\n  # input.write [ '~', 'frob', null, null, ]\n  # input.write [ '~', 'drab', null, null, ]\n  input.end()\ntest_changeset()\n```\n\n\n###\n\n\n\n\n\n############################################################################################################\n# CND                       = require 'cnd'\n# rpr                       = CND.rpr\n# badge                     = 'MK/TS/JIZURA/main'\n# log                       = CND.get_logger 'plain',     badge\n# info                      = CND.get_logger 'info',      badge\n# whisper                   = CND.get_logger 'whisper',   badge\n# alert                     = CND.get_logger 'alert',     badge\n# debug                     = CND.get_logger 'debug',     badge\n# warn                      = CND.get_logger 'warn',      badge\n# help                      = CND.get_logger 'help',      badge\n# urge                      = CND.get_logger 'urge',      badge\n# echo                      = CND.echo.bind CND\ndiff                      = require 'changeset'\nLODASH                    = require 'lodash'\n\n#-----------------------------------------------------------------------------------------------------------\n@snapshot = ( original )      -> LODASH.cloneDeep original\n@diff     = ( x, y )          -> diff x, y\n@patch    = ( changeset, x )  -> diff.apply changeset, x\n"]}